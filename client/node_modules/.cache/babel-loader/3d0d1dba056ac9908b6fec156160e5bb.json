{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: react-moveable\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable\nversion: 0.21.6\n*/\nimport { createElement, PureComponent } from 'react';\nimport getAgent from '@egjs/agent';\nimport { prefixNames, ref, refs, prefixCSS, withMethods } from 'framework-utils';\nimport { splitUnit, isUndefined, isObject, splitBracket, isFunction, hasClass, find, findIndex, isString, isArray, dot, addClass, removeClass, splitComma, splitSpace } from '@daybrush/utils';\nimport styled from 'react-css-styled';\nimport Dragger from '@daybrush/drag';\nimport DragScroll from '@scena/dragscroll';\nimport ChildrenDiffer from '@egjs/children-differ';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction getSVGCursor(scale, degree) {\n  return \"data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\" + 32 * scale + \"px\\\" height=\\\"\" + 32 * scale + \"px\\\" viewBox=\\\"0 0 32 32\\\" ><path d=\\\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.2\\\" fill=\\\"black\\\" stroke=\\\"white\\\" style=\\\"transform:rotate(\" + degree + \"deg);transform-origin: 16px 16px\\\"></path></svg>\";\n}\n\nfunction getCursorCSS(degree) {\n  var x1 = getSVGCursor(1, degree);\n  var x2 = getSVGCursor(2, degree);\n  var degree45 = Math.round(degree / 45) * 45 % 180;\n  var defaultCursor = degree45 === 135 ? \"nwse-resize\" : degree45 === 45 ? \"nesw-resize\" : degree45 === 90 ? \"ew-resize\" : \"ns-resize\"; // 135\n  // tslint:disable-next-line: max-line-length\n\n  return \"cursor:\" + defaultCursor + \";cursor: url('\" + x1 + \"') 16 16, \" + defaultCursor + \";cursor: -webkit-image-set(url('\" + x1 + \"') 1x, url('\" + x2 + \"') 2x) 16 16, \" + defaultCursor + \";\";\n}\n\nvar agent = getAgent((typeof navigator !== \"undefined\" && navigator || {}).userAgent || \"\");\nvar IS_WEBKIT = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\nvar PREFIX = \"moveable-\";\nvar MOVEABLE_CSS = \"\\n{\\n\\tposition: fixed;\\n\\twidth: 1px;\\n\\theight: 1px;\\n\\tleft: 0;\\n\\ttop: 0;\\n    z-index: 3000;\\n    --zoom: 1;\\n    --zoompx: 1px;\\n}\\n.control-box {\\n    z-index: 0;\\n}\\n.line, .control {\\n\\tleft: 0;\\n    top: 0;\\n    will-change: transform;\\n}\\n.control {\\n\\tposition: absolute;\\n\\twidth: 14px;\\n\\theight: 14px;\\n\\tborder-radius: 50%;\\n\\tborder: 2px solid #fff;\\n\\tbox-sizing: border-box;\\n\\tbackground: #4af;\\n\\tmargin-top: -7px;\\n    margin-left: -7px;\\n    width: calc(14 * var(--zoompx));\\n    height: calc(14 * var(--zoompx));\\n    margin-top: calc(-7 * var(--zoompx));\\n    margin-left: calc(-7 * var(--zoompx));\\n    border: calc(2 * var(--zoompx)) solid #fff;\\n    z-index: 10;\\n}\\n.padding {\\n    position: absolute;\\n    top: 0px;\\n    left: 0px;\\n    width: 100px;\\n    height: 100px;\\n    transform-origin: 0 0;\\n}\\n.line {\\n\\tposition: absolute;\\n\\twidth: 1px;\\n    height: 1px;\\n    width: var(--zoompx);\\n    height: var(--zoompx);\\n\\tbackground: #4af;\\n\\ttransform-origin: 0px 50%;\\n}\\n.line.dashed {\\n    box-sizing: border-box;\\n    background: transparent;\\n}\\n.line.dashed.horizontal {\\n    border-top: 1px dashed #4af;\\n    border-top: var(--zoompx) dashed #4af;\\n}\\n.line.dashed.vertical {\\n    border-left: 1px dashed #4af;\\n    border-left: var(--zoompx) dashed #4af;\\n}\\n.line.dashed:before {\\n    position: absolute;\\n    content: attr(data-size);\\n    color: #4af;\\n    font-size: 12px;\\n    font-weight: bold;\\n}\\n.line.dashed.horizontal:before, .line.gap.horizontal:before {\\n    left: 50%;\\n    transform: translateX(-50%);\\n    bottom: 5px;\\n}\\n.line.dashed.vertical:before, .line.gap.vertical:before {\\n    top: 50%;\\n    transform: translateY(-50%);\\n    left: 5px;\\n}\\n.line.rotation-line {\\n\\theight: 40px;\\n    width: 1px;\\n    transform-origin: 50% calc(100% - 0.5px);\\n    top: -40px;\\n    width: var(--zoompx);\\n    height: calc(40 * var(--zoompx));\\n    top: calc(-40 * var(--zoompx));\\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\\n}\\n.line.rotation-line .control {\\n\\tborder-color: #4af;\\n\\tbackground:#fff;\\n    cursor: alias;\\n    left: 50%;\\n}\\n.line.vertical {\\n    transform: translateX(-50%);\\n}\\n.line.horizontal {\\n    transform: translateY(-50%);\\n}\\n.line.vertical.bold {\\n    width: 2px;\\n    width: calc(2 * var(--zoompx));\\n}\\n.line.horizontal.bold {\\n    height: 2px;\\n    height: calc(2 * var(--zoompx));\\n}\\n\\n.line.gap {\\n    background: #f55;\\n}\\n.line.gap:before {\\n    position: absolute;\\n    content: attr(data-size);\\n    color: #f55;\\n    font-size: 12px;\\n    font-weight: bold;\\n}\\n.control.origin {\\n\\tborder-color: #f55;\\n\\tbackground: #fff;\\n\\twidth: 12px;\\n\\theight: 12px;\\n\\tmargin-top: -6px;\\n    margin-left: -6px;\\n    width: calc(12 * var(--zoompx));\\n    height: calc(12 * var(--zoompx));\\n    margin-top: calc(-6 * var(--zoompx));\\n    margin-left: calc(-6 * var(--zoompx));\\n\\tpointer-events: none;\\n}\\n\" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {\n  return \"\\n.direction[data-rotation=\\\"\" + degree + \"\\\"] {\\n\\t\" + getCursorCSS(degree) + \"\\n}\\n\";\n}).join(\"\\n\") + \"\\n.group {\\n    z-index: -1;\\n}\\n.area {\\n    position: absolute;\\n}\\n.area-pieces {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    display: none;\\n}\\n.area.avoid {\\n    pointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\n    display: block;\\n}\\n.area-piece {\\n    position: absolute;\\n}\\n\\n\" + (IS_WEBKIT ? \":global svg *:before {\\n\\tcontent:\\\"\\\";\\n\\ttransform-origin: inherit;\\n}\" : \"\") + \"\\n\";\nvar NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];\nvar TINY_NUM = 0.0000001;\nvar MIN_SCALE = 0.000000001;\nvar MAX_NUM = Math.pow(10, 10);\nvar MIN_NUM = -MAX_NUM;\nvar DIRECTIONS = [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"];\nvar DIRECTION_INDEXES = {\n  n: [0, 1],\n  s: [2, 3],\n  w: [2, 0],\n  e: [1, 3],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n};\nvar DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n};\nvar MOVEABLE_METHODS = [\"isMoveableElement\", \"updateRect\", \"updateTarget\", \"destroy\", \"dragStart\", \"isInside\", \"hitTest\", \"setState\", \"getRect\", \"request\", \"isDragging\"];\n\nfunction add(matrix, inverseMatrix, startIndex, fromIndex, n, k) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    var fromX = fromIndex + i * n;\n    matrix[x] += matrix[fromX] * k;\n    inverseMatrix[x] += inverseMatrix[fromX] * k;\n  }\n}\n\nfunction swap(matrix, inverseMatrix, startIndex, fromIndex, n) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    var fromX = fromIndex + i * n;\n    var v = matrix[x];\n    var iv = inverseMatrix[x];\n    matrix[x] = matrix[fromX];\n    matrix[fromX] = v;\n    inverseMatrix[x] = inverseMatrix[fromX];\n    inverseMatrix[fromX] = iv;\n  }\n}\n\nfunction divide(matrix, inverseMatrix, startIndex, n, k) {\n  for (var i = 0; i < n; ++i) {\n    var x = startIndex + i * n;\n    matrix[x] /= k;\n    inverseMatrix[x] /= k;\n  }\n}\n\nfunction ignoreDimension(matrix, m, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n\n  for (var i = 0; i < n; ++i) {\n    newMatrix[i * n + m - 1] = 0;\n    newMatrix[(m - 1) * n + i] = 0;\n  }\n\n  newMatrix[(m - 1) * (n + 1)] = 1;\n  return newMatrix;\n}\n\nfunction invert(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = matrix.slice();\n  var inverseMatrix = createIdentityMatrix(n);\n\n  for (var i = 0; i < n; ++i) {\n    // diagonal\n    var identityIndex = n * i + i;\n\n    if (newMatrix[identityIndex] === 0) {\n      for (var j = i + 1; j < n; ++j) {\n        if (newMatrix[n * i + j]) {\n          swap(newMatrix, inverseMatrix, i, j, n);\n          break;\n        }\n      }\n    }\n\n    if (newMatrix[identityIndex]) {\n      divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n    } else {\n      // no inverse matrix\n      return [];\n    }\n\n    for (var j = 0; j < n; ++j) {\n      var targetStartIndex = j;\n      var targetIndex = j + i * n;\n      var target = newMatrix[targetIndex];\n\n      if (target === 0 || i === j) {\n        continue;\n      }\n\n      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n    }\n  }\n\n  return inverseMatrix;\n}\n\nfunction transpose(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = [];\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < n; ++j) {\n      newMatrix[j * n + i] = matrix[n * i + j];\n    }\n  }\n\n  return newMatrix;\n}\n\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nfunction getOrigin(matrix, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var originMatrix = [];\n\n  for (var i = 0; i < n - 1; ++i) {\n    originMatrix[i] = matrix[n * (n - 1) + i];\n  }\n\n  originMatrix[n - 1] = 0;\n  return originMatrix;\n}\n\nfunction convertPositionMatrix(matrix, n) {\n  var newMatrix = matrix.slice();\n\n  for (var i = matrix.length; i < n - 1; ++i) {\n    newMatrix[i] = 0;\n  }\n\n  newMatrix[n - 1] = 1;\n  return newMatrix;\n}\n\nfunction convertDimension(matrix, n, m) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  } // n < m\n\n\n  if (n === m) {\n    return matrix;\n  }\n\n  var newMatrix = createIdentityMatrix(m);\n  var length = Math.min(n, m);\n\n  for (var i = 0; i < length - 1; ++i) {\n    for (var j = 0; j < length - 1; ++j) {\n      newMatrix[i * m + j] = matrix[i * n + j];\n    }\n\n    newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n    newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n  }\n\n  newMatrix[m * m - 1] = matrix[n * n - 1];\n  return newMatrix;\n}\n\nfunction multiplies(n) {\n  var matrixes = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    matrixes[_i - 1] = arguments[_i];\n  }\n\n  var m = createIdentityMatrix(n);\n  matrixes.forEach(function (matrix) {\n    m = multiply(m, matrix, n);\n  });\n  return m;\n}\n\nfunction multiply(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = Math.sqrt(matrix.length);\n  }\n\n  var newMatrix = []; // 1 y: n\n  // 1 x: m\n  // 2 x: m\n  // 2 y: k\n  // n * m X m * k\n\n  var m = matrix.length / n;\n  var k = matrix2.length / m;\n\n  if (!m) {\n    return matrix2;\n  } else if (!k) {\n    return matrix;\n  }\n\n  for (var i = 0; i < n; ++i) {\n    for (var j = 0; j < k; ++j) {\n      newMatrix[j * n + i] = 0;\n\n      for (var l = 0; l < m; ++l) {\n        // m1 x: m(l), y: n(i)\n        // m2 x: k(j):  y: m(l)\n        // nw x: n(i), y: k(j)\n        newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n      }\n    }\n  } // n * k\n\n\n  return newMatrix;\n}\n\nfunction average() {\n  var nums = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    nums[_i] = arguments[_i];\n  }\n\n  var length = nums.length;\n  var total = 0;\n\n  for (var i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n\n  return length ? total / length : 0;\n}\n\nfunction plus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] + pos2[i];\n  }\n\n  return nextPos;\n}\n\nfunction minus(pos1, pos2) {\n  var length = Math.min(pos1.length, pos2.length);\n  var nextPos = pos1.slice();\n\n  for (var i = 0; i < length; ++i) {\n    nextPos[i] = nextPos[i] - pos2[i];\n  }\n\n  return nextPos;\n}\n\nfunction convertCSStoMatrix(a, is2d) {\n  if (is2d === void 0) {\n    is2d = a.length === 6;\n  }\n\n  if (is2d) {\n    return [a[0], a[1], 0, a[2], a[3], 0, a[4], a[5], 1];\n  }\n\n  return a;\n}\n\nfunction convertMatrixtoCSS(a, is2d) {\n  if (is2d === void 0) {\n    is2d = a.length === 9;\n  }\n\n  if (is2d) {\n    return [a[0], a[1], a[3], a[4], a[6], a[7]];\n  }\n\n  return a;\n}\n\nfunction caculate(matrix, matrix2, n) {\n  if (n === void 0) {\n    n = matrix2.length;\n  }\n\n  var result = multiply(matrix, matrix2, n);\n  var k = result[n - 1];\n  return result.map(function (v) {\n    return v / k;\n  });\n}\n\nfunction rotate(pos, rad) {\n  return caculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));\n}\n\nfunction createRotateMatrix(rad, n) {\n  var cos = Math.cos(rad);\n  var sin = Math.sin(rad);\n  var m = createIdentityMatrix(n); // cos -sin\n  // sin cos\n\n  m[0] = cos;\n  m[1] = sin;\n  m[n] = -sin;\n  m[n + 1] = cos;\n  return m;\n}\n\nfunction createIdentityMatrix(n) {\n  var length = n * n;\n  var matrix = [];\n\n  for (var i = 0; i < length; ++i) {\n    matrix[i] = i % (n + 1) ? 0 : 1;\n  }\n\n  return matrix;\n}\n\nfunction createScaleMatrix(scale, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(scale.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[(n + 1) * i] = scale[i];\n  }\n\n  return m;\n}\n\nfunction createOriginMatrix(origin, n) {\n  var m = createIdentityMatrix(n);\n  var length = Math.min(origin.length, n - 1);\n\n  for (var i = 0; i < length; ++i) {\n    m[n * (n - 1) + i] = origin[i];\n  }\n\n  return m;\n}\n\nfunction createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {\n  var x0 = pos0[0],\n      y0 = pos0[1];\n  var x1 = pos1[0],\n      y1 = pos1[1];\n  var x2 = pos2[0],\n      y2 = pos2[1];\n  var x3 = pos3[0],\n      y3 = pos3[1];\n  var u0 = nextPos0[0],\n      v0 = nextPos0[1];\n  var u1 = nextPos1[0],\n      v1 = nextPos1[1];\n  var u2 = nextPos2[0],\n      v2 = nextPos2[1];\n  var u3 = nextPos3[0],\n      v3 = nextPos3[1];\n  var matrix = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];\n  var inverseMatrix = invert(matrix, 8);\n\n  if (!inverseMatrix.length) {\n    return [];\n  }\n\n  var h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n  h[8] = 1;\n  return convertDimension(transpose(h), 3, 4);\n}\n\nfunction setDragStart(moveable, _a) {\n  var datas = _a.datas;\n  var _b = moveable.state,\n      matrix = _b.matrix,\n      beforeMatrix = _b.beforeMatrix,\n      is3d = _b.is3d,\n      left = _b.left,\n      top = _b.top,\n      origin = _b.origin,\n      offsetMatrix = _b.offsetMatrix,\n      targetMatrix = _b.targetMatrix,\n      transformOrigin = _b.transformOrigin;\n  var n = is3d ? 4 : 3;\n  datas.is3d = is3d;\n  datas.matrix = matrix;\n  datas.targetMatrix = targetMatrix;\n  datas.beforeMatrix = beforeMatrix;\n  datas.offsetMatrix = offsetMatrix;\n  datas.transformOrigin = transformOrigin;\n  datas.inverseMatrix = invert(matrix, n);\n  datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n  datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n  datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\n\nfunction getDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix,\n      inverseMatrix = datas.inverseMatrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(caculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);\n}\n\nfunction getInverseDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var beforeMatrix = datas.beforeMatrix,\n      matrix = datas.matrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(caculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);\n}\n\nfunction caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\n  if (prevWidth === void 0) {\n    prevWidth = width;\n  }\n\n  if (prevHeight === void 0) {\n    prevHeight = height;\n  }\n\n  if (prevOrigin === void 0) {\n    prevOrigin = [0, 0];\n  }\n\n  if (!transformOrigin) {\n    return prevOrigin;\n  }\n\n  return transformOrigin.map(function (pos, i) {\n    var _a = splitUnit(pos),\n        value = _a.value,\n        unit = _a.unit;\n\n    var prevSize = i ? prevHeight : prevWidth;\n    var size = i ? height : width;\n\n    if (pos === \"%\" || isNaN(value)) {\n      // no value but %\n      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n      return size * measureRatio;\n    } else if (unit !== \"%\") {\n      return value;\n    }\n\n    return size * value / 100;\n  });\n}\n\nfunction getPosIndexesByDirection(direction) {\n  var indexes = [];\n\n  if (direction[1] >= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(3);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(2);\n    }\n  }\n\n  if (direction[1] <= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(1);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(0);\n    }\n  }\n\n  return indexes;\n}\n\nfunction getPosesByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  return getPosIndexesByDirection(direction).map(function (index) {\n    return poses[index];\n  });\n}\n\nfunction getPosByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  var nextPoses = getPosesByDirection(poses, direction);\n  return [average.apply(void 0, nextPoses.map(function (pos) {\n    return pos[0];\n  })), average.apply(void 0, nextPoses.map(function (pos) {\n    return pos[1];\n  }))];\n}\n\nfunction getPosByReverseDirection(poses, direction) {\n  /*\n  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n  */\n  return getPosByDirection(poses, direction.map(function (dir) {\n    return -dir;\n  }));\n}\n\nfunction getDist(startPos, matrix, width, height, n, direction) {\n  var poses = caculatePoses(matrix, width, height, n);\n  var pos = getPosByReverseDirection(poses, direction);\n  var distX = startPos[0] - pos[0];\n  var distY = startPos[1] - pos[1];\n  return [distX, distY];\n}\n\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\n  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\n\nfunction scaleMatrix(state, scale) {\n  var transformOrigin = state.transformOrigin,\n      offsetMatrix = state.offsetMatrix,\n      is3d = state.is3d,\n      targetMatrix = state.targetMatrix;\n  var n = is3d ? 4 : 3;\n  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);\n}\n\nfunction getScaleDist(moveable, scale, direction, fixedPosition) {\n  var state = moveable.state;\n  var is3d = state.is3d,\n      left = state.left,\n      top = state.top,\n      width = state.width,\n      height = state.height;\n  var n = is3d ? 4 : 3;\n  var groupable = moveable.props.groupable;\n  var nextMatrix = scaleMatrix(moveable.state, scale);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getResizeDist(moveable, width, height, direction, fixedPosition, transformOrigin) {\n  var groupable = moveable.props.groupable;\n  var _a = moveable.state,\n      prevOrigin = _a.transformOrigin,\n      targetMatrix = _a.targetMatrix,\n      offsetMatrix = _a.offsetMatrix,\n      is3d = _a.is3d,\n      prevWidth = _a.width,\n      prevHeight = _a.height,\n      left = _a.left,\n      top = _a.top;\n  var n = is3d ? 4 : 3;\n  var nextOrigin = caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n  var dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getStartDirection(moveable, direction) {\n  if (!direction[0] && !direction[1]) {\n    return [0, 0];\n  }\n\n  var baseDirection = [-1, -1];\n  return [direction[0] ? direction[0] : baseDirection[0] * -1, direction[1] ? direction[1] : baseDirection[1] * -1];\n}\n\nfunction getAbsoluteFixedPosition(moveable, direction) {\n  return getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n\nfunction multiply2(pos1, pos2) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\n\nfunction prefix() {\n  var classNames = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    classNames[_i] = arguments[_i];\n  }\n\n  return prefixNames.apply(void 0, [PREFIX].concat(classNames));\n}\n\nfunction createIdentityMatrix3() {\n  return createIdentityMatrix(3);\n}\n\nfunction getTransformMatrix(transform) {\n  if (!transform || transform === \"none\") {\n    return [1, 0, 0, 1, 0, 0];\n  }\n\n  if (isObject(transform)) {\n    return transform;\n  }\n\n  var value = splitBracket(transform).value;\n  return value.split(/s*,\\s*/g).map(function (v) {\n    return parseFloat(v);\n  });\n}\n\nfunction getAbsoluteMatrix(matrix, n, origin) {\n  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function (a) {\n    return -a;\n  }), n));\n}\n\nfunction measureSVGSize(el, unit, isHorizontal) {\n  if (unit === \"%\") {\n    var viewBox = getSVGViewBox(el.ownerSVGElement);\n    return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n  }\n\n  return 1;\n}\n\nfunction getBeforeTransformOrigin(el) {\n  var relativeOrigin = getTransformOrigin(getComputedStyle$1(el, \":before\"));\n  return relativeOrigin.map(function (o, i) {\n    var _a = splitUnit(o),\n        value = _a.value,\n        unit = _a.unit;\n\n    return value * measureSVGSize(el, unit, i === 0);\n  });\n}\n\nfunction getTransformOrigin(style) {\n  var transformOrigin = style.transformOrigin;\n  return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\n\nfunction getOffsetInfo(el, lastParent, isParent) {\n  var body = document.body;\n  var target = !el || isParent ? el : el.parentElement;\n  var isEnd = false;\n  var position = \"relative\";\n\n  while (target && target !== body) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n\n    var style = getComputedStyle$1(target);\n    var transform = style.transform;\n    position = style.position;\n\n    if (position !== \"static\" || transform && transform !== \"none\") {\n      break;\n    }\n\n    target = target.parentElement;\n    position = \"relative\";\n  }\n\n  return {\n    isStatic: position === \"static\",\n    isEnd: isEnd || !target || target === body,\n    offsetParent: target || body\n  };\n}\n\nfunction getOffsetPosInfo(el, container, style, isFixed) {\n  var _a;\n\n  var tagName = el.tagName.toLowerCase();\n  var offsetLeft = el.offsetLeft;\n  var offsetTop = el.offsetTop;\n\n  if (isFixed) {\n    var containerClientRect = (container || document.documentElement).getBoundingClientRect();\n    offsetLeft -= containerClientRect.left;\n    offsetTop -= containerClientRect.top;\n  } // svg\n\n\n  var isSVG = isUndefined(offsetLeft);\n  var hasOffset = !isSVG;\n  var origin;\n  var targetOrigin; // inner svg element\n\n  if (!hasOffset && tagName !== \"svg\") {\n    origin = IS_WEBKIT ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n    hasOffset = true;\n\n    if (tagName === \"g\") {\n      offsetLeft = 0;\n      offsetTop = 0;\n    } else {\n      _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];\n    }\n  } else {\n    origin = getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n    targetOrigin = origin.slice();\n  }\n\n  return {\n    isSVG: isSVG,\n    hasOffset: hasOffset,\n    offset: [offsetLeft, offsetTop],\n    origin: origin,\n    targetOrigin: targetOrigin\n  };\n}\n\nfunction getMatrixStackInfo(target, container, prevMatrix) {\n  var el = target;\n  var matrixes = [];\n  var isEnd = false;\n  var is3d = false;\n  var n = 3;\n  var transformOrigin;\n  var targetTransformOrigin;\n  var targetMatrix;\n  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n  if (prevMatrix) {\n    isEnd = target === container;\n\n    if (prevMatrix.length > 10) {\n      is3d = true;\n      n = 4;\n    }\n\n    container = target.parentElement;\n  }\n\n  while (el && !isEnd) {\n    var style = getComputedStyle$1(el);\n    var tagName = el.tagName.toLowerCase();\n    var position = style.position;\n    var isFixed = position === \"fixed\";\n    var matrix = convertCSStoMatrix(getTransformMatrix(style.transform)); // convert 3 to 4\n\n    var length = matrix.length;\n\n    if (!is3d && length === 16) {\n      is3d = true;\n      n = 4;\n      var matrixesLength = matrixes.length;\n\n      for (var i = 0; i < matrixesLength; ++i) {\n        matrixes[i] = convertDimension(matrixes[i], 3, 4);\n      }\n    }\n\n    if (is3d && length === 9) {\n      matrix = convertDimension(matrix, 3, 4);\n    }\n\n    var _a = getOffsetPosInfo(el, container, style, isFixed),\n        hasOffset = _a.hasOffset,\n        isSVG = _a.isSVG,\n        origin = _a.origin,\n        targetOrigin = _a.targetOrigin,\n        offsetPos = _a.offset;\n\n    var offsetLeft = offsetPos[0],\n        offsetTop = offsetPos[1];\n\n    if (tagName === \"svg\" && targetMatrix) {\n      matrixes.push( // scale matrix for svg's SVGElements.\n      getSVGMatrix(el, n), createIdentityMatrix(n));\n    }\n\n    var _b = getOffsetInfo(el, container),\n        offsetParent = _b.offsetParent,\n        isOffsetEnd = _b.isEnd,\n        isStatic = _b.isStatic;\n\n    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n      offsetLeft -= offsetParent.offsetLeft;\n      offsetTop -= offsetParent.offsetTop;\n      isEnd = isEnd || isOffsetEnd;\n    }\n\n    var parentClientLeft = 0;\n    var parentClientTop = 0;\n\n    if (hasOffset && offsetContainer !== offsetParent) {\n      // border\n      parentClientLeft = offsetParent.clientLeft;\n      parentClientTop = offsetParent.clientTop;\n    }\n\n    matrixes.push( // absolute matrix\n    getAbsoluteMatrix(matrix, n, origin), // offset matrix (offsetPos + clientPos(border))\n    createOriginMatrix(hasOffset ? [offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop] : [el, origin], n));\n\n    if (!targetMatrix) {\n      targetMatrix = matrix;\n    }\n\n    if (!transformOrigin) {\n      transformOrigin = origin;\n    }\n\n    if (!targetTransformOrigin) {\n      targetTransformOrigin = targetOrigin;\n    }\n\n    if (isEnd || isFixed) {\n      break;\n    } else {\n      el = offsetParent;\n      isEnd = isOffsetEnd;\n    }\n  }\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(n);\n  }\n\n  if (!transformOrigin) {\n    transformOrigin = [0, 0];\n  }\n\n  if (!targetTransformOrigin) {\n    targetTransformOrigin = [0, 0];\n  }\n\n  return {\n    offsetContainer: offsetContainer,\n    matrixes: matrixes,\n    targetMatrix: targetMatrix,\n    transformOrigin: transformOrigin,\n    targetTransformOrigin: targetTransformOrigin,\n    is3d: is3d\n  };\n}\n\nfunction caculateMatrixStack(target, container, rootContainer, prevMatrix, prevRootMatrix, prevN) {\n  var _a = getMatrixStackInfo(target, container, prevMatrix),\n      matrixes = _a.matrixes,\n      is3d = _a.is3d,\n      prevTargetMatrix = _a.targetMatrix,\n      transformOrigin = _a.transformOrigin,\n      targetTransformOrigin = _a.targetTransformOrigin,\n      offsetContainer = _a.offsetContainer;\n\n  var _b = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix),\n      rootMatrixes = _b.matrixes,\n      isRoot3d = _b.is3d;\n\n  var n = isRoot3d || is3d ? 4 : 3;\n  var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n  var originalContainer = container || document.body;\n  var allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN, n) : createIdentityMatrix(n);\n  var targetMatrix = prevTargetMatrix;\n  var rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN, n) : createIdentityMatrix(n);\n  var beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN, n) : createIdentityMatrix(n);\n  var offsetMatrix = createIdentityMatrix(n);\n  var length = matrixes.length;\n  var endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n  rootMatrixes.reverse();\n  matrixes.reverse();\n\n  if (!is3d && isRoot3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n    matrixes.forEach(function (matrix, i) {\n      matrixes[i] = convertDimension(matrix, 3, 4);\n    });\n  }\n\n  if (is3d && !isRoot3d) {\n    rootMatrixes.forEach(function (matrix, i) {\n      rootMatrixes[i] = convertDimension(matrix, 3, 4);\n    });\n  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n\n  if (!prevRootMatrix) {\n    rootMatrixes.forEach(function (matrix) {\n      rootMatrix = multiply(rootMatrix, matrix, n);\n    });\n  }\n\n  matrixes.forEach(function (matrix, i) {\n    var _a;\n\n    if (length - 2 === i) {\n      // length - 3\n      beforeMatrix = allMatrix.slice();\n    }\n\n    if (length - 1 === i) {\n      // length - 2\n      offsetMatrix = allMatrix.slice();\n    } // caculate for SVGElement\n\n\n    if (isObject(matrix[n * (n - 1)])) {\n      _a = getSVGOffset(matrix[n * (n - 1)], endContainer, n, matrix[n * (n - 1) + 1], allMatrix, matrixes[i + 1]), matrix[n * (n - 1)] = _a[0], matrix[n * (n - 1) + 1] = _a[1];\n    }\n\n    allMatrix = multiply(allMatrix, matrix, n);\n  });\n  var isMatrix3d = !isSVGGraphicElement && is3d;\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n\n  var transform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n  return [rootMatrix, beforeMatrix, offsetMatrix, allMatrix, targetMatrix, transform, transformOrigin, targetTransformOrigin, is3d || isRoot3d];\n}\n\nfunction makeMatrixCSS(matrix, is3d) {\n  if (is3d === void 0) {\n    is3d = matrix.length > 9;\n  }\n\n  return (is3d ? \"matrix3d\" : \"matrix\") + \"(\" + convertMatrixtoCSS(matrix, !is3d).join(\",\") + \")\";\n}\n\nfunction getSVGViewBox(el) {\n  var clientWidth = el.clientWidth;\n  var clientHeight = el.clientHeight;\n  var viewBox = el.viewBox;\n  var baseVal = viewBox && viewBox.baseVal || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  };\n  return {\n    x: baseVal.x,\n    y: baseVal.y,\n    width: baseVal.width || clientWidth,\n    height: baseVal.height || clientHeight\n  };\n}\n\nfunction getSVGMatrix(el, n) {\n  var clientWidth = el.clientWidth;\n  var clientHeight = el.clientHeight;\n\n  var _a = getSVGViewBox(el),\n      viewBoxWidth = _a.width,\n      viewBoxHeight = _a.height;\n\n  var scaleX = clientWidth / viewBoxWidth;\n  var scaleY = clientHeight / viewBoxHeight;\n  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n\n  var align = preserveAspectRatio.align; // 1 : meet 2: slice\n\n  var meetOrSlice = preserveAspectRatio.meetOrSlice;\n  var svgOrigin = [0, 0];\n  var scale = [scaleX, scaleY];\n  var translate = [0, 0];\n\n  if (align !== 1) {\n    var xAlign = (align - 2) % 3;\n    var yAlign = Math.floor((align - 2) / 3);\n    svgOrigin[0] = viewBoxWidth * xAlign / 2;\n    svgOrigin[1] = viewBoxHeight * yAlign / 2;\n    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n  }\n\n  var scaleMatrix = createScaleMatrix(scale, n);\n  scaleMatrix[n * (n - 1)] = translate[0], scaleMatrix[n * (n - 1) + 1] = translate[1];\n  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\n\nfunction getSVGGraphicsOffset(el, origin) {\n  if (!el.getBBox) {\n    return [0, 0];\n  }\n\n  var bbox = el.getBBox();\n  var viewBox = getSVGViewBox(el.ownerSVGElement);\n  var left = bbox.x - viewBox.x;\n  var top = bbox.y - viewBox.y;\n  return [left, top, origin[0] - left, origin[1] - top];\n}\n\nfunction caculatePosition(matrix, pos, n) {\n  return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\n\nfunction caculatePoses(matrix, width, height, n) {\n  return [[0, 0], [width, 0], [0, height], [width, height]].map(function (pos) {\n    return caculatePosition(matrix, pos, n);\n  });\n}\n\nfunction getRect(poses) {\n  var posesX = poses.map(function (pos) {\n    return pos[0];\n  });\n  var posesY = poses.map(function (pos) {\n    return pos[1];\n  });\n  var left = Math.min.apply(Math, posesX);\n  var top = Math.min.apply(Math, posesY);\n  var right = Math.max.apply(Math, posesX);\n  var bottom = Math.max.apply(Math, posesY);\n  var rectWidth = right - left;\n  var rectHeight = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: rectWidth,\n    height: rectHeight\n  };\n}\n\nfunction caculateRect(matrix, width, height, n) {\n  var poses = caculatePoses(matrix, width, height, n);\n  return getRect(poses);\n}\n\nfunction getSVGOffset(el, container, n, origin, beforeMatrix, absoluteMatrix) {\n  var _a;\n\n  var _b = getSize(el, undefined, true),\n      width = _b[0],\n      height = _b[1];\n\n  var containerClientRect = container.getBoundingClientRect();\n  var rect = el.getBoundingClientRect();\n  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0);\n  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0);\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n  var mat = multiplies(n, beforeMatrix, absoluteMatrix);\n\n  var _c = caculateRect(mat, width, height, n),\n      prevLeft = _c.left,\n      prevTop = _c.top,\n      prevWidth = _c.width,\n      prevHeight = _c.height;\n\n  var posOrigin = caculatePosition(mat, origin, n);\n  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];\n  var offset = [0, 0];\n  var count = 0;\n\n  while (++count < 10) {\n    var inverseBeforeMatrix = invert(beforeMatrix, n);\n    _a = minus(caculatePosition(inverseBeforeMatrix, rectOrigin, n), caculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];\n    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), absoluteMatrix);\n\n    var _d = caculateRect(mat2, width, height, n),\n        nextLeft = _d.left,\n        nextTop = _d.top;\n\n    var distLeft = nextLeft - rectLeft;\n    var distTop = nextTop - rectTop;\n\n    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n      break;\n    }\n\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n\n  return offset.map(function (p) {\n    return Math.round(p);\n  });\n}\n\nfunction caculateMoveablePosition(matrix, origin, width, height) {\n  var is3d = matrix.length === 16;\n  var n = is3d ? 4 : 3;\n\n  var _a = caculatePoses(matrix, width, height, n),\n      _b = _a[0],\n      x1 = _b[0],\n      y1 = _b[1],\n      _c = _a[1],\n      x2 = _c[0],\n      y2 = _c[1],\n      _d = _a[2],\n      x3 = _d[0],\n      y3 = _d[1],\n      _e = _a[3],\n      x4 = _e[0],\n      y4 = _e[1];\n\n  var _f = caculatePosition(matrix, origin, n),\n      originX = _f[0],\n      originY = _f[1];\n\n  var left = Math.min(x1, x2, x3, x4);\n  var top = Math.min(y1, y2, y3, y4);\n  var right = Math.max(x1, x2, x3, x4);\n  var bottom = Math.max(y1, y2, y3, y4);\n  x1 = x1 - left || 0;\n  x2 = x2 - left || 0;\n  x3 = x3 - left || 0;\n  x4 = x4 - left || 0;\n  y1 = y1 - top || 0;\n  y2 = y2 - top || 0;\n  y3 = y3 - top || 0;\n  y4 = y4 - top || 0;\n  originX = originX - left || 0;\n  originY = originY - top || 0;\n  var center = [(x1 + x2 + x3 + x4) / 4, (y1 + y2 + y3 + y4) / 4];\n  var pos1Rad = getRad(center, [x1, y1]);\n  var pos2Rad = getRad(center, [x2, y2]);\n  var direction = pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;\n  return [[left, top, right, bottom], [originX, originY], [[x1, y1], [x2, y2], [x3, y3], [x4, y4]], direction];\n}\n\nfunction getDistSize(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\n\nfunction getDiagonalSize(pos1, pos2) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\n\nfunction getLineStyle(pos1, pos2, rad) {\n  if (rad === void 0) {\n    rad = getRad(pos1, pos2);\n  }\n\n  var width = getDiagonalSize(pos1, pos2);\n  return {\n    transform: \"translateY(-50%) translate(\" + pos1[0] + \"px, \" + pos1[1] + \"px) rotate(\" + rad + \"rad)\",\n    width: width + \"px\"\n  };\n}\n\nfunction getControlTransform(rotation) {\n  var poses = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    poses[_i - 1] = arguments[_i];\n  }\n\n  var length = poses.length;\n  var x = poses.reduce(function (prev, pos) {\n    return prev + pos[0];\n  }, 0) / length;\n  var y = poses.reduce(function (prev, pos) {\n    return prev + pos[1];\n  }, 0) / length;\n  return {\n    transform: \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"rad)\"\n  };\n}\n\nfunction getCSSSize(target) {\n  var style = window.getComputedStyle(target);\n  return [parseFloat(style.width), parseFloat(style.height)];\n}\n\nfunction getSize(target, style, isOffset, isBoxSizing) {\n  if (style === void 0) {\n    style = window.getComputedStyle(target);\n  }\n\n  if (isBoxSizing === void 0) {\n    isBoxSizing = isOffset || style.boxSizing === \"border-box\";\n  }\n\n  var width = target.offsetWidth;\n  var height = target.offsetHeight;\n  var hasOffset = !isUndefined(width);\n\n  if ((isOffset || isBoxSizing) && hasOffset) {\n    return [width, height];\n  }\n\n  if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n    var bbox = target.getBBox();\n    return [bbox.width, bbox.height];\n  }\n\n  width = target.clientWidth;\n  height = target.clientHeight;\n\n  if (isOffset || isBoxSizing) {\n    var borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    var borderRight = parseFloat(style.borderRightWidth) || 0;\n    var borderTop = parseFloat(style.borderTopWidth) || 0;\n    var borderBottom = parseFloat(style.borderBottomWidth) || 0;\n    return [width + borderLeft + borderRight, height + borderTop + borderBottom];\n  } else {\n    var paddingLeft = parseFloat(style.paddingLeft) || 0;\n    var paddingRight = parseFloat(style.paddingRight) || 0;\n    var paddingTop = parseFloat(style.paddingTop) || 0;\n    var paddingBottom = parseFloat(style.paddingBottom) || 0;\n    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];\n  }\n}\n\nfunction getRotationRad(poses, direction) {\n  return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nfunction getTargetInfo(moveableElement, target, container, parentContainer, rootContainer, state) {\n  var _a, _b, _c, _d, _e;\n\n  var left = 0;\n  var top = 0;\n  var right = 0;\n  var bottom = 0;\n  var origin = [0, 0];\n  var poses = [[0, 0], [0, 0], [0, 0], [0, 0]];\n  var rootMatrix = createIdentityMatrix3();\n  var offsetMatrix = createIdentityMatrix3();\n  var beforeMatrix = createIdentityMatrix3();\n  var matrix = createIdentityMatrix3();\n  var targetMatrix = createIdentityMatrix3();\n  var width = 0;\n  var height = 0;\n  var transformOrigin = [0, 0];\n  var direction = 1;\n  var beforeDirection = 1;\n  var is3d = false;\n  var targetTransform = \"\";\n  var beforeOrigin = [0, 0];\n  var targetClientRect = resetClientRect();\n  var containerClientRect = resetClientRect();\n  var moveableClientRect = resetClientRect();\n  var targetOrigin = [0, 0];\n  var rotation = 0;\n  var prevMatrix = state ? state.beforeMatrix : undefined;\n  var prevRootMatrix = state ? state.rootMatrix : undefined;\n  var prevN = state ? state.is3d ? 4 : 3 : undefined;\n\n  if (target) {\n    if (state) {\n      width = state.width;\n      height = state.height;\n    } else {\n      var style = getComputedStyle$1(target);\n      width = target.offsetWidth;\n      height = target.offsetHeight;\n\n      if (isUndefined(width)) {\n        _a = getSize(target, style, true), width = _a[0], height = _a[1];\n      }\n    }\n\n    _b = caculateMatrixStack(target, container, rootContainer, prevMatrix, prevRootMatrix, prevN), rootMatrix = _b[0], beforeMatrix = _b[1], offsetMatrix = _b[2], matrix = _b[3], targetMatrix = _b[4], targetTransform = _b[5], transformOrigin = _b[6], targetOrigin = _b[7], is3d = _b[8];\n    _c = caculateMoveablePosition(matrix, transformOrigin, width, height), _d = _c[0], left = _d[0], top = _d[1], right = _d[2], bottom = _d[3], origin = _c[1], poses = _c[2], direction = _c[3];\n    var n = is3d ? 4 : 3;\n    var beforePos = [0, 0];\n    _e = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height), beforePos = _e[0], beforeOrigin = _e[1], beforeDirection = _e[3];\n    beforeOrigin = [beforeOrigin[0] + beforePos[0] - left, beforeOrigin[1] + beforePos[1] - top];\n    targetClientRect = getClientRect(target);\n    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);\n\n    if (moveableElement) {\n      moveableClientRect = getClientRect(moveableElement);\n    }\n\n    rotation = getRotationRad([poses[0], poses[1]], direction);\n  }\n\n  return {\n    rotation: rotation,\n    targetClientRect: targetClientRect,\n    containerClientRect: containerClientRect,\n    moveableClientRect: moveableClientRect,\n    beforeDirection: beforeDirection,\n    direction: direction,\n    target: target,\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    pos1: poses[0],\n    pos2: poses[1],\n    pos3: poses[2],\n    pos4: poses[3],\n    width: width,\n    height: height,\n    rootMatrix: rootMatrix,\n    beforeMatrix: beforeMatrix,\n    offsetMatrix: offsetMatrix,\n    targetMatrix: targetMatrix,\n    matrix: matrix,\n    targetTransform: targetTransform,\n    is3d: is3d,\n    beforeOrigin: beforeOrigin,\n    origin: origin,\n    transformOrigin: transformOrigin,\n    targetOrigin: targetOrigin\n  };\n}\n\nfunction resetClientRect() {\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n    clientLeft: 0,\n    clientTop: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\n\nfunction getClientRect(el, isExtends) {\n  var _a = el.getBoundingClientRect(),\n      left = _a.left,\n      width = _a.width,\n      top = _a.top,\n      bottom = _a.bottom,\n      right = _a.right,\n      height = _a.height;\n\n  var rect = {\n    left: left,\n    right: right,\n    top: top,\n    bottom: bottom,\n    width: width,\n    height: height\n  };\n\n  if (isExtends) {\n    rect.clientLeft = el.clientLeft;\n    rect.clientTop = el.clientTop;\n    rect.clientWidth = el.clientWidth;\n    rect.clientHeight = el.clientHeight;\n    rect.scrollWidth = el.scrollWidth;\n    rect.scrollHeight = el.scrollHeight;\n  }\n\n  return rect;\n}\n\nfunction getDirection(target) {\n  if (!target) {\n    return;\n  }\n\n  var direciton = target.getAttribute(\"data-direction\");\n\n  if (!direciton) {\n    return;\n  }\n\n  var dir = [0, 0];\n  direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n  direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n  direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n  direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n  return dir;\n}\n\nfunction getAbsolutePoses(poses, dist) {\n  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];\n}\n\nfunction getAbsolutePosesByState(_a) {\n  var left = _a.left,\n      top = _a.top,\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nfunction roundSign(num) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nfunction throttle(num, unit) {\n  if (!unit) {\n    return num;\n  }\n\n  return Math.round(num / unit) * unit;\n}\n\nfunction throttleArray(nums, unit) {\n  nums.forEach(function (_, i) {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n\nfunction unset(self, name) {\n  if (self[name]) {\n    self[name].unset();\n    self[name] = null;\n  }\n}\n\nfunction getOrientationDirection(pos, pos1, pos2) {\n  return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\n\nfunction isInside(pos, pos1, pos2, pos3, pos4) {\n  var k1 = getOrientationDirection(pos, pos1, pos2);\n  var k2 = getOrientationDirection(pos, pos2, pos3);\n  var k3 = getOrientationDirection(pos, pos3, pos1);\n  var k4 = getOrientationDirection(pos, pos2, pos3);\n  var k5 = getOrientationDirection(pos, pos3, pos4);\n  var k6 = getOrientationDirection(pos, pos4, pos2);\n  var signs1 = [k1, k2, k3];\n  var signs2 = [k4, k5, k6];\n\n  if (signs1.every(function (sign) {\n    return sign >= 0;\n  }) || signs1.every(function (sign) {\n    return sign <= 0;\n  }) || signs2.every(function (sign) {\n    return sign >= 0;\n  }) || signs2.every(function (sign) {\n    return sign <= 0;\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction fillParams(moveable, e, params) {\n  var datas = e.datas;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  var nextParams = __assign({}, params, {\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    datas: datas.datas\n  });\n\n  if (datas.isStartEvent) {\n    datas.lastEvent = nextParams;\n  } else {\n    datas.isStartEvent = true;\n  }\n\n  return nextParams;\n}\n\nfunction fillEndParams(moveable, e, params) {\n  var datas = e.datas;\n  var isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  return __assign({\n    isDrag: isDrag\n  }, params, {\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    lastEvent: datas.lastEvent,\n    isDouble: e.isDouble,\n    datas: datas.datas\n  });\n}\n\nfunction triggerEvent(moveable, name, params, isManager) {\n  if (isManager) {\n    MoveableManager.prototype.triggerEvent.call(moveable, name, params);\n  }\n\n  return moveable.triggerEvent(name, params);\n}\n\nfunction getComputedStyle$1(el, pseudoElt) {\n  return window.getComputedStyle(el, pseudoElt);\n}\n\nfunction filterAbles(ables, methods, triggerAblesSimultaneously) {\n  var enabledAbles = {};\n  var ableGroups = {};\n  return ables.filter(function (able) {\n    var name = able.name;\n\n    if (enabledAbles[name] || !methods.some(function (method) {\n      return able[method];\n    })) {\n      return false;\n    }\n\n    if (!triggerAblesSimultaneously && able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n\n      ableGroups[able.ableGroup] = true;\n    }\n\n    enabledAbles[name] = true;\n    return true;\n  });\n}\n\nfunction getKeepRatioHeight(width, isWidth, ratio) {\n  return width * (isWidth ? ratio : 1 / ratio);\n}\n\nfunction getKeepRatioWidth(height, isWidth, ratio) {\n  return height * (isWidth ? 1 / ratio : ratio);\n}\n\nfunction equals(a1, a2) {\n  return a1 === a2 || a1 == null && a2 == null;\n}\n\nfunction selectValue() {\n  var values = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n\n  var length = values.length - 1;\n\n  for (var i = 0; i < length; ++i) {\n    var value = values[i];\n\n    if (!isUndefined(value)) {\n      return value;\n    }\n  }\n\n  return values[length];\n}\n\nfunction groupBy(arr, func) {\n  var groups = [];\n  var groupKeys = [];\n  arr.forEach(function (el, index) {\n    var groupKey = func(el, index, arr);\n    var keyIndex = groupKeys.indexOf(groupKey);\n    var group = groups[keyIndex] || [];\n\n    if (keyIndex === -1) {\n      groupKeys.push(groupKey);\n      groups.push(group);\n    }\n\n    group.push(el);\n  });\n  return groups;\n}\n\nfunction groupByMap(arr, func) {\n  var groups = [];\n  var groupKeys = {};\n  arr.forEach(function (el, index) {\n    var groupKey = func(el, index, arr);\n    var group = groupKeys[groupKey];\n\n    if (!group) {\n      group = [];\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n\n    group.push(el);\n  });\n  return groups;\n}\n\nfunction flat(arr) {\n  return arr.reduce(function (prev, cur) {\n    return prev.concat(cur);\n  }, []);\n}\n\nfunction maxOffset() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  args.sort(function (a, b) {\n    return Math.abs(b) - Math.abs(a);\n  });\n  return args[0];\n}\n\nfunction minOffset() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  args.sort(function (a, b) {\n    return Math.abs(a) - Math.abs(b);\n  });\n  return args[0];\n}\n\nfunction caculateInversePosition(matrix, pos, n) {\n  return caculate(invert(matrix, n), convertPositionMatrix(pos, n), n);\n}\n\nfunction convertDragDist(state, e) {\n  var _a;\n\n  var is3d = state.is3d,\n      rootMatrix = state.rootMatrix;\n  var n = is3d ? 4 : 3;\n  _a = caculateInversePosition(rootMatrix, [e.distX, e.distY], n), e.distX = _a[0], e.distY = _a[1];\n  return e;\n}\n\nfunction caculatePadding(matrix, pos, transformOrigin, origin, n) {\n  return minus(caculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\n\nfunction checkSize(targetSize, compareSize, isMax) {\n  return [[compareSize[0], compareSize[0] * targetSize[1] / targetSize[0]], [compareSize[1] * targetSize[0] / targetSize[1], compareSize[1]]].filter(function (size) {\n    return size.every(function (value, i) {\n      return isMax ? value <= compareSize[i] : value >= compareSize[i];\n    });\n  })[0] || targetSize;\n}\n\nfunction caculateBoundSize(size, minSize, maxSize, keepRatio) {\n  if (!keepRatio) {\n    return size.map(function (value, i) {\n      return Math.min(maxSize[i], Math.max(value, minSize[i]));\n    });\n  }\n\n  var width = size[0],\n      height = size[1]; // width : height = minWidth : minHeight;\n\n  var _a = checkSize(size, minSize, false),\n      minWidth = _a[0],\n      minHeight = _a[1];\n\n  var _b = checkSize(size, maxSize, true),\n      maxWidth = _b[0],\n      maxHeight = _b[1];\n\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n\n  return [width, height];\n}\n\nfunction getUnitSize(pos, size) {\n  var _a = splitUnit(pos),\n      value = _a.value,\n      unit = _a.unit;\n\n  return unit === \"%\" ? value * size / 100 : value;\n}\n\nfunction convertCSSSize(value, size, isRelative) {\n  return isRelative ? value / size * 100 + \"%\" : value + \"px\";\n}\n\nfunction moveControlPos(controlPoses, nextPoses, index, distX, distY) {\n  var _a = controlPoses[index],\n      direction = _a.direction,\n      pos = _a.pos,\n      horizontal = _a.horizontal,\n      vertical = _a.vertical,\n      sub = _a.sub;\n  var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];\n\n  if (direction && !sub) {\n    direction.split(\"\").forEach(function (dir) {\n      var isVertical = dir === \"n\" || dir === \"s\";\n      controlPoses.forEach(function (controlPose, i) {\n        var dirDir = controlPose.direction,\n            dirHorizontal = controlPose.horizontal,\n            dirVertical = controlPose.vertical,\n            controlPos = controlPose.pos;\n\n        if (!dirDir || dirDir.indexOf(dir) === -1) {\n          return;\n        }\n\n        nextPoses[i] = plus(controlPos, [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]]);\n      });\n    });\n  } else {\n    nextPoses[index] = plus(pos, dist);\n  }\n}\n\nfunction caculatePointerDist(moveable, e) {\n  var clientX = e.clientX,\n      clientY = e.clientY,\n      datas = e.datas;\n  var _a = moveable.state,\n      moveableClientRect = _a.moveableClientRect,\n      rootMatrix = _a.rootMatrix,\n      is3d = _a.is3d,\n      pos1 = _a.pos1;\n  var left = moveableClientRect.left,\n      top = moveableClientRect.top;\n  var n = is3d ? 4 : 3;\n\n  var _b = minus(caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1),\n      posX = _b[0],\n      posY = _b[1];\n\n  var _c = getDragDist({\n    datas: datas,\n    distX: posX,\n    distY: posY\n  }),\n      distX = _c[0],\n      distY = _c[1];\n\n  return [distX, distY];\n}\n\nfunction getTinyDist(v) {\n  return Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n\nfunction triggerRenderStart(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.isPinch\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix + \"Start\", params);\n}\n\nfunction triggerRender(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.isPinch\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix, params);\n}\n\nfunction triggerRenderEnd(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.sPinch,\n    isDrag: e.isDrag\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix + \"End\", params);\n}\n\nfunction triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, requestInstant) {\n  var isStart = eventType === \"Start\";\n  var target = moveable.state.target;\n\n  if (!target || isStart && eventAffix.indexOf(\"Control\") > -1 && !e.isRequest && moveable.areaElement === e.inputEvent.target) {\n    return false;\n  }\n\n  var eventName = \"\" + eventOperation + eventAffix + eventType;\n  var conditionName = \"\" + eventOperation + eventAffix + \"Condition\";\n  var isEnd = eventType === \"End\";\n  var isAfter = eventType.indexOf(\"After\") > -1;\n  var isFirstStart = isStart && (!moveable.targetDragger || !moveable.controlDragger || !moveable.targetDragger.isFlag() || !moveable.controlDragger.isFlag());\n\n  if (isFirstStart) {\n    moveable.updateRect(eventType, true, false);\n  }\n\n  if (eventType === \"\" && !isAfter) {\n    convertDragDist(moveable.state, e);\n  }\n\n  var isGroup = eventAffix.indexOf(\"Group\") > -1;\n  var ables = moveable[ableType].slice();\n\n  if (e.isRequest) {\n    var requestAble_1 = e.requestAble;\n\n    if (!ables.some(function (able) {\n      return able.name === requestAble_1;\n    })) {\n      ables.push.apply(ables, moveable.props.ables.filter(function (able) {\n        return able.name === requestAble_1;\n      }));\n    }\n  }\n\n  if (!ables.length) {\n    return false;\n  }\n\n  var events = ables.filter(function (able) {\n    return able[eventName];\n  });\n  var datas = e.datas;\n  var renderDatas = datas.render || (datas.render = {});\n\n  var renderEvent = __assign({}, e, {\n    datas: renderDatas,\n    originalDatas: datas\n  });\n\n  if (isFirstStart) {\n    events.forEach(function (able) {\n      able.unset && able.unset(moveable);\n    });\n  }\n\n  var results = events.filter(function (able) {\n    var hasCondition = isStart && able[conditionName];\n    var ableName = able.name;\n    var nextDatas = datas[ableName] || (datas[ableName] = {});\n\n    if (!hasCondition || able[conditionName](e, moveable)) {\n      return able[eventName](moveable, __assign({}, e, {\n        datas: nextDatas,\n        originalDatas: datas\n      }));\n    }\n\n    return false;\n  });\n  var isUpdate = results.length;\n\n  if (isStart) {\n    if (events.length && !isUpdate) {\n      moveable.state.dragger = null;\n\n      if (moveable.moveables) {\n        moveable.moveables.forEach(function (childeMoveable) {\n          childeMoveable.state.dragger = null;\n        });\n      }\n\n      return false;\n    }\n\n    triggerRenderStart(moveable, isGroup, renderEvent);\n  } else if (isEnd) {\n    triggerRenderEnd(moveable, isGroup, renderEvent);\n  } else if (!isAfter || isUpdate) {\n    triggerRender(moveable, isGroup, renderEvent);\n  }\n\n  if (isEnd) {\n    moveable.state.dragger = null;\n  }\n\n  if (moveable.isUnmounted) {\n    return false;\n  }\n\n  if (!isStart && isUpdate && !requestInstant || isEnd) {\n    if (results.some(function (able) {\n      return able.updateRect;\n    }) && !isGroup) {\n      moveable.updateRect(eventType, false, false);\n    } else {\n      moveable.updateRect(eventType, true, false);\n    }\n\n    moveable.forceUpdate();\n  }\n\n  if (!isStart && !isEnd && !isAfter && isUpdate) {\n    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n  }\n}\n\nfunction getTargetAbleDragger(moveable, moveableTarget, eventAffix) {\n  var controlBox = moveable.controlBox.getElement();\n  var targets = [];\n  targets.push(controlBox);\n\n  if (!moveable.props.dragArea) {\n    targets.push(moveableTarget);\n  }\n\n  var startFunc = function (e) {\n    var eventTarget = e.inputEvent.target;\n    var areaElement = moveable.areaElement;\n    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) || eventTarget.className.indexOf(\"moveable-area\") > -1 || eventTarget.className.indexOf(\"moveable-padding\") > -1;\n  };\n\n  return getAbleDragger(moveable, targets, \"targetAbles\", eventAffix, {\n    dragstart: startFunc,\n    pinchstart: startFunc\n  });\n}\n\nfunction getAbleDragger(moveable, target, ableType, eventAffix, conditionFunctions) {\n  if (conditionFunctions === void 0) {\n    conditionFunctions = {};\n  }\n\n  var _a = moveable.props,\n      pinchOutside = _a.pinchOutside,\n      pinchThreshold = _a.pinchThreshold;\n  var options = {\n    container: window,\n    pinchThreshold: pinchThreshold,\n    pinchOutside: pinchOutside\n  };\n  [\"drag\", \"pinch\"].forEach(function (eventOperation) {\n    [\"Start\", \"\", \"End\"].forEach(function (eventType) {\n      var eventName = \"\" + eventOperation + eventType.toLowerCase();\n\n      options[eventName] = function (e) {\n        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n          return false;\n        }\n\n        return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n      };\n    });\n  });\n  return new Dragger(target, options);\n}\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\n\n\nvar Pinchable = {\n  name: \"pinchable\",\n  updateRect: true,\n  props: {\n    pinchable: Boolean\n  },\n  events: {\n    onPinchStart: \"pinchStart\",\n    onPinch: \"pinch\",\n    onPinchEnd: \"pinchEnd\",\n    onPinchGroupStart: \"pinchGroupStart\",\n    onPinchGroup: \"pinchGroup\",\n    onPinchGroupEnd: \"pinchGroupEnd\"\n  },\n  pinchStart: function (moveable, e) {\n    var datas = e.datas,\n        targets = e.targets,\n        angle = e.angle;\n    var _a = moveable.props,\n        pinchable = _a.pinchable,\n        ables = _a.ables;\n\n    if (!pinchable) {\n      return false;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"Start\";\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlStart\";\n    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {\n      return pinchable.indexOf(able.name) > -1;\n    })).filter(function (able) {\n      return able.canPinch && able[controlEventName];\n    });\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var result = triggerEvent(moveable, eventName, params);\n    datas.isPinch = result !== false;\n    datas.ables = pinchAbles;\n    var isPinch = datas.isPinch;\n\n    if (!isPinch) {\n      return false;\n    }\n\n    pinchAbles.forEach(function (able) {\n      datas[able.name + \"Datas\"] = {};\n\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      var ableEvent = __assign({}, e, {\n        datas: datas[able.name + \"Datas\"],\n        parentRotate: angle,\n        isPinch: true\n      });\n\n      able[controlEventName](moveable, ableEvent);\n    });\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: [0, 0]\n    };\n    return isPinch;\n  },\n  pinch: function (moveable, e) {\n    var datas = e.datas,\n        pinchScale = e.scale,\n        distance = e.distance,\n        inputEvent = e.inputEvent,\n        targets = e.targets,\n        angle = e.angle;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var parentDistance = distance * (1 - 1 / pinchScale);\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\");\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"Control\";\n    ables.forEach(function (able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      able[controlEventName](moveable, __assign({}, e, {\n        datas: datas[able.name + \"Datas\"],\n        inputEvent: inputEvent,\n        parentDistance: parentDistance,\n        parentRotate: angle,\n        isPinch: true\n      }));\n    });\n    return params;\n  },\n  pinchEnd: function (moveable, e) {\n    var datas = e.datas,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        targets = e.targets;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"End\";\n    var params = fillEndParams(moveable, e, {\n      isDrag: isPinch\n    });\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlEnd\";\n    ables.forEach(function (able) {\n      if (!able[controlEventName]) {\n        return;\n      }\n\n      able[controlEventName](moveable, __assign({}, e, {\n        isDrag: isPinch,\n        datas: datas[able.name + \"Datas\"],\n        inputEvent: inputEvent,\n        isPinch: true\n      }));\n    });\n    return isPinch;\n  },\n  pinchGroupStart: function (moveable, e) {\n    return this.pinchStart(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroup: function (moveable, e) {\n    return this.pinch(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroupEnd: function (moveable, e) {\n    return this.pinchEnd(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  }\n};\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction setCustomDrag(state, delta, inputEvent, isPinch, isConvert) {\n  var result = state.dragger.move(delta, inputEvent);\n  var datas = result.originalDatas || result.datas;\n  var draggableDatas = datas.draggable || (datas.draggable = {});\n  return __assign({}, isConvert ? convertDragDist(state, result) : result, {\n    isDrag: true,\n    isPinch: !!isPinch,\n    parentEvent: true,\n    datas: draggableDatas\n  });\n}\n\nvar CustomDragger = /*#__PURE__*/function () {\n  function CustomDragger() {\n    this.prevX = 0;\n    this.prevY = 0;\n    this.startX = 0;\n    this.startY = 0;\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {\n      draggable: {}\n    };\n  }\n\n  var __proto = CustomDragger.prototype;\n\n  __proto.dragStart = function (client, inputEvent) {\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {\n      draggable: {}\n    };\n    return __assign({}, this.move(client, inputEvent), {\n      type: \"dragstart\"\n    });\n  };\n\n  __proto.drag = function (client, inputEvent) {\n    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);\n  };\n\n  __proto.move = function (delta, inputEvent) {\n    var clientX;\n    var clientY;\n\n    if (!this.isFlag) {\n      this.prevX = delta[0];\n      this.prevY = delta[1];\n      this.startX = delta[0];\n      this.startY = delta[1];\n      clientX = delta[0];\n      clientY = delta[1];\n      this.isFlag = true;\n    } else {\n      clientX = this.prevX + delta[0];\n      clientY = this.prevY + delta[1];\n      this.isDrag = true;\n    }\n\n    this.prevX = clientX;\n    this.prevY = clientY;\n    return {\n      type: \"drag\",\n      clientX: clientX,\n      clientY: clientY,\n      inputEvent: inputEvent,\n      isDrag: this.isDrag,\n      distX: clientX - this.startX,\n      distY: clientY - this.startY,\n      deltaX: delta[0],\n      deltaY: delta[1],\n      datas: this.datas.draggable,\n      originalDatas: this.datas,\n      parentEvent: true,\n      parentDragger: this\n    };\n  };\n\n  return CustomDragger;\n}();\n\nfunction triggerChildDragger(moveable, able, type, delta, e, isConvert) {\n  var isStart = !!type.match(/Start$/g);\n  var isEnd = !!type.match(/End$/g);\n  var inputEvent = e.inputEvent;\n  var isPinch = e.isPinch;\n  var datas = e.datas;\n  var childs = moveable.moveables.map(function (child, i) {\n    var childEvent = {};\n\n    if (isStart) {\n      childEvent = new CustomDragger().dragStart(delta, inputEvent);\n    } else {\n      if (!child.state.dragger) {\n        child.state.dragger = datas.childDraggers[i];\n      }\n\n      childEvent = setCustomDrag(child.state, delta, inputEvent, isPinch, isConvert);\n    }\n\n    var result = able[type](child, __assign({}, childEvent, {\n      parentFlag: true\n    }));\n\n    if (isEnd) {\n      child.state.dragger = null;\n    }\n\n    return result;\n  });\n\n  if (isStart) {\n    datas.childDraggers = moveable.moveables.map(function (child) {\n      return child.state.dragger;\n    });\n  }\n\n  return childs;\n}\n\nfunction triggerChildAble(moveable, able, type, datas, eachEvent, callback) {\n  var name = able.name;\n  var ableDatas = datas[name] || (datas[name] = []);\n  var isEnd = !!type.match(/End$/g);\n  var childs = moveable.moveables.map(function (child, i) {\n    var childDatas = ableDatas[i] || (ableDatas[i] = {});\n    var childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n    var result = able[type](child, __assign({}, childEvent, {\n      datas: childDatas,\n      parentFlag: true\n    }));\n    result && callback && callback(child, childDatas, result, i);\n\n    if (isEnd) {\n      child.state.dragger = null;\n    }\n\n    return result;\n  });\n  return childs;\n}\n\nfunction directionCondition(e) {\n  if (e.isRequest) {\n    if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n      return e.parentDirection;\n    } else {\n      return false;\n    }\n  }\n\n  return hasClass(e.inputEvent.target, prefix(\"direction\"));\n} // MatchTypes<typeof Draggable[\"props\"], AnyProps<DraggableOptions>>;\n// MatchTypes<typeof Resizable[\"events\"], DraggableEvents>;\n\n\nfunction invert$1(obj) {\n  var nextObj = {};\n\n  for (var name in obj) {\n    nextObj[obj[name]] = name;\n  }\n\n  return nextObj;\n}\n\nfunction getGapGuidelines(guidelines, type, snapThreshold, index, _a, _b) {\n  var start = _a[0],\n      end = _a[1];\n  var otherStart = _b[0],\n      otherEnd = _b[1];\n  var totalGuidelines = [];\n  var otherIndex = index ? 0 : 1;\n  var otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n  var elementGuidelines = groupBy(guidelines.filter(function (_a) {\n    var guidelineType = _a.type;\n    return guidelineType === type;\n  }), function (_a) {\n    var element = _a.element;\n    return element;\n  }).map(function (group) {\n    return group[0];\n  }).filter(function (_a) {\n    var pos = _a.pos,\n        sizes = _a.sizes;\n    return pos[otherIndex] <= otherEnd && otherStart <= pos[otherIndex] + sizes[otherIndex];\n  });\n  elementGuidelines.forEach(function (guideline1) {\n    var elementStart = guideline1.pos[index];\n    var elementEnd = elementStart + guideline1.sizes[index];\n    elementGuidelines.forEach(function (_a) {\n      var guideline2Pos = _a.pos,\n          guideline2Sizes = _a.sizes,\n          guideline2Element = _a.element;\n      var targetStart = guideline2Pos[index];\n      var targetEnd = targetStart + guideline2Sizes[index];\n      var pos = 0;\n      var gap = 0;\n      var canSnap = true;\n\n      if (elementEnd <= targetStart) {\n        // gap -\n        gap = elementEnd - targetStart;\n        pos = targetEnd - gap;\n\n        if (start < pos - snapThreshold) {\n          canSnap = false;\n        } // element target moveable\n\n      } else if (targetEnd <= elementStart) {\n        // gap +\n        gap = elementStart - targetEnd;\n        pos = targetStart - gap;\n\n        if (end > pos + snapThreshold) {\n          canSnap = false;\n        } // moveable target element\n\n      } else {\n        return;\n      }\n\n      if (canSnap) {\n        totalGuidelines.push({\n          pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n          element: guideline2Element,\n          sizes: guideline2Sizes,\n          size: 0,\n          type: otherType,\n          gap: gap,\n          gapGuidelines: elementGuidelines\n        });\n      }\n\n      if (elementEnd <= start && end <= targetStart) {\n        // elementEnd   moveable   target\n        var centerPos = (targetStart + elementEnd - (end - start)) / 2;\n\n        if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n          totalGuidelines.push({\n            pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n            element: guideline2Element,\n            sizes: guideline2Sizes,\n            size: 0,\n            type: otherType,\n            gap: elementEnd - start,\n            gapGuidelines: elementGuidelines\n          });\n        }\n      }\n    });\n  });\n  return totalGuidelines;\n}\n\nfunction getTotalGuidelines(moveable) {\n  var _a = moveable.state,\n      guidelines = _a.guidelines,\n      _b = _a.containerClientRect,\n      containerHeight = _b.scrollHeight,\n      containerWidth = _b.scrollWidth;\n  var props = moveable.props;\n  var _c = props.snapHorizontal,\n      snapHorizontal = _c === void 0 ? true : _c,\n      _d = props.snapVertical,\n      snapVertical = _d === void 0 ? true : _d,\n      _e = props.snapGap,\n      snapGap = _e === void 0 ? true : _e,\n      verticalGuidelines = props.verticalGuidelines,\n      horizontalGuidelines = props.horizontalGuidelines,\n      _f = props.snapThreshold,\n      snapThreshold = _f === void 0 ? 5 : _f;\n  var totalGuidelines = guidelines.slice();\n\n  if (snapGap) {\n    var _g = getRect(getAbsolutePosesByState(moveable.state)),\n        top = _g.top,\n        left = _g.left,\n        bottom = _g.bottom,\n        right = _g.right;\n\n    var elementGuidelines = guidelines.filter(function (_a) {\n      var element = _a.element;\n      return element;\n    });\n    totalGuidelines.push.apply(totalGuidelines, getGapGuidelines(elementGuidelines, \"horizontal\", snapThreshold, 0, [left, right], [top, bottom]).concat(getGapGuidelines(elementGuidelines, \"vertical\", snapThreshold, 1, [top, bottom], [left, right])));\n  }\n\n  if (snapHorizontal && horizontalGuidelines) {\n    horizontalGuidelines.forEach(function (pos) {\n      totalGuidelines.push({\n        type: \"horizontal\",\n        pos: [0, throttle(pos, 0.1)],\n        size: containerWidth\n      });\n    });\n  }\n\n  if (snapVertical && verticalGuidelines) {\n    verticalGuidelines.forEach(function (pos) {\n      totalGuidelines.push({\n        type: \"vertical\",\n        pos: [throttle(pos, 0.1), 0],\n        size: containerHeight\n      });\n    });\n  }\n\n  return totalGuidelines;\n}\n\nfunction checkSnapPoses(moveable, posesX, posesY, snapCenter, customSnapThreshold) {\n  var totalGuidelines = getTotalGuidelines(moveable);\n  var props = moveable.props;\n  var _a = props.snapElement,\n      snapElement = _a === void 0 ? true : _a;\n  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);\n  return {\n    vertical: checkSnap(totalGuidelines, \"vertical\", posesX, snapThreshold, snapCenter, snapElement),\n    horizontal: checkSnap(totalGuidelines, \"horizontal\", posesY, snapThreshold, snapCenter, snapElement)\n  };\n}\n\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\n  var endX = endPos[0],\n      endY = endPos[1];\n  var startX = startPos[0],\n      startY = startPos[1];\n\n  var _a = minus(endPos, startPos),\n      dx = _a[0],\n      dy = _a[1];\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  dx = getTinyDist(dx);\n  dy = getTinyDist(dy);\n  var verticalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  }\n\n  var _b = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),\n      verticalSnapInfo = _b.vertical,\n      horizontalSnapInfo = _b.horizontal;\n\n  verticalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isRight ? pos >= startX : pos <= startX;\n  });\n  horizontalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isBottom ? pos >= startY : pos <= startY;\n  });\n  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),\n      isVerticalSnap = _c.isSnap,\n      verticalGuideline = _c.guideline;\n\n  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),\n      isHorizontalSnap = _d.isSnap,\n      horizontalGuideline = _d.guideline;\n\n  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\n  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\n\n  if (dx === 0) {\n    if (isHorizontalSnap) {\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = horizontalGuideline.pos[1];\n      horizontalInfo.offset = endY - horizontalInfo.pos;\n    }\n  } else if (dy === 0) {\n    if (isVerticalSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = verticalPos;\n      verticalInfo.offset = endX - verticalPos;\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isSnap = false;\n\n    if (isVerticalSnap) {\n      x = verticalPos;\n      y = a * x + b;\n      isSnap = true;\n    } else if (isHorizontalSnap) {\n      y = horizontalPos;\n      x = (y - b) / a;\n      isSnap = true;\n    }\n\n    if (isSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkSnaps(moveable, rect, isCenter, customSnapThreshold) {\n  var snapCenter = moveable.props.snapCenter;\n  var isSnapCenter = snapCenter && isCenter;\n  var verticalNames = [\"left\", \"right\"];\n  var horizontalNames = [\"top\", \"bottom\"];\n\n  if (isSnapCenter) {\n    verticalNames.push(\"center\");\n    horizontalNames.push(\"middle\");\n  }\n\n  verticalNames = verticalNames.filter(function (name) {\n    return name in rect;\n  });\n  horizontalNames = horizontalNames.filter(function (name) {\n    return name in rect;\n  });\n  return checkSnapPoses(moveable, verticalNames.map(function (name) {\n    return rect[name];\n  }), horizontalNames.map(function (name) {\n    return rect[name];\n  }), isSnapCenter, customSnapThreshold);\n}\n\nfunction getNearestSnapGuidelineInfo(snapInfo) {\n  var isSnap = snapInfo.isSnap;\n\n  if (!isSnap) {\n    return {\n      isSnap: false,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  }\n\n  var posInfo = snapInfo.posInfos[0];\n  var guidelineInfo = posInfo.guidelineInfos[0];\n  var offset = guidelineInfo.offset;\n  var dist = guidelineInfo.dist;\n  var guideline = guidelineInfo.guideline;\n  return {\n    isSnap: isSnap,\n    offset: offset,\n    dist: dist,\n    pos: posInfo.pos,\n    guideline: guideline\n  };\n}\n\nfunction checkSnap(guidelines, targetType, targetPoses, snapThreshold, snapCenter, snapElement) {\n  if (!guidelines || !guidelines.length) {\n    return {\n      isSnap: false,\n      posInfos: []\n    };\n  }\n\n  var isVertical = targetType === \"vertical\";\n  var posType = isVertical ? 0 : 1;\n  var snapPosInfos = targetPoses.map(function (targetPos) {\n    var guidelineInfos = guidelines.map(function (guideline) {\n      var pos = guideline.pos;\n      var offset = targetPos - pos[posType];\n      return {\n        offset: offset,\n        dist: Math.abs(offset),\n        guideline: guideline\n      };\n    }).filter(function (_a) {\n      var guideline = _a.guideline,\n          dist = _a.dist;\n      var type = guideline.type,\n          center = guideline.center,\n          element = guideline.element;\n\n      if (!snapElement && element || !snapCenter && center || type !== targetType || dist > snapThreshold) {\n        return false;\n      }\n\n      return true;\n    }).sort(function (a, b) {\n      return a.dist - b.dist;\n    });\n    return {\n      pos: targetPos,\n      guidelineInfos: guidelineInfos\n    };\n  }).filter(function (snapPosInfo) {\n    return snapPosInfo.guidelineInfos.length > 0;\n  }).sort(function (a, b) {\n    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n  });\n  return {\n    isSnap: snapPosInfos.length > 0,\n    posInfos: snapPosInfos\n  };\n}\n\nfunction getSnapInfosByDirection(moveable, poses, snapDirection) {\n  var nextPoses = [];\n\n  if (snapDirection[0] && snapDirection[1]) {\n    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {\n      return getPosByDirection(poses, direction);\n    });\n  } else if (!snapDirection[0] && !snapDirection[1]) {\n    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n    for (var i = 0; i < 4; ++i) {\n      nextPoses.push(alignPoses[i]);\n      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);\n    }\n  } else {\n    if (moveable.props.keepRatio) {\n      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {\n        return getPosByDirection(poses, dir);\n      });\n    } else {\n      nextPoses = getPosesByDirection(poses, snapDirection);\n\n      if (nextPoses.length > 1) {\n        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);\n      }\n    }\n  }\n\n  return checkSnapPoses(moveable, nextPoses.map(function (pos) {\n    return pos[0];\n  }), nextPoses.map(function (pos) {\n    return pos[1];\n  }), true, 1);\n}\n\nfunction getNearOffsetInfo(offsets, index) {\n  return offsets.slice().sort(function (a, b) {\n    var aSign = a.sign[index];\n    var bSign = b.sign[index];\n    var aOffset = a.offset[index];\n    var bOffset = b.offset[index];\n    var aDist = Math.abs(aOffset);\n    var bDist = Math.abs(bOffset); // -1 The positions of a and b do not change.\n    // 1 The positions of a and b are reversed.\n\n    if (!aSign) {\n      return 1;\n    } else if (!bSign) {\n      return -1;\n    } else if (a.isBound && b.isBound) {\n      return bDist - aDist;\n    } else if (a.isBound) {\n      return -1;\n    } else if (b.isBound) {\n      return 1;\n    } else if (a.isSnap && b.isSnap) {\n      return aDist - bDist;\n    } else if (a.isSnap) {\n      return -1;\n    } else if (b.isSnap) {\n      return 1;\n    } else if (aDist < TINY_NUM) {\n      return 1;\n    } else if (bDist < TINY_NUM) {\n      return -1;\n    }\n\n    return aDist - bDist;\n  })[0];\n}\n\nfunction isStartLine(dot, line) {\n  // l    o     => true\n  // o    l    => false\n  var cx = average(line[0][0], line[1][0]);\n  var cy = average(line[0][1], line[1][1]);\n  return {\n    vertical: cx <= dot[0],\n    horizontal: cy <= dot[1]\n  };\n}\n\nfunction hitTestLine(dot, _a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  var test1;\n  var test2;\n\n  if (!dx) {\n    test1 = pos1[0];\n    test2 = dot[0];\n  } else if (!dy) {\n    test1 = pos1[1];\n    test2 = dot[1];\n  } else {\n    var a = dy / dx; // y = a * (x - pos1) + pos1\n\n    test1 = a * (dot[0] - pos1[0]) + pos1[1];\n    test2 = dot[1];\n  }\n\n  return test1 - test2;\n}\n\nfunction isSameStartLine(dots, line, error) {\n  if (error === void 0) {\n    error = TINY_NUM;\n  }\n\n  var centerSign = hitTestLine(dots[0], line) <= 0;\n  return dots.slice(1).every(function (dot) {\n    var value = hitTestLine(dot, line);\n    var sign = value <= 0;\n    return sign === centerSign || Math.abs(value) <= error;\n  });\n}\n\nfunction checkInnerBoundDot(pos, start, end, isStart, threshold) {\n  if (threshold === void 0) {\n    threshold = 0;\n  }\n\n  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {\n    // false 402 565 602 => 37 ([0, 37])\n    // true 400 524.9712603540036 600 => 124 ([124, 0])\n    // true 400 410 600 => 10 ([10, 0])\n    return {\n      isBound: true,\n      offset: isStart ? start - pos : end - pos\n    };\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction checkInnerBound(moveable, line, center) {\n  var bounds = moveable.props.innerBounds;\n\n  if (!bounds) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n\n  var _a = isStartLine(center, line),\n      isHorizontalStart = _a.horizontal,\n      isVerticalStart = _a.vertical;\n\n  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  } // test vertical\n\n\n  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart); // test horizontal\n\n  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n  var offset = [0, 0];\n  var isBound = false;\n  var isAllBound = false;\n\n  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n    offset = [verticalOffset, 0];\n    isBound = isVerticalBound;\n    isAllBound = isAllVerticalBound;\n  } else {\n    offset = [0, horizontalOffset];\n    isBound = isHorizontalBound;\n    isAllBound = isAllHorizontalBound;\n  }\n\n  return {\n    isAllBound: isAllBound,\n    isVerticalBound: isVerticalBound,\n    isHorizontalBound: isHorizontalBound,\n    isBound: isBound,\n    offset: offset\n  };\n}\n\nfunction checkLineBoundCollision(line, boundLine, isStart, threshold, isRender) {\n  var dot1 = line[0];\n  var dot2 = line[1];\n  var boundDot1 = boundLine[0];\n  var boundDot2 = boundLine[1];\n  var dy1 = getTinyDist(dot2[1] - dot1[1]);\n  var dx1 = getTinyDist(dot2[0] - dot1[0]);\n  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]); // dx2 or dy2 is zero\n\n  if (!dx2) {\n    // vertical\n    if (isRender && !dy1) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dx1) {\n      // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n      var y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]\n\n      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n    } else {\n      var offset = boundDot1[0] - dot1[0];\n      var isBound = Math.abs(offset) <= (threshold || 0);\n      return {\n        isBound: isBound,\n        offset: isBound ? offset : 0\n      };\n    }\n  } else if (!dy2) {\n    // horizontal\n    if (isRender && !dx1) {\n      // 90deg\n      return {\n        isBound: false,\n        offset: 0\n      };\n    } else if (dy1) {\n      // y = a * (x - x1) + y1\n      // x = (y - y1) / a + x1\n      // const a = dy1 / dx1;\n      // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n      var x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]\n\n      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n    } else {\n      var offset = boundDot1[1] - dot1[1];\n      var isBound = Math.abs(offset) <= (threshold || 0);\n      return {\n        isBound: isBound,\n        offset: isBound ? offset : 0\n      };\n    }\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction getInnerBoundInfo(moveable, lines, center, datas) {\n  return lines.map(function (_a) {\n    var multiple = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n\n    var _b = checkInnerBound(moveable, [pos1, pos2], center),\n        isBound = _b.isBound,\n        offset = _b.offset,\n        isVerticalBound = _b.isVerticalBound,\n        isHorizontalBound = _b.isHorizontalBound;\n\n    var sizeOffset = getDragDist({\n      datas: datas,\n      distX: offset[0],\n      distY: offset[1]\n    }).map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isBound,\n      isVerticalBound: isVerticalBound,\n      isHorizontalBound: isHorizontalBound,\n      isSnap: false,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\n  var _a;\n\n  var lines = getCheckSnapLines(poses, [0, 0], false).map(function (_a) {\n    var sign = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n    return [sign.map(function (dir) {\n      return Math.abs(dir) * 2;\n    }), pos1, pos2];\n  });\n  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n  var verticalOffset = 0;\n  var horizontalOffset = 0;\n  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n  if (isVerticalBound || isHorizontalBound) {\n    _a = getInverseDragDist({\n      datas: datas,\n      distX: -widthOffsetInfo.offset[0],\n      distY: -heightOffsetInfo.offset[1]\n    }), verticalOffset = _a[0], horizontalOffset = _a[1];\n  }\n\n  return {\n    vertical: {\n      isBound: isVerticalBound,\n      offset: verticalOffset\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      offset: horizontalOffset\n    }\n  };\n}\n\nfunction getCheckSnapLineDirections(direction, keepRatio) {\n  var lineDirections = [];\n  var x = direction[0];\n  var y = direction[1];\n\n  if (x && y) {\n    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);\n  } else if (x) {\n    // vertcal\n    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);\n\n    if (keepRatio) {\n      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);\n    }\n  } else if (y) {\n    // horizontal\n    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);\n\n    if (keepRatio) {\n      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);\n  }\n\n  return lineDirections;\n}\n\nfunction getCheckSnapLines(poses, direction, keepRatio) {\n  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {\n    var sign = _a[0],\n        dir1 = _a[1],\n        dir2 = _a[2];\n    return [sign, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];\n  });\n}\n\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  var dots = [center].concat(boundDots);\n  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line, i) {\n    return !isSameStartLine(dots, line);\n  });\n}\n\nfunction getDistPointLine(_a) {\n  // x = 0, y = 0\n  // d = (ax + by + c) / root(a2 + b2)\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return Math.abs(pos1[0]);\n  }\n\n  if (!dy) {\n    return Math.abs(pos1[1]);\n  } // y - y1 = a(x - x1)\n  // 0 = ax -y + -a * x1 + y1\n\n\n  var a = dy / dx;\n  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\n\nfunction solveReverseLine(_a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return [pos1[0], 0];\n  }\n\n  if (!dy) {\n    return [0, pos1[1]];\n  }\n\n  var a = dy / dx; // y - y1 = a (x  - x1)\n  // y = ax - a * x1 + y1\n\n  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x\n  // x = -b / (a + 1 / a)\n  // y = b / (1 + 1 / a^2)\n\n  return [-b / (a + 1 / a), b / (a * a + 1)];\n}\n\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.innerBounds;\n  var rad = rotation * Math.PI / 180;\n\n  if (!bounds) {\n    return [];\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var relativeLeft = left - origin[0];\n  var relativeRight = left + width - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = top + height - origin[1];\n  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];\n  var center = getPosByDirection(nextPoses, [0, 0]);\n\n  if (!isBoundRotate(nextPoses, dots, center, 0)) {\n    return [];\n  }\n\n  var result = [];\n  var dotInfos = dots.map(function (dot) {\n    return [getDistSize(dot), getRad([0, 0], dot)];\n  });\n  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {\n    var lineRad = getRad([0, 0], solveReverseLine(line));\n    var lineDist = getDistPointLine(line);\n    result.push.apply(result, dotInfos.filter(function (_a) {\n      var dotDist = _a[0];\n      return dotDist && lineDist <= dotDist;\n    }).map(function (_a) {\n      var dotDist = _a[0],\n          dotRad = _a[1];\n      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n      var nextRad1 = dotRad + distRad;\n      var nextRad2 = dotRad - distRad;\n      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];\n    }).reduce(function (prev, cur) {\n      prev.push.apply(prev, cur);\n      return prev;\n    }, []).filter(function (nextRad) {\n      return !isBoundRotate(prevPoses, dots, center, nextRad);\n    }).map(function (nextRad) {\n      return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n    }));\n  });\n  return result;\n}\n\nfunction checkInnerBoundPoses(moveable) {\n  var innerBounds = moveable.props.innerBounds;\n\n  if (!innerBounds) {\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  }\n\n  var _a = moveable.getRect(),\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n\n  var poses = [pos1, pos2, pos3, pos4];\n  var center = getPosByDirection(poses, [0, 0]);\n  var left = innerBounds.left,\n      top = innerBounds.top,\n      width = innerBounds.width,\n      height = innerBounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];\n  var horizontalPoses = [];\n  var verticalPoses = [];\n  var boundMap = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false\n  };\n  lines.forEach(function (line) {\n    var _a = isStartLine(center, line),\n        isHorizontalStart = _a.horizontal,\n        isVerticalStart = _a.vertical; // test vertical\n\n\n    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true); // test horizontal\n\n    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n\n    if (topBoundInfo.isBound && !boundMap.top) {\n      horizontalPoses.push(top);\n      boundMap.top = true;\n    }\n\n    if (bottomBoundInfo.isBound && !boundMap.bottom) {\n      horizontalPoses.push(top + height);\n      boundMap.bottom = true;\n    }\n\n    if (leftBoundInfo.isBound && !boundMap.left) {\n      verticalPoses.push(left);\n      boundMap.left = true;\n    }\n\n    if (rightBoundInfo.isBound && !boundMap.right) {\n      verticalPoses.push(left + width);\n      boundMap.right = true;\n    }\n  });\n  return {\n    horizontal: horizontalPoses,\n    vertical: verticalPoses\n  };\n}\n\nfunction checkBoundPoses(moveable, verticalPoses, horizontalPoses) {\n  var _a = moveable.props.bounds || {},\n      _b = _a.left,\n      left = _b === void 0 ? -Infinity : _b,\n      _c = _a.top,\n      top = _c === void 0 ? -Infinity : _c,\n      _d = _a.right,\n      right = _d === void 0 ? Infinity : _d,\n      _e = _a.bottom,\n      bottom = _e === void 0 ? Infinity : _e;\n\n  var bounds = {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom\n  };\n  return {\n    vertical: checkBound(bounds, verticalPoses, true),\n    horizontal: checkBound(bounds, horizontalPoses, false)\n  };\n}\n\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\n  var _a = moveable.props.bounds || {},\n      _b = _a.left,\n      left = _b === void 0 ? -Infinity : _b,\n      _c = _a.top,\n      top = _c === void 0 ? -Infinity : _c,\n      _d = _a.right,\n      right = _d === void 0 ? Infinity : _d,\n      _e = _a.bottom,\n      bottom = _e === void 0 ? Infinity : _e;\n\n  var endX = endPos[0],\n      endY = endPos[1];\n\n  var _f = minus(endPos, startPos),\n      dx = _f[0],\n      dy = _f[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  var verticalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  } else if (dx === 0) {\n    if (isBottom) {\n      if (bottom < endY) {\n        horizontalInfo.pos = bottom;\n        horizontalInfo.offset = endY - bottom;\n      }\n    } else {\n      if (top > endY) {\n        horizontalInfo.pos = top;\n        horizontalInfo.offset = endY - top;\n      }\n    }\n  } else if (dy === 0) {\n    if (isRight) {\n      if (right < endX) {\n        verticalInfo.pos = right;\n        verticalInfo.offset = endX - right;\n      }\n    } else {\n      if (left > endX) {\n        verticalInfo.pos = left;\n        verticalInfo.offset = endX - left;\n      }\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isBound = false;\n\n    if (isRight && right <= endX) {\n      y = a * right + b;\n      x = right;\n      isBound = true;\n    } else if (!isRight && endX <= left) {\n      y = a * left + b;\n      x = left;\n      isBound = true;\n    }\n\n    if (isBound) {\n      if (y < top || y > bottom) {\n        isBound = false;\n      }\n    }\n\n    if (!isBound) {\n      if (isBottom && bottom <= endY) {\n        y = bottom;\n        x = (y - b) / a;\n        isBound = true;\n      } else if (!isBottom && endY <= top) {\n        y = top;\n        x = (y - b) / a;\n        isBound = true;\n      }\n    }\n\n    if (isBound) {\n      verticalInfo.isBound = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isBound = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkBound(bounds, poses, isVertical) {\n  // 0   [100 - 200]  300\n  var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n  var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"]; // 450\n\n  var minPos = Math.min.apply(Math, poses);\n  var maxPos = Math.max.apply(Math, poses);\n\n  if (startBoundPos + 1 > minPos) {\n    return {\n      isBound: true,\n      offset: minPos - startBoundPos,\n      pos: startBoundPos\n    };\n  }\n\n  if (endBoundPos - 1 < maxPos) {\n    return {\n      isBound: true,\n      offset: maxPos - endBoundPos,\n      pos: endBoundPos\n    };\n  }\n\n  return {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n}\n\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  return nextPoses.some(function (pos) {\n    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;\n  });\n}\n\nfunction boundRotate(vec, boundPos, index) {\n  var r = getDistSize(vec);\n  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n  return [nextPos, -nextPos].sort(function (a, b) {\n    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n  }).map(function (pos) {\n    return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n  });\n}\n\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.bounds;\n  var rad = rotation * Math.PI / 180;\n\n  if (!bounds) {\n    return [];\n  }\n\n  var _a = bounds.left,\n      left = _a === void 0 ? -Infinity : _a,\n      _b = bounds.top,\n      top = _b === void 0 ? -Infinity : _b,\n      _c = bounds.right,\n      right = _c === void 0 ? Infinity : _c,\n      _d = bounds.bottom,\n      bottom = _d === void 0 ? Infinity : _d;\n  var relativeLeft = left - origin[0];\n  var relativeRight = right - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = bottom - origin[1];\n  var boundRect = {\n    left: relativeLeft,\n    top: relativeTop,\n    right: relativeRight,\n    bottom: relativeBottom\n  };\n\n  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\n    return [];\n  }\n\n  var result = [];\n  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a, i) {\n    var boundPos = _a[0],\n        index = _a[1];\n    nextPoses.forEach(function (nextPos) {\n      var relativeRad1 = getRad([0, 0], nextPos);\n      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {\n        return rad + relativeRad2 - relativeRad1;\n      }).filter(function (nextRad) {\n        return !isBoundRotate$1(prevPoses, boundRect, nextRad);\n      }).map(function (nextRad) {\n        return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  });\n  return result;\n}\n\nfunction caculateContainerPos(rootMatrix, containerRect, n) {\n  var clientPos = caculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);\n  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];\n}\n\nfunction snapStart(moveable) {\n  var state = moveable.state;\n\n  if (state.guidelines && state.guidelines.length) {\n    return;\n  }\n\n  var _a = moveable.props,\n      _b = _a.horizontalGuidelines,\n      horizontalGuidelines = _b === void 0 ? [] : _b,\n      _c = _a.verticalGuidelines,\n      verticalGuidelines = _c === void 0 ? [] : _c,\n      _d = _a.elementGuidelines,\n      elementGuidelines = _d === void 0 ? [] : _d,\n      bounds = _a.bounds,\n      innerBounds = _a.innerBounds,\n      snapCenter = _a.snapCenter;\n\n  if (!innerBounds && !bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n    return;\n  }\n\n  var containerClientRect = state.containerClientRect,\n      _e = state.targetClientRect,\n      clientTop = _e.top,\n      clientLeft = _e.left,\n      rootMatrix = state.rootMatrix,\n      is3d = state.is3d;\n  var n = is3d ? 4 : 3;\n\n  var _f = caculateContainerPos(rootMatrix, containerClientRect, n),\n      containerLeft = _f[0],\n      containerTop = _f[1];\n\n  var poses = getAbsolutePosesByState(state);\n  var targetLeft = Math.min.apply(Math, poses.map(function (pos) {\n    return pos[0];\n  }));\n  var targetTop = Math.min.apply(Math, poses.map(function (pos) {\n    return pos[1];\n  }));\n\n  var _g = minus([targetLeft, targetTop], caculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function (pos) {\n    return roundSign(pos);\n  }),\n      distLeft = _g[0],\n      distTop = _g[1];\n\n  var guidelines = [];\n  elementGuidelines.forEach(function (el) {\n    var rect = el.getBoundingClientRect();\n    var left = rect.left - containerLeft;\n    var top = rect.top - containerTop;\n    var bottom = top + rect.height;\n    var right = left + rect.width;\n\n    var _a = caculateInversePosition(rootMatrix, [left, top], n),\n        elementLeft = _a[0],\n        elementTop = _a[1];\n\n    var _b = caculateInversePosition(rootMatrix, [right, bottom], n),\n        elementRight = _b[0],\n        elementBottom = _b[1];\n\n    var width = elementRight - elementLeft;\n    var height = elementBottom - elementTop;\n    var sizes = [width, height];\n    guidelines.push({\n      type: \"vertical\",\n      element: el,\n      pos: [throttle(elementLeft + distLeft, 0.1), elementTop],\n      size: height,\n      sizes: sizes\n    });\n    guidelines.push({\n      type: \"vertical\",\n      element: el,\n      pos: [throttle(elementRight + distLeft, 0.1), elementTop],\n      size: height,\n      sizes: sizes\n    });\n    guidelines.push({\n      type: \"horizontal\",\n      element: el,\n      pos: [elementLeft, throttle(elementTop + distTop, 0.1)],\n      size: width,\n      sizes: sizes\n    });\n    guidelines.push({\n      type: \"horizontal\",\n      element: el,\n      pos: [elementLeft, throttle(elementBottom + distTop, 0.1)],\n      size: width,\n      sizes: sizes\n    });\n\n    if (snapCenter) {\n      guidelines.push({\n        type: \"vertical\",\n        element: el,\n        pos: [throttle((elementLeft + elementRight) / 2 + distLeft, 0.1), elementTop],\n        size: height,\n        sizes: sizes,\n        center: true\n      });\n      guidelines.push({\n        type: \"horizontal\",\n        element: el,\n        pos: [elementLeft, throttle((elementTop + elementBottom) / 2 + distTop, 0.1)],\n        size: width,\n        sizes: sizes,\n        center: true\n      });\n    }\n  });\n  state.guidelines = guidelines;\n  state.enableSnap = true;\n}\n\nfunction hasGuidelines(moveable, ableName) {\n  var _a = moveable.props,\n      snappable = _a.snappable,\n      bounds = _a.bounds,\n      innerBounds = _a.innerBounds,\n      verticalGuidelines = _a.verticalGuidelines,\n      horizontalGuidelines = _a.horizontalGuidelines,\n      _b = moveable.state,\n      guidelines = _b.guidelines,\n      enableSnap = _b.enableSnap;\n\n  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {\n    return false;\n  }\n\n  if (bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction solveNextOffset(pos1, pos2, offset, isVertical, datas) {\n  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);\n\n  if (!sizeOffset) {\n    return [0, 0];\n  }\n\n  var _a = getDragDist({\n    datas: datas,\n    distX: sizeOffset[0],\n    distY: sizeOffset[1]\n  }),\n      widthOffset = _a[0],\n      heightOffset = _a[1];\n\n  return [widthOffset, heightOffset];\n}\n\nfunction getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {\n  var nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n  var nextPos = getPosByReverseDirection(nextPoses, direction);\n  return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\n\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return snapInfo.offset;\n  }\n\n  return 0;\n}\n\nfunction getSnapBound(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return getNearestSnapGuidelineInfo(snapInfo).offset;\n  }\n\n  return 0;\n}\n\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {\n  var _a = checkBoundKeepRatio(moveable, startPos, endPos),\n      horizontalBoundInfo = _a.horizontal,\n      verticalBoundInfo = _a.vertical;\n\n  var _b = isRequest ? {\n    horizontal: {\n      isSnap: false\n    },\n    vertical: {\n      isSnap: false\n    }\n  } : checkSnapKeepRatio(moveable, startPos, endPos),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\n\nfunction checkSnapBounds(moveable, isRequest, poses, boundPoses) {\n  if (boundPoses === void 0) {\n    boundPoses = poses;\n  }\n\n  var _a = checkBoundPoses(moveable, boundPoses.map(function (pos) {\n    return pos[0];\n  }), boundPoses.map(function (pos) {\n    return pos[1];\n  })),\n      horizontalBoundInfo = _a.horizontal,\n      verticalBoundInfo = _a.vertical;\n\n  var _b = isRequest ? {\n    horizontal: {\n      isSnap: false\n    },\n    vertical: {\n      isSnap: false\n    }\n  } : checkSnapPoses(moveable, poses.map(function (pos) {\n    return pos[0];\n  }), poses.map(function (pos) {\n    return pos[1];\n  })),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\n\nfunction normalized(value) {\n  return value ? value / Math.abs(value) : 0;\n}\n\nfunction checkMaxBounds(moveable, poses, direction, fixedPos, datas) {\n  var fixedDirection = [-direction[0], -direction[1]];\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  var bounds = moveable.props.bounds;\n  var maxWidth = Infinity;\n  var maxHeight = Infinity;\n\n  if (bounds) {\n    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];\n    var _b = bounds.left,\n        left_1 = _b === void 0 ? -Infinity : _b,\n        _c = bounds.top,\n        top_1 = _c === void 0 ? -Infinity : _c,\n        _d = bounds.right,\n        right_1 = _d === void 0 ? Infinity : _d,\n        _e = bounds.bottom,\n        bottom_1 = _e === void 0 ? Infinity : _e;\n    directions.forEach(function (otherDirection) {\n      var isCheckVertical = otherDirection[0] !== fixedDirection[0];\n      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n      var otherPos = getPosByDirection(poses, otherDirection);\n      var verticalDirection = normalized(otherDirection[1] - fixedDirection[1]);\n      var horizontalDirection = normalized(otherDirection[0] - fixedDirection[0]);\n      var deg = getRad(fixedPos, otherPos) * 360 / Math.PI;\n\n      if (isCheckHorizontal) {\n        var nextOtherPos = otherPos.slice();\n\n        if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n          nextOtherPos[1] = fixedPos[1];\n        }\n\n        var _a = solveNextOffset(fixedPos, nextOtherPos, (fixedPos[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),\n            heightOffset = _a[1];\n\n        if (!isNaN(heightOffset)) {\n          maxHeight = height + verticalDirection * heightOffset;\n        }\n      }\n\n      if (isCheckVertical) {\n        var nextOtherPos = otherPos.slice();\n\n        if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n          nextOtherPos[0] = fixedPos[0];\n        }\n\n        var widthOffset = solveNextOffset(fixedPos, nextOtherPos, (fixedPos[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas)[0];\n\n        if (!isNaN(widthOffset)) {\n          maxWidth = width + horizontalDirection * widthOffset;\n        }\n      }\n    });\n  }\n\n  return {\n    maxWidth: maxWidth,\n    maxHeight: maxHeight\n  };\n}\n\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {\n  return directions.map(function (_a) {\n    var startDirection = _a[0],\n        endDirection = _a[1];\n    var otherStartPos = getPosByDirection(poses, startDirection);\n    var otherEndPos = getPosByDirection(poses, endDirection);\n    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkSnapBounds(moveable, isRequest, [otherEndPos]);\n    var _b = snapBoundInfo.horizontal,\n        otherHorizontalDist = _b.dist,\n        otherHorizontalOffset = _b.offset,\n        isOtherHorizontalBound = _b.isBound,\n        isOtherHorizontalSnap = _b.isSnap,\n        _c = snapBoundInfo.vertical,\n        otherVerticalDist = _c.dist,\n        otherVerticalOffset = _c.offset,\n        isOtherVerticalBound = _c.isBound,\n        isOtherVerticalSnap = _c.isSnap;\n    var multiple = minus(endDirection, startDirection);\n\n    if (!otherVerticalOffset && !otherHorizontalOffset) {\n      return {\n        isBound: isOtherVerticalBound || isOtherHorizontalBound,\n        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n        sign: multiple,\n        offset: [0, 0]\n      };\n    }\n\n    var isVertical = otherHorizontalDist < otherVerticalDist;\n    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getCheckSnapDirections(direction, keepRatio) {\n  var directions = [];\n  var fixedDirection = [-direction[0], -direction[1]];\n\n  if (direction[0] && direction[1]) {\n    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);\n\n    if (keepRatio) {\n      // pass two direction condition\n      directions.push([fixedDirection, direction]);\n    }\n  } else if (direction[0]) {\n    // vertcal\n    if (keepRatio) {\n      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);\n    } else {\n      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);\n    }\n  } else if (direction[1]) {\n    // horizontal\n    if (keepRatio) {\n      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);\n    } else {\n      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);\n  }\n\n  return directions;\n}\n\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, isRequest, datas) {\n  var directions = getCheckSnapDirections(direction, keepRatio);\n  var lines = getCheckSnapLines(poses, direction, keepRatio);\n  var offsets = getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas).concat(getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));\n  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n  return {\n    width: {\n      isBound: widthOffsetInfo.isBound,\n      offset: widthOffsetInfo.offset[0]\n    },\n    height: {\n      isBound: heightOffsetInfo.isBound,\n      offset: heightOffsetInfo.offset[1]\n    }\n  };\n}\n\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, isRequest, datas) {\n  var snapPos = getPosByDirection(poses, direction);\n\n  var _a = checkSnapBounds(moveable, isRequest, [snapPos]),\n      horizontalOffset = _a.horizontal.offset,\n      verticalOffset = _a.vertical.offset;\n\n  if (verticalOffset || horizontalOffset) {\n    var _b = getDragDist({\n      datas: datas,\n      distX: -verticalOffset,\n      distY: -horizontalOffset\n    }),\n        nextWidthOffset = _b[0],\n        nextHeightOffset = _b[1];\n\n    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n    return [nextWidth - width, nextHeight - height];\n  }\n\n  return [0, 0];\n}\n\nfunction checkSizeDist(moveable, getNextPoses, width, height, direction, fixedPos, isRequest, datas) {\n  var poses = getAbsolutePosesByState(moveable.state);\n  var keepRatio = moveable.props.keepRatio;\n  var widthOffset = 0;\n  var heightOffset = 0;\n\n  for (var i = 0; i < 2; ++i) {\n    var nextPoses = getNextPoses(widthOffset, heightOffset);\n\n    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, isRequest, datas),\n        widthOffsetInfo = _a.width,\n        heightOffsetInfo = _a.height;\n\n    var isWidthBound = widthOffsetInfo.isBound;\n    var isHeightBound = heightOffsetInfo.isBound;\n    var nextWidthOffset = widthOffsetInfo.offset;\n    var nextHeightOffset = heightOffsetInfo.offset;\n\n    if (i === 1) {\n      if (!isWidthBound) {\n        nextWidthOffset = 0;\n      }\n\n      if (!isHeightBound) {\n        nextHeightOffset = 0;\n      }\n    }\n\n    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n      return [0, 0];\n    }\n\n    if (keepRatio) {\n      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist; // height * widthOffset = width * heighOffset\n\n      if (isGetWidthOffset) {\n        // width : height = ? : heightOffset\n        nextWidthOffset = width * nextHeightOffset / height;\n      } else {\n        // width : height = widthOffset : ?\n        nextHeightOffset = height * nextWidthOffset / width;\n      }\n    }\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  if (direction[0] && direction[1]) {\n    var _b = checkMaxBounds(moveable, poses, direction, fixedPos, datas),\n        maxWidth = _b.maxWidth,\n        maxHeight = _b.maxHeight;\n\n    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, isRequest, datas),\n        nextWidthOffset = _c[0],\n        nextHeightOffset = _c[1];\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  return [widthOffset, heightOffset];\n}\n\nfunction checkSnapRotate(moveable, rect, origin, rotation) {\n  if (!hasGuidelines(moveable, \"rotatable\")) {\n    return rotation;\n  }\n\n  var pos1 = rect.pos1,\n      pos2 = rect.pos2,\n      pos3 = rect.pos3,\n      pos4 = rect.pos4;\n  var rad = rotation * Math.PI / 180;\n  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {\n    return minus(pos, origin);\n  });\n  var nextPoses = prevPoses.map(function (pos) {\n    return rotate(pos, rad);\n  });\n  var result = checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation).concat(checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));\n  result.sort(function (a, b) {\n    return Math.abs(a - rotation) - Math.abs(b - rotation);\n  });\n\n  if (result.length) {\n    return result[0];\n  } else {\n    return rotation;\n  }\n}\n\nfunction checkSnapSize(moveable, width, height, direction, fixedPos, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"resizable\")) {\n    return [0, 0];\n  }\n\n  var _a = moveable.state,\n      matrix = _a.matrix,\n      is3d = _a.is3d;\n  return checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(matrix, width + widthOffset, height + heightOffset, fixedPos, direction, is3d);\n  }, width, height, direction, fixedPos, isRequest, datas);\n}\n\nfunction checkSnapScale(moveable, scale, direction, fixedPos, isRequest, datas) {\n  var width = datas.width,\n      height = datas.height;\n\n  if (!hasGuidelines(moveable, \"scalable\")) {\n    return [0, 0];\n  }\n\n  var is3d = datas.is3d;\n  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPos, direction, is3d);\n  }, width, height, direction, fixedPos, isRequest, datas);\n  return [sizeDist[0] / width, sizeDist[1] / height];\n}\n\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  if (!dx) {\n    // y = 0 * x + b\n    // only horizontal\n    if (!isVertical) {\n      return [0, snapOffset];\n    }\n\n    return [0, 0];\n  }\n\n  if (!dy) {\n    // only vertical\n    if (isVertical) {\n      return [snapOffset, 0];\n    }\n\n    return [0, 0];\n  } // y = ax + b\n\n\n  var a = dy / dx;\n  var b = pos1[1] - a * pos1[0];\n\n  if (isVertical) {\n    // y = a * x + b\n    var y = a * (pos2[0] + snapOffset) + b;\n    return [snapOffset, y - pos2[1]];\n  } else {\n    // x = (y - b) / a\n    var x = (pos2[1] + snapOffset - b) / a;\n    return [x - pos2[0], snapOffset];\n  }\n}\n\nfunction startCheckSnapDrag(moveable, datas) {\n  datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nfunction checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {\n  var distX = _a[0],\n      distY = _a[1];\n  var isVerticalBound = _b[0],\n      isHorizontalBound = _b[1];\n  var isVerticalSnap = _c[0],\n      isHorizontalSnap = _c[1];\n  var verticalOffset = _d[0],\n      horizontalOffset = _d[1];\n  var offsetX = -verticalOffset;\n  var offsetY = -horizontalOffset;\n\n  if (throttleDragRotate && distX && distY) {\n    offsetX = 0;\n    offsetY = 0;\n    var adjustPoses = [];\n\n    if (isVerticalBound && isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalBound) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset]);\n    } else if (isVerticalSnap && isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalSnap) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset]);\n    }\n\n    if (adjustPoses.length) {\n      adjustPoses.sort(function (a, b) {\n        return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n      });\n      var adjustPos = adjustPoses[0];\n\n      if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n        offsetX = -adjustPos[0];\n        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n        var prevDistY = distY;\n        offsetY = -adjustPos[1];\n        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n      }\n\n      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n        if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else {\n          offsetX = maxOffset(-verticalOffset, offsetX);\n          offsetY = maxOffset(-horizontalOffset, offsetY);\n        }\n      }\n    }\n  } else {\n    offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n  }\n\n  return [offsetX, offsetY];\n}\n\nfunction checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"draggable\")) {\n    return [{\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }, {\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }];\n  }\n\n  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n\n  var _a = getRect(poses),\n      left = _a.left,\n      right = _a.right,\n      top = _a.top,\n      bottom = _a.bottom;\n\n  var snapCenter = moveable.props.snapCenter;\n  var snapPoses = [[left, top], [right, top], [left, bottom], [right, bottom]];\n\n  if (snapCenter) {\n    snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n  }\n\n  var _b = checkSnapBounds(moveable, isRequest, snapPoses, poses),\n      verticalSnapBoundInfo = _b.vertical,\n      horizontalSnapBoundInfo = _b.horizontal;\n\n  var _c = getInnerBoundDragInfo(moveable, poses, datas),\n      verticalInnerBoundInfo = _c.vertical,\n      horizontalInnerBoundInfo = _c.horizontal;\n\n  var isVerticalSnap = verticalSnapBoundInfo.isSnap;\n  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n\n  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),\n      offsetX = _d[0],\n      offsetY = _d[1];\n\n  return [{\n    isBound: isVerticalBound,\n    isSnap: isVerticalSnap,\n    offset: offsetX\n  }, {\n    isBound: isHorizontalBound,\n    isSnap: isHorizontalSnap,\n    offset: offsetY\n  }];\n}\n\nfunction getSnapGuidelines(posInfos) {\n  var guidelines = [];\n  posInfos.forEach(function (posInfo) {\n    posInfo.guidelineInfos.forEach(function (_a) {\n      var guideline = _a.guideline;\n\n      if (guidelines.indexOf(guideline) > -1) {\n        return;\n      }\n\n      guidelines.push(guideline);\n    });\n  });\n  return guidelines;\n}\n\nfunction getElementGuidelineDist(elementPos, elementSize, targetPos, targetSize) {\n  // relativePos < 0  => element(l)  ---  (r)target\n  // relativePos > 0  => target(l)   ---  (r)element\n  var relativePos = elementPos - targetPos;\n  var startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n  var endPos = relativePos < 0 ? 0 : relativePos;\n  var size = endPos - startPos;\n  return {\n    size: size,\n    pos: startPos\n  };\n}\n\nfunction groupByElementGuidelines(guidelines, clientPos, size, index) {\n  var groupInfos = [];\n  var group = groupBy(guidelines.filter(function (_a) {\n    var element = _a.element,\n        gap = _a.gap;\n    return element && !gap;\n  }), function (_a) {\n    var element = _a.element,\n        pos = _a.pos;\n    var elementPos = pos[index];\n    var sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n    var groupKey = sign + \"_\" + pos[index ? 0 : 1];\n    var groupInfo = find(groupInfos, function (_a) {\n      var groupElement = _a[0],\n          groupPos = _a[1];\n      return element === groupElement && elementPos === groupPos;\n    });\n\n    if (groupInfo) {\n      return groupInfo[2];\n    }\n\n    groupInfos.push([element, elementPos, groupKey]);\n    return groupKey;\n  });\n  group.forEach(function (elementGuidelines) {\n    elementGuidelines.sort(function (a, b) {\n      var result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n      return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n    });\n  });\n  return group;\n}\n\nfunction renderElementGroup(group, _a, minPos, clientPos, clientSize, targetPos, snapThreshold, isDisplaySnapDigit, snapDigit, index, snapDistFormat, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return flat(group.map(function (elementGuidelines, i) {\n    var isFirstRenderSize = true;\n    return elementGuidelines.map(function (_a, j) {\n      var _b;\n\n      var pos = _a.pos,\n          size = _a.size;\n\n      var _c = getElementGuidelineDist(pos[index], size, clientPos, clientSize),\n          linePos = _c.pos,\n          lineSize = _c.size;\n\n      if (lineSize < snapThreshold) {\n        return null;\n      }\n\n      var isRenderSize = isFirstRenderSize;\n      isFirstRenderSize = false;\n      var snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n      return React.createElement(\"div\", {\n        className: prefix(\"line\", directionName, \"guideline\", \"dashed\"),\n        \"data-size\": snapSize > 0 ? snapDistFormat(snapSize) : \"\",\n        key: directionName + \"LinkGuidline\" + i + \"-\" + j,\n        style: (_b = {}, _b[posName1] = minPos + linePos + \"px\", _b[posName2] = -targetPos + pos[index ? 0 : 1] + \"px\", _b[sizeName] = lineSize + \"px\", _b)\n      });\n    });\n  }));\n}\n\nfunction renderSnapPoses(snapPoses, _a, minPos, targetPos, size, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return snapPoses.map(function (_a, i) {\n    var _b;\n\n    var type = _a.type,\n        pos = _a.pos;\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", directionName, \"guideline\", \"target\", \"bold\", type),\n      key: directionName + \"TargetGuidline\" + i,\n      style: (_b = {}, _b[posName1] = minPos + \"px\", _b[posName2] = -targetPos + pos + \"px\", _b[sizeName] = size + \"px\", _b)\n    });\n  });\n}\n\nfunction renderGuidelines(guidelines, _a, targetPos1, targetPos2, index, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return guidelines.map(function (guideline, i) {\n    var _a;\n\n    var pos = guideline.pos,\n        size = guideline.size,\n        element = guideline.element;\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", directionName, \"guideline\", element ? \"bold\" : \"\"),\n      key: directionName + \"Guidline\" + i,\n      style: (_a = {}, _a[posName1] = -targetPos1 + pos[index] + \"px\", _a[posName2] = -targetPos2 + pos[index ? 0 : 1] + \"px\", _a[sizeName] = size + \"px\", _a)\n    });\n  });\n}\n\nfunction getGapGuidelinesToStart(guidelines, index, targetPos, targetSizes, guidelinePos, gap, otherPos) {\n  var absGap = Math.abs(gap);\n  var start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n  return guidelines.filter(function (_a) {\n    var gapPos = _a.pos;\n    return gapPos[index] <= targetPos[index];\n  }).sort(function (_a, _b) {\n    var aPos = _a.pos;\n    var bPos = _b.pos;\n    return bPos[index] - aPos[index];\n  }).filter(function (_a) {\n    var gapPos = _a.pos,\n        gapSizes = _a.sizes;\n    var nextPos = gapPos[index];\n\n    if (throttle(nextPos + gapSizes[index], 0.0001) === throttle(start - absGap, 0.0001)) {\n      start = nextPos;\n      return true;\n    }\n\n    return false;\n  }).map(function (gapGuideline) {\n    var renderPos = -targetPos[index] + gapGuideline.pos[index] + gapGuideline.sizes[index];\n    return __assign({}, gapGuideline, {\n      gap: gap,\n      renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos]\n    });\n  });\n}\n\nfunction getGapGuidelinesToEnd(guidelines, index, targetPos, targetSizes, guidelinePos, gap, otherPos) {\n  var absGap = Math.abs(gap);\n  var start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n  return guidelines.filter(function (_a) {\n    var gapPos = _a.pos;\n    return gapPos[index] > targetPos[index];\n  }).sort(function (_a, _b) {\n    var aPos = _a.pos;\n    var bPos = _b.pos;\n    return aPos[index] - bPos[index];\n  }).filter(function (_a) {\n    var gapPos = _a.pos,\n        gapSizes = _a.sizes;\n    var nextPos = gapPos[index];\n\n    if (throttle(nextPos, 0.0001) === throttle(start + absGap, 0.0001)) {\n      start = nextPos + gapSizes[index];\n      return true;\n    }\n\n    return false;\n  }).map(function (gapGuideline) {\n    var renderPos = -targetPos[index] + gapGuideline.pos[index] - absGap;\n    return __assign({}, gapGuideline, {\n      gap: gap,\n      renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos]\n    });\n  });\n}\n\nfunction getGapGuidelines$1(guidelines, type, targetPos, targetSizes) {\n  var elementGuidelines = guidelines.filter(function (_a) {\n    var element = _a.element,\n        gap = _a.gap,\n        guidelineType = _a.type;\n    return element && gap && guidelineType === type;\n  });\n\n  var _a = type === \"vertical\" ? [0, 1] : [1, 0],\n      index = _a[0],\n      otherIndex = _a[1];\n\n  return flat(elementGuidelines.map(function (guideline, i) {\n    var pos = guideline.pos;\n    var gap = guideline.gap;\n    var gapGuidelines = guideline.gapGuidelines;\n    var sizes = guideline.sizes;\n    var offset = minOffset(pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex], pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex]);\n    var minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);\n\n    if (offset > 0 && offset > minSize) {\n      offset = (offset - minSize / 2) * 2;\n    } else if (offset < 0 && offset < -minSize) {\n      offset = (offset + minSize / 2) * 2;\n    }\n\n    var otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n    return getGapGuidelinesToStart(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos).concat(getGapGuidelinesToEnd(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos));\n  }));\n}\n\nfunction renderGapGuidelines(moveable, gapGuidelines, type, _a, snapDistFormat, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  var _b = moveable.props,\n      _c = _b.snapDigit,\n      snapDigit = _c === void 0 ? 0 : _c,\n      _d = _b.isDisplaySnapDigit,\n      isDisplaySnapDigit = _d === void 0 ? true : _d;\n  var otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n\n  var _e = type === \"vertical\" ? [0, 1] : [1, 0],\n      index = _e[0],\n      otherIndex = _e[1];\n\n  return gapGuidelines.map(function (_a, i) {\n    var _b;\n\n    var renderPos = _a.renderPos,\n        gap = _a.gap;\n    var absGap = Math.abs(gap);\n    var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", directionName, \"guideline\", \"gap\"),\n      \"data-size\": snapSize > 0 ? snapDistFormat(snapSize) : \"\",\n      key: otherType + \"GapGuideline\" + i,\n      style: (_b = {}, _b[posName1] = renderPos[index] + \"px\", _b[posName2] = renderPos[otherIndex] + \"px\", _b[sizeName] = absGap + \"px\", _b)\n    });\n  });\n}\n\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses) {\n  var _a = checkBoundPoses(moveable, verticalPoses, horizontalPoses),\n      _b = _a.vertical,\n      isVerticalBound = _b.isBound,\n      verticalBoundPos = _b.pos,\n      _c = _a.horizontal,\n      isHorizontalBound = _c.isBound,\n      horizontalBoundPos = _c.pos;\n\n  if (isVerticalBound) {\n    verticalSnapPoses.push({\n      type: \"bounds\",\n      pos: verticalBoundPos\n    });\n  }\n\n  if (isHorizontalBound) {\n    horizontalSnapPoses.push({\n      type: \"bounds\",\n      pos: horizontalBoundPos\n    });\n  }\n\n  var _d = checkInnerBoundPoses(moveable),\n      verticalInnerBoundPoses = _d.vertical,\n      horizontalInnerBoundPoses = _d.horizontal;\n\n  verticalInnerBoundPoses.forEach(function (innerPos) {\n    if (findIndex(verticalSnapPoses, function (_a) {\n      var type = _a.type,\n          pos = _a.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n\n    verticalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n  horizontalInnerBoundPoses.forEach(function (innerPos) {\n    if (findIndex(horizontalSnapPoses, function (_a) {\n      var type = _a.type,\n          pos = _a.pos;\n      return type === \"bounds\" && pos === innerPos;\n    }) >= 0) {\n      return;\n    }\n\n    horizontalSnapPoses.push({\n      type: \"bounds\",\n      pos: innerPos\n    });\n  });\n}\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\n\n\nvar Snappable = {\n  name: \"snappable\",\n  props: {\n    snappable: [Boolean, Array],\n    snapCenter: Boolean,\n    snapHorizontal: Boolean,\n    snapVertical: Boolean,\n    snapElement: Boolean,\n    snapGap: Boolean,\n    isDisplaySnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object,\n    snapDistFormat: Function\n  },\n  events: {\n    onSnap: \"snap\"\n  },\n  css: [\":host {\\n    --bounds-color: #d66;\\n}\", \".guideline {\\n    pointer-events: none;\\n    z-index: 1;\\n}\", \".line.guideline.bounds {\\n    background: #d66;\\n    background: var(--bounds-color);\\n}\"],\n  render: function (moveable, React) {\n    var _a = moveable.state,\n        targetTop = _a.top,\n        targetLeft = _a.left,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        snapRenderInfo = _a.snapRenderInfo,\n        targetClientRect = _a.targetClientRect,\n        containerClientRect = _a.containerClientRect,\n        is3d = _a.is3d,\n        rootMatrix = _a.rootMatrix;\n\n    if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n      return [];\n    }\n\n    var n = is3d ? 4 : 3;\n    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n    var containerPos = caculateContainerPos(rootMatrix, containerClientRect, n);\n\n    var _b = caculateInversePosition(rootMatrix, [targetClientRect.left - containerPos[0], targetClientRect.top - containerPos[1]], n),\n        clientLeft = _b[0],\n        clientTop = _b[1];\n\n    var _c = moveable.props,\n        _d = _c.snapThreshold,\n        snapThreshold = _d === void 0 ? 5 : _d,\n        _e = _c.snapDigit,\n        snapDigit = _e === void 0 ? 0 : _e,\n        _f = _c.isDisplaySnapDigit,\n        isDisplaySnapDigit = _f === void 0 ? true : _f,\n        _g = _c.snapDistFormat,\n        snapDistFormat = _g === void 0 ? function (v) {\n      return v;\n    } : _g;\n    var poses = getAbsolutePosesByState(moveable.state);\n\n    var _h = getRect(poses),\n        width = _h.width,\n        height = _h.height,\n        top = _h.top,\n        left = _h.left,\n        bottom = _h.bottom,\n        right = _h.right;\n\n    var verticalSnapPoses = [];\n    var horizontalSnapPoses = [];\n    var verticalGuidelines = [];\n    var horizontalGuidelines = [];\n    var snapInfos = [];\n\n    if (!snapRenderInfo.request) {\n      if (snapRenderInfo.direction) {\n        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n      }\n\n      if (snapRenderInfo.snap) {\n        var rect = getRect(poses);\n\n        if (snapRenderInfo.center) {\n          rect.middle = (rect.top + rect.bottom) / 2;\n          rect.center = (rect.left + rect.right) / 2;\n        }\n\n        snapInfos.push(checkSnaps(moveable, rect, true, 1));\n      }\n\n      snapInfos.forEach(function (snapInfo) {\n        var verticalPosInfos = snapInfo.vertical.posInfos,\n            horizontalPosInfos = snapInfo.horizontal.posInfos;\n        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.map(function (posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.map(function (posInfo) {\n          return {\n            type: \"snap\",\n            pos: posInfo.pos\n          };\n        }));\n        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));\n        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));\n      });\n    }\n\n    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);\n    var elementHorizontalGroup = groupByElementGuidelines(horizontalGuidelines, clientLeft, width, 0);\n    var elementVerticalGroup = groupByElementGuidelines(verticalGuidelines, clientTop, height, 1);\n    var horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"];\n    var verticalNames = [\"vertical\", \"top\", \"left\", \"height\"];\n    var gapVerticalGuidelines = getGapGuidelines$1(verticalGuidelines, \"vertical\", [targetLeft, targetTop], [width, height]);\n    var gapHorizontalGuidelines = getGapGuidelines$1(horizontalGuidelines, \"horizontal\", [targetLeft, targetTop], [width, height]);\n    var allGuidelines = verticalGuidelines.concat(horizontalGuidelines);\n    triggerEvent(moveable, \"onSnap\", {\n      guidelines: allGuidelines.filter(function (_a) {\n        var element = _a.element;\n        return !element;\n      }),\n      elements: groupBy(allGuidelines.filter(function (_a) {\n        var element = _a.element;\n        return element;\n      }), function (_a) {\n        var element = _a.element;\n        return element;\n      }),\n      gaps: gapVerticalGuidelines.concat(gapHorizontalGuidelines)\n    }, true);\n    return renderGapGuidelines(moveable, gapVerticalGuidelines, \"vertical\", horizontalNames, snapDistFormat, React).concat(renderGapGuidelines(moveable, gapHorizontalGuidelines, \"horizontal\", verticalNames, snapDistFormat, React), renderElementGroup(elementHorizontalGroup, horizontalNames, minLeft, clientLeft, width, targetTop, snapThreshold, isDisplaySnapDigit, snapDigit, 0, snapDistFormat, React), renderElementGroup(elementVerticalGroup, verticalNames, minTop, clientTop, height, targetLeft, snapThreshold, isDisplaySnapDigit, snapDigit, 1, snapDistFormat, React), renderSnapPoses(horizontalSnapPoses, horizontalNames, minLeft, targetTop, width, React), renderSnapPoses(verticalSnapPoses, verticalNames, minTop, targetLeft, height, React), renderGuidelines(horizontalGuidelines, horizontalNames, targetLeft, targetTop, 0, React), renderGuidelines(verticalGuidelines, verticalNames, targetTop, targetLeft, 1, React));\n  },\n  dragStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest,\n      snap: true,\n      center: true\n    };\n    snapStart(moveable);\n  },\n  pinchStart: function (moveable) {\n    this.unset(moveable);\n  },\n  dragEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragControlCondition: function (e) {\n    return directionCondition(e) || dragControlCondition(e);\n  },\n  dragControlStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragControlEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragGroupStart: function (moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroupEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragGroupControlStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragGroupControlEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  unset: function (moveable) {\n    var state = moveable.state;\n    state.enableSnap = false;\n    state.guidelines = [];\n    state.snapRenderInfo = null;\n  }\n};\n/**\n* Whether or not target can be snapped to the guideline. (default: false)\n* @name Moveable.Snappable#snappable\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.snappable = true;\n*/\n\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable.Snappable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n * });\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * When you drag, make the snap in the vertical guidelines. (default: true)\n * @name Moveable.Snappable#snapVertical\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapVertical = false;\n */\n\n/**\n * When you drag, make the snap in the horizontal guidelines. (default: true)\n * @name Moveable.Snappable#snapHorizontal\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapHorizontal = false;\n */\n\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n\n/**\n * When you drag, make the snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapElement\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapElement = false;\n */\n\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n\n/**\n * You can set up boundaries. (default: null)\n * @name Moveable.Snappable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n\n/**\n * You can set up inner boundaries. (default: null)\n * @name Moveable.Snappable#innerBounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: v => v,\n * });\n * moveable.snapDistFormat = v => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\n\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number,\n    startDragRotate: Number\n  },\n  events: {\n    onDragStart: \"dragStart\",\n    onDrag: \"drag\",\n    onDragEnd: \"dragEnd\",\n    onDragGroupStart: \"dragGroupStart\",\n    onDragGroup: \"dragGroup\",\n    onDragGroupEnd: \"dragGroupEnd\"\n  },\n  render: function (moveable, React) {\n    var throttleDragRotate = moveable.props.throttleDragRotate;\n    var _a = moveable.state,\n        dragInfo = _a.dragInfo,\n        beforeOrigin = _a.beforeOrigin;\n\n    if (!throttleDragRotate || !dragInfo) {\n      return [];\n    }\n\n    var dist = dragInfo.dist;\n\n    if (!dist[0] && !dist[1]) {\n      return [];\n    }\n\n    var width = getDistSize(dist);\n    var rad = getRad(dist, [0, 0]);\n    return [React.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: width + \"px\",\n        transform: \"translate(\" + beforeOrigin[0] + \"px, \" + beforeOrigin[1] + \"px) rotate(\" + rad + \"rad)\"\n      }\n    })];\n  },\n  dragStart: function (moveable, e) {\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentDragger = e.parentDragger;\n    var state = moveable.state;\n    var targetTransform = state.targetTransform,\n        target = state.target,\n        dragger = state.dragger;\n\n    if (dragger) {\n      return false;\n    }\n\n    state.dragger = parentDragger || moveable.targetDragger;\n    var style = window.getComputedStyle(target);\n    datas.datas = {};\n    datas.left = parseFloat(style.left || \"\") || 0;\n    datas.top = parseFloat(style.top || \"\") || 0;\n    datas.bottom = parseFloat(style.bottom || \"\") || 0;\n    datas.right = parseFloat(style.right || \"\") || 0;\n    datas.transform = targetTransform;\n    datas.startTranslate = [0, 0];\n    setDragStart(moveable, {\n      datas: datas\n    });\n    datas.prevDist = [0, 0];\n    datas.prevBeforeDist = [0, 0];\n    datas.isDrag = false;\n    startCheckSnapDrag(moveable, datas);\n    var params = fillParams(moveable, e, {\n      set: function (translate) {\n        datas.startTranslate = translate;\n      }\n    });\n    var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n    if (result !== false) {\n      datas.isDrag = true;\n      moveable.state.dragInfo = {\n        startRect: moveable.getRect(),\n        dist: [0, 0]\n      };\n    } else {\n      state.dragger = null;\n      datas.isPinch = false;\n    }\n\n    return datas.isDrag ? params : false;\n  },\n  drag: function (moveable, e) {\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n    var distX = e.distX,\n        distY = e.distY;\n    var isDrag = datas.isDrag,\n        prevDist = datas.prevDist,\n        prevBeforeDist = datas.prevBeforeDist,\n        transform = datas.transform,\n        startTranslate = datas.startTranslate;\n\n    if (!isDrag) {\n      return;\n    }\n\n    var props = moveable.props;\n    var parentMoveable = props.parentMoveable;\n    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;\n    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n    var isSnap = false;\n    var dragRotateRad = 0;\n\n    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n      var startDragRotate = props.startDragRotate || 0;\n      var deg = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;\n      var ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n      var rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n      var r = getDistSize([rx, ry]);\n      dragRotateRad = deg * Math.PI / 180;\n      distX = r * Math.cos(dragRotateRad);\n      distY = r * Math.sin(dragRotateRad);\n    }\n\n    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n      var _a = checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas),\n          verticalInfo = _a[0],\n          horizontalInfo = _a[1];\n\n      var isVerticalSnap = verticalInfo.isSnap,\n          isVerticalBound = verticalInfo.isBound,\n          verticalOffset = verticalInfo.offset;\n      var isHorizontalSnap = horizontalInfo.isSnap,\n          isHorizontalBound = horizontalInfo.isBound,\n          horizontalOffset = horizontalInfo.offset;\n      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n      distX += verticalOffset;\n      distY += horizontalOffset;\n    }\n\n    datas.passDeltaX = distX - (datas.passDistX || 0);\n    datas.passDeltaY = distY - (datas.passDistY || 0);\n    datas.passDistX = distX;\n    datas.passDistY = distY;\n    var beforeTranslate = plus(getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, true), startTranslate);\n    var translate = plus(getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, false), startTranslate);\n\n    if (!throttleDragRotate && !isSnap) {\n      throttleArray(translate, throttleDrag);\n      throttleArray(beforeTranslate, throttleDrag);\n    }\n\n    var beforeDist = minus(beforeTranslate, startTranslate);\n    var dist = minus(translate, startTranslate);\n    var delta = minus(dist, prevDist);\n    var beforeDelta = minus(beforeDist, prevBeforeDist);\n    datas.prevDist = dist;\n    datas.prevBeforeDist = beforeDist;\n    var left = datas.left + beforeDist[0];\n    var top = datas.top + beforeDist[1];\n    var right = datas.right - beforeDist[0];\n    var bottom = datas.bottom - beforeDist[1];\n    var nextTransform = transform + \" translate(\" + dist[0] + \"px, \" + dist[1] + \"px)\";\n    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n\n    if (!parentEvent && !parentMoveable && delta.every(function (num) {\n      return !num;\n    }) && beforeDelta.some(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      transform: nextTransform,\n      dist: dist,\n      delta: delta,\n      translate: translate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeTranslate: beforeTranslate,\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      isPinch: isPinch\n    });\n    !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n    return params;\n  },\n  dragEnd: function (moveable, e) {\n    var parentEvent = e.parentEvent,\n        datas = e.datas,\n        isDrag = e.isDrag;\n    moveable.state.dragger = null;\n    moveable.state.dragInfo = null;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    datas.isDrag = false;\n    !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupStart: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY;\n    var params = this.dragStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var events = triggerChildDragger(moveable, this, \"dragStart\", [clientX || 0, clientY || 0], e, false);\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n    datas.isDrag = result !== false;\n    return datas.isDrag ? params : false;\n  },\n  dragGroup: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    var params = this.drag(moveable, e);\n    var _a = e.datas,\n        passDeltaX = _a.passDeltaX,\n        passDeltaY = _a.passDeltaY;\n    var events = triggerChildDragger(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n    if (!params) {\n      return;\n    }\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onDragGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    this.dragEnd(moveable, e);\n    triggerChildDragger(moveable, this, \"dragEnd\", [0, 0], e, false);\n    triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    }));\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Draggable#request\n   * @param {object} [e] - the draggable's request parameter\n   * @param {number} [e.x] - x position\n   * @param {number} [e.y] - y position\n   * @param {number} [e.deltaX] - X number to move\n   * @param {number} [e.deltaY] - Y number to move\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"draggable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100 });\n   * moveable.request(\"draggable\", { x: 220, y: 100 });\n   * moveable.request(\"draggable\", { x: 240, y: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function (moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    return {\n      isControl: false,\n      requestStart: function () {\n        return {\n          datas: datas\n        };\n      },\n      request: function (e) {\n        if (\"x\" in e) {\n          distX = e.x - rect.left;\n        } else if (\"deltaX\" in e) {\n          distX += e.deltaX;\n        }\n\n        if (\"y\" in e) {\n          distY = e.y - rect.top;\n        } else if (\"deltaY\" in e) {\n          distY += e.deltaY;\n        }\n\n        return {\n          datas: datas,\n          distX: distX,\n          distY: distY\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  },\n  unset: function (moveable) {\n    moveable.state.dragInfo = null;\n  }\n};\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group drag starts, the `dragGroupStart` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroupStart\n* @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroupStart\", ({ targets }) => {\n*     console.log(\"onDragGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group drag, the `dragGroup` event is called.\n* @memberof Moveable.Draggable\n* @event dragGroup\n* @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     draggable: true\n* });\n* moveable.on(\"dragGroup\", ({ targets, events }) => {\n*     console.log(\"onDragGroup\", targets);\n*     events.forEach(ev => {\n*          // drag event\n*          console.log(\"onDrag left, top\", ev.left, ev.top);\n*          // ev.target!.style.left = `${ev.left}px`;\n*          // ev.target!.style.top = `${ev.top}px`;\n*          console.log(\"onDrag translate\", ev.dist);\n*          ev.target!.style.transform = ev.transform;)\n*     });\n* });\n*/\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {\n  var n = moveable.state.is3d ? 4 : 3;\n  var nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n  datas.prevSnapDeg = datas.prevDeg;\n  datas.startDeg = datas.prevDeg;\n  datas.loop = 0;\n}\n\nfunction getParentDeg(moveable, moveableRect, datas, parentDist, direction, startRotate) {\n  var prevDeg = datas.prevDeg; // const absoluteDeg = startRotate + parentDist;\n\n  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);\n  datas.prevDeg = dist;\n  var delta = dist - prevDeg;\n  return [delta, dist, startRotate + dist];\n}\n\nfunction getDeg(moveable, moveableRect, datas, deg, direction, startRotate, throttleRotate, isSnap) {\n  var prevDeg = datas.prevDeg,\n      prevSnapDeg = datas.prevSnapDeg,\n      startDeg = datas.startDeg,\n      prevLoop = datas.loop;\n\n  if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n    // 360 => 0\n    ++datas.loop;\n  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n    // 0 => 360\n    --datas.loop;\n  }\n\n  var loop = datas.loop;\n  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n  var absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n  absoluteDeg = throttle(absoluteDeg, throttleRotate);\n  var dist = direction * (absoluteDeg - startRotate);\n\n  if (isSnap) {\n    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n    absoluteDeg = dist / direction + startRotate;\n  }\n\n  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n  return [delta, dist, startRotate + dist];\n}\n\nfunction getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startRotate, throttleRotate) {\n  return getDeg(moveable, moveableRect, datas, getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startRotate, throttleRotate, true);\n}\n\nfunction getPositions(rotationPosition, _a, direction) {\n  var pos1 = _a[0],\n      pos2 = _a[1],\n      pos3 = _a[2],\n      pos4 = _a[3];\n\n  var _b = (rotationPosition || \"top\").split(\"-\"),\n      dir1 = _b[0],\n      dir2 = _b[1];\n\n  var radPoses = [pos1, pos2]; // if (scale[0] < 0) {\n  //     dir1 = getReversePositionX(dir1);\n  //     dir2 = getReversePositionX(dir2);\n  // }\n  // if (scale[1] < 0) {\n  //     dir1 = getReversePositionY(dir1);\n  //     dir2 = getReversePositionY(dir2);\n  // }\n\n  if (dir1 === \"left\") {\n    radPoses = [pos3, pos1];\n  } else if (dir1 === \"right\") {\n    radPoses = [pos2, pos4];\n  } else if (dir1 === \"bottom\") {\n    radPoses = [pos4, pos3];\n  }\n\n  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];\n  var rad = getRotationRad(radPoses, direction);\n\n  if (dir2) {\n    var isStart = dir2 === \"top\" || dir2 === \"left\";\n    var isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];\n  }\n\n  return [pos, rad];\n}\n\nfunction dragControlCondition(e) {\n  if (e.isRequest) {\n    return e.requestAble === \"rotatable\";\n  }\n\n  return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nvar Rotatable = {\n  name: \"rotatable\",\n  canPinch: true,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number\n  },\n  events: {\n    onRotateStart: \"rotateStart\",\n    onRotate: \"rotate\",\n    onRotateEnd: \"rotateEnd\",\n    onRotateGroupStart: \"rotateGroupStart\",\n    onRotateGroup: \"rotateGroup\",\n    onRotateGroupEnd: \"rotateGroupEnd\"\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        rotatable = _a.rotatable,\n        rotationPosition = _a.rotationPosition;\n\n    if (!rotatable) {\n      return null;\n    }\n\n    var _b = moveable.state,\n        renderPoses = _b.renderPoses,\n        direction = _b.direction;\n\n    var _c = getPositions(rotationPosition, renderPoses, direction),\n        pos = _c[0],\n        rotationRad = _c[1];\n\n    return React.createElement(\"div\", {\n      key: \"rotation\",\n      className: prefix(\"line rotation-line\"),\n      style: {\n        // tslint:disable-next-line: max-line-length\n        transform: \"translate(-50%) translate(\" + pos[0] + \"px, \" + pos[1] + \"px) rotate(\" + rotationRad + \"rad)\"\n      }\n    }, React.createElement(\"div\", {\n      className: prefix(\"control\", \"rotation\")\n    }));\n  },\n  dragControlCondition: dragControlCondition,\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n    var _a = moveable.state,\n        target = _a.target,\n        left = _a.left,\n        top = _a.top,\n        origin = _a.origin,\n        beforeOrigin = _a.beforeOrigin,\n        direction = _a.direction,\n        beforeDirection = _a.beforeDirection,\n        targetTransform = _a.targetTransform;\n\n    if (!isRequest && !target) {\n      return false;\n    }\n\n    var rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left;\n    datas.top = top;\n\n    if (isRequest || isPinch || parentFlag) {\n      var externalRotate = parentRotate || 0;\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n      datas.afterInfo = {\n        origin: rect.origin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n    } else {\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin\n      };\n      datas.afterInfo = {\n        origin: rect.origin\n      };\n      var controlRect = getClientRect(moveable.controlBox.getElement());\n      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n    }\n\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startRotate = 0;\n    datas.datas = {};\n    var params = fillParams(moveable, e, {\n      set: function (rotatation) {\n        datas.startRotate = rotatation;\n      }\n    });\n    var result = triggerEvent(moveable, \"onRotateStart\", params);\n    datas.isRotate = result !== false;\n    moveable.state.snapRenderInfo = {\n      request: e.isRequest\n    };\n    return datas.isRotate ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch;\n    var direction = datas.direction,\n        beforeDirection = datas.beforeDirection,\n        beforeInfo = datas.beforeInfo,\n        afterInfo = datas.afterInfo,\n        isRotate = datas.isRotate,\n        startRotate = datas.startRotate,\n        rect = datas.rect;\n\n    if (!isRotate) {\n      return;\n    }\n\n    var _g = moveable.props,\n        _h = _g.throttleRotate,\n        throttleRotate = _h === void 0 ? 0 : _h,\n        parentMoveable = _g.parentMoveable;\n    var delta;\n    var dist;\n    var rotate;\n    var beforeDelta;\n    var beforeDist;\n    var beforeRotate;\n\n    if (!parentFlag && \"parentDist\" in e) {\n      var parentDist = e.parentDist;\n      _a = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate), delta = _a[0], dist = _a[1], rotate = _a[2];\n      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];\n    } else if (isPinch || parentFlag) {\n      _c = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate), delta = _c[0], dist = _c[1], rotate = _c[2];\n      _d = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate), beforeDelta = _d[0], beforeDist = _d[1], beforeRotate = _d[2];\n    } else {\n      _e = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate), delta = _e[0], dist = _e[1], rotate = _e[2];\n      _f = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate), beforeDelta = _f[0], beforeDist = _f[1], beforeRotate = _f[2];\n    }\n\n    if (!delta && !beforeDelta && !parentMoveable) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      delta: delta,\n      dist: dist,\n      rotate: rotate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeRotate: beforeRotate,\n      transform: datas.transform + \" rotate(\" + dist + \"deg)\",\n      isPinch: !!isPinch\n    });\n    triggerEvent(moveable, \"onRotate\", params);\n    return params;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isRotate) {\n      return false;\n    }\n\n    datas.isRotate = false;\n    triggerEvent(moveable, \"onRotateEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent;\n    var _a = moveable.state,\n        parentLeft = _a.left,\n        parentTop = _a.top,\n        parentBeforeOrigin = _a.beforeOrigin;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    params.set(datas.beforeDirection * moveable.rotation);\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, __assign({}, e, {\n      parentRotate: 0\n    }), function (child, childDatas, eventParams) {\n      var _a = child.state,\n          left = _a.left,\n          top = _a.top,\n          beforeOrigin = _a.beforeOrigin;\n      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));\n      childDatas.prevClient = childClient;\n      eventParams.dragStart = Draggable.dragStart(child, new CustomDragger().dragStart(childClient, inputEvent));\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n    datas.isRotate = result !== false;\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var direction = datas.beforeDirection;\n    var parentRotate = params.beforeDist;\n    var deg = params.beforeDelta;\n    var rad = deg / 180 * Math.PI;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, __assign({}, e, {\n      parentRotate: parentRotate\n    }), function (child, childDatas, result, i) {\n      var _a = childDatas.prevClient,\n          prevX = _a[0],\n          prevY = _a[1];\n\n      var _b = rotate([prevX, prevY], rad * direction),\n          clientX = _b[0],\n          clientY = _b[1];\n\n      var delta = [clientX - prevX, clientY - prevY];\n      childDatas.prevClient = [clientX, clientY];\n      var dragResult = Draggable.drag(child, setCustomDrag(child.state, delta, inputEvent, !!e.isPinch, false));\n      result.drag = dragResult;\n    });\n    moveable.rotation = direction * params.beforeRotate;\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events,\n      set: function (rotation) {\n        moveable.rotation = rotation;\n      }\n    }, params);\n\n    triggerEvent(moveable, \"onRotateGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Rotatable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.deltaRotate=0] -  delta number of rotation\n   * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n   *\n   * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"rotatable\");\n   *\n   * // request\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   *\n   * requester.request({ rotate: 10 });\n   * requester.request({ rotate: 20 });\n   * requester.request({ rotate: 30 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function (moveable) {\n    var datas = {};\n    var distRotate = 0;\n    var startRotation = moveable.getRotation();\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas\n        };\n      },\n      request: function (e) {\n        if (\"deltaRotate\" in e) {\n          distRotate += e.deltaRotate;\n        } else if (\"rotate\" in e) {\n          distRotate = e.rotate - startRotation;\n        }\n\n        return {\n          datas: datas,\n          parentDist: distRotate\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction renderControls(moveable, defaultDirections, React) {\n  var _a = moveable.state,\n      renderPoses = _a.renderPoses,\n      rotation = _a.rotation;\n  var _b = moveable.props.renderDirections,\n      directions = _b === void 0 ? defaultDirections : _b;\n  var direction = moveable.state.direction;\n  var directionMap = {};\n  directions.forEach(function (dir) {\n    directionMap[dir] = true;\n  });\n  return directions.map(function (dir) {\n    var indexes = DIRECTION_INDEXES[dir];\n\n    if (!indexes || !directionMap[dir]) {\n      return null;\n    }\n\n    var directionRotation = throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[dir];\n\n    if (direction < 1) {\n      directionRotation = 360 - directionRotation;\n    }\n\n    directionRotation %= 180;\n    return React.createElement(\"div\", {\n      className: prefix(\"control\", \"direction\", dir),\n      \"data-rotation\": directionRotation,\n      \"data-direction\": dir,\n      key: \"direction-\" + dir,\n      style: getControlTransform.apply(void 0, [rotation].concat(indexes.map(function (index) {\n        return renderPoses[index];\n      })))\n    });\n  });\n}\n\nfunction renderAllDirections(moveable, React) {\n  return renderControls(moveable, DIRECTIONS, React);\n}\n\nfunction renderDiagonalDirections(moveable, React) {\n  return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\n\nvar Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  updateRect: true,\n  canPinch: true,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    keepRatio: Boolean\n  },\n  events: {\n    onResizeStart: \"resizeStart\",\n    onResize: \"resize\",\n    onResizeEnd: \"resizeEnd\",\n    onResizeGroupStart: \"resizeGroupStart\",\n    onResizeGroup: \"resizeGroup\",\n    onResizeGroupEnd: \"resizeGroupEnd\"\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        edge = _a.edge;\n\n    if (resizable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function (moveable, e) {\n    var _a;\n\n    var inputEvent = e.inputEvent,\n        isPinch = e.isPinch,\n        parentDirection = e.parentDirection,\n        datas = e.datas,\n        parentFlag = e.parentFlag;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _b = moveable.state,\n        target = _b.target,\n        width = _b.width,\n        height = _b.height;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    !isPinch && setDragStart(moveable, {\n      datas: datas\n    });\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];\n    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n    datas.minSize = padding;\n    datas.maxSize = [Infinity, Infinity];\n\n    if (!parentFlag) {\n      var style = window.getComputedStyle(target);\n      datas.minSize = plus([parseFloat(style.minWidth) || 0, parseFloat(style.minHeight) || 0], padding);\n      datas.maxSize = plus([parseFloat(style.maxWidth) || Infinity, parseFloat(style.maxHeight) || Infinity], padding);\n    }\n\n    var transformOrigin = moveable.props.transformOrigin || \"% %\";\n    datas.transformOrigin = transformOrigin && isString(transformOrigin) ? transformOrigin.split(\" \") : transformOrigin;\n    datas.startDirection = getStartDirection(moveable, direction);\n    datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n    datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n    var params = fillParams(moveable, e, {\n      direction: direction,\n      set: function (_a) {\n        var startWidth = _a[0],\n            startHeight = _a[1];\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setMin: function (minSize) {\n        datas.minSize = minSize;\n      },\n      setMax: function (maxSize) {\n        datas.maxSize = maxSize;\n      },\n      setOrigin: function (origin) {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))\n    });\n    var result = triggerEvent(moveable, \"onResizeStart\", params);\n\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction: direction\n      };\n    }\n\n    return datas.isResize ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var _a;\n\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        parentDistance = e.parentDistance,\n        parentScale = e.parentScale,\n        inputEvent = e.inputEvent,\n        parentKeepRatio = e.parentKeepRatio,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist,\n        isRequest = e.isRequest;\n    var direction = datas.direction,\n        isResize = datas.isResize,\n        transformOrigin = datas.transformOrigin;\n\n    if (!isResize) {\n      return;\n    }\n\n    var startWidth = datas.startWidth,\n        startHeight = datas.startHeight,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight,\n        minSize = datas.minSize,\n        maxSize = datas.maxSize;\n    var _b = moveable.props,\n        _c = _b.throttleResize,\n        throttleResize = _c === void 0 ? 0 : _c,\n        parentMoveable = _b.parentMoveable;\n    var sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n\n    var keepRatio = moveable.props.keepRatio || parentKeepRatio;\n    var isWidth = sizeDirection[0] || !sizeDirection[1];\n    var ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n    var startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n    var fixedPosition = dragClient;\n    var distWidth = 0;\n    var distHeight = 0;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition;\n      }\n    }\n\n    if (parentDist) {\n      distWidth = parentDist[0];\n      distHeight = parentDist[1];\n    } else if (parentScale) {\n      distWidth = (parentScale[0] - 1) * startOffsetWidth;\n      distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (isPinch) {\n      if (parentDistance) {\n        distWidth = parentDistance;\n        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n      }\n    } else {\n      var dist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      distWidth = sizeDirection[0] * dist[0];\n      distHeight = sizeDirection[1] * dist[1];\n\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        var rad = getRad([0, 0], dist);\n        var standardRad = getRad([0, 0], sizeDirection);\n        var ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n        var size = getDistSize([distWidth, distHeight]);\n        var signSize = Math.cos(rad - standardRad) * size;\n\n        if (!sizeDirection[0]) {\n          // top, bottom\n          distHeight = signSize;\n          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n        } else if (!sizeDirection[1]) {\n          // left, right\n          distWidth = signSize;\n          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n        } else {\n          // two-way\n          distWidth = Math.cos(ratioRad) * signSize;\n          distHeight = Math.sin(ratioRad) * signSize;\n        }\n      }\n    }\n\n    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n      // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n      nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n    }\n\n    var snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas.fixedOriginalPosition, isRequest, datas);\n    }\n\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          nextWidth = throttle(nextWidth, throttleResize);\n        } else {\n          nextHeight = throttle(nextHeight, throttleResize);\n        }\n      }\n\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        nextWidth += snapDist[0];\n        nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        nextHeight += snapDist[1];\n        nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n      }\n    } else {\n      nextWidth += snapDist[0];\n      nextHeight += snapDist[1];\n\n      if (!snapDist[0]) {\n        nextWidth = throttle(nextWidth, throttleResize);\n      }\n\n      if (!snapDist[1]) {\n        nextHeight = throttle(nextHeight, throttleResize);\n      }\n    }\n\n    _a = caculateBoundSize([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a[0], nextHeight = _a[1];\n    nextWidth = Math.round(nextWidth);\n    nextHeight = Math.round(nextHeight);\n    distWidth = nextWidth - startOffsetWidth;\n    distHeight = nextHeight - startOffsetHeight;\n    var delta = [distWidth - prevWidth, distHeight - prevHeight];\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, startDirection, fixedPosition, transformOrigin);\n\n    if (!parentMoveable && delta.every(function (num) {\n      return !num;\n    }) && inverseDelta.every(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      width: startWidth + distWidth,\n      height: startHeight + distHeight,\n      offsetWidth: nextWidth,\n      offsetHeight: nextHeight,\n      direction: direction,\n      dist: [distWidth, distHeight],\n      delta: delta,\n      isPinch: !!isPinch,\n      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onResize\", params);\n    return params;\n  },\n  dragControlAfter: function (moveable, e) {\n    var datas = e.datas;\n    var isResize = datas.isResize,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight;\n\n    if (!isResize) {\n      return;\n    }\n\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height;\n    var errorWidth = width - (startOffsetWidth + prevWidth);\n    var errorHeight = height - (startOffsetHeight + prevHeight);\n    var isErrorWidth = Math.abs(errorWidth) > 3;\n    var isErrorHeight = Math.abs(errorHeight) > 3;\n\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n\n    if (isErrorWidth || isErrorHeight) {\n      this.dragControl(moveable, e);\n      return true;\n    }\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isResize) {\n      return false;\n    }\n\n    datas.isResize = false;\n    var params = fillEndParams(moveable, e, {});\n    triggerEvent(moveable, \"onResizeEnd\", params);\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var direction = params.direction;\n    var fixedPosition = datas.fixedOriginalPosition;\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, function (child, childDatas) {\n      var pos = getAbsoluteFixedPosition(child, direction);\n\n      var _a = caculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      childDatas.originalX = originalX;\n      childDatas.originalY = originalY;\n      return e;\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var offsetWidth = params.offsetWidth,\n        offsetHeight = params.offsetHeight,\n        dist = params.dist;\n    var keepRatio = moveable.props.keepRatio;\n    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];\n    var fixedPosition = datas.fixedOriginalPosition;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, function (_, childDatas) {\n      var _a = caculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * parentScale[0], childDatas.originalY * parentScale[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return __assign({}, e, {\n        parentDist: null,\n        parentScale: parentScale,\n        dragClient: plus(fixedPosition, [clientX, clientY]),\n        parentKeepRatio: keepRatio\n      });\n    });\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onResizeGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Resizable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to resize\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @param {number} [e.offsetWidth] - offset number of width\n   * @param {number} [e.offsetHeight] - offset number of height\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"resizable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n   * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function (moveable) {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    var rect = moveable.getRect();\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function (e) {\n        if (\"offsetWidth\" in e) {\n          distWidth = e.offsetWidth - rect.offsetWidth;\n        } else if (\"deltaWidth\" in e) {\n          distWidth += e.deltaWidth;\n        }\n\n        if (\"offsetHeight\" in e) {\n          distHeight = e.offsetHeight - rect.offsetHeight;\n        } else if (\"deltaHeight\" in e) {\n          distHeight += e.deltaHeight;\n        }\n\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable.Resizable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize.\n * @name Moveable.Resizable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 0,\n * });\n *\n * moveable.throttleResize = 1;\n */\n\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Resizable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Resizable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group resize starts, the `resizeGroupStart` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroupStart\n* @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroupStart\", ({ targets }) => {\n*     console.log(\"onResizeGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group resize, the `resizeGroup` event is called.\n* @memberof Moveable.Resizable\n* @event resizeGroup\n* @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     resizable: true\n* });\n* moveable.on(\"resizeGroup\", ({ targets, events }) => {\n*     console.log(\"onResizeGroup\", targets);\n*     events.forEach(ev => {\n*         const offset = [\n*             direction[0] < 0 ? -ev.delta[0] : 0,\n*             direction[1] < 0 ? -ev.delta[1] : 0,\n*         ];\n*         // ev.drag is a drag event that occurs when the group resize.\n*         const left = offset[0] + ev.drag.beforeDist[0];\n*         const top = offset[1] + ev.drag.beforeDist[1];\n*         const width = ev.width;\n*         const top = ev.top;\n*     });\n* });\n*/\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\n\nvar Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean\n  },\n  events: {\n    onScaleStart: \"scaleStart\",\n    onScale: \"scale\",\n    onScaleEnd: \"scaleEnd\",\n    onScaleGroupStart: \"scaleGroupStart\",\n    onScaleGroup: \"scaleGroup\",\n    onScaleGroupEnd: \"scaleGroupEnd\"\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        edge = _a.edge;\n\n    if (!resizable && scalable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        parentDirection = e.parentDirection;\n    var direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height,\n        targetTransform = _a.targetTransform,\n        target = _a.target;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    if (!isPinch) {\n      setDragStart(moveable, {\n        datas: datas\n      });\n    }\n\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.width = width;\n    datas.height = height;\n    datas.startScale = [1, 1];\n    datas.fixedDirection = direction.map(function (dir) {\n      return -dir;\n    });\n    datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n    var params = fillParams(moveable, e, {\n      direction: direction,\n      set: function (scale) {\n        datas.startScale = scale;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))\n    });\n    var result = triggerEvent(moveable, \"onScaleStart\", params);\n\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        request: e.isRequest,\n        direction: direction\n      };\n    }\n\n    return datas.isScale ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentScale = e.parentScale,\n        parentDistance = e.parentDistance,\n        parentKeepRatio = e.parentKeepRatio,\n        parentFlag = e.parentFlag,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist,\n        isRequest = e.isRequest;\n    var prevDist = datas.prevDist,\n        direction = datas.direction,\n        width = datas.width,\n        height = datas.height,\n        transform = datas.transform,\n        isScale = datas.isScale,\n        startScale = datas.startScale;\n\n    if (!isScale) {\n      return false;\n    }\n\n    var _a = moveable.props,\n        throttleScale = _a.throttleScale,\n        parentMoveable = _a.parentMoveable;\n    var sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n\n    var keepRatio = moveable.props.keepRatio || parentKeepRatio;\n    var state = moveable.state;\n    var isWidth = sizeDirection[0] || !sizeDirection[1];\n    var startWidth = width * startScale[0];\n    var startHeight = height * startScale[1];\n    var ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n    var scaleX = 1;\n    var scaleY = 1;\n    var fixedPosition = dragClient;\n\n    if (!dragClient) {\n      if (!parentFlag && isPinch) {\n        fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n      } else {\n        fixedPosition = datas.fixedPosition;\n      }\n    }\n\n    if (parentDist) {\n      scaleX = (width + parentDist[0]) / width;\n      scaleY = (height + parentDist[1]) / height;\n    } else if (parentScale) {\n      scaleX = parentScale[0];\n      scaleY = parentScale[1];\n    } else if (isPinch) {\n      if (parentDistance) {\n        scaleX = (width + parentDistance) / width;\n        scaleY = (height + parentDistance * height / width) / height;\n      }\n    } else {\n      var dist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      var distWidth = sizeDirection[0] * dist[0];\n      var distHeight = sizeDirection[1] * dist[1];\n\n      if (keepRatio && width && height) {\n        var rad = getRad([0, 0], dist);\n        var standardRad = getRad([0, 0], sizeDirection);\n        var ratioRad = getRad([0, 0], [startWidth, startHeight]);\n        var size = getDistSize([distWidth, distHeight]);\n        var signSize = Math.cos(rad - standardRad) * size;\n\n        if (!sizeDirection[0]) {\n          // top, bottom\n          distHeight = signSize;\n          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n        } else if (!sizeDirection[1]) {\n          // left, right\n          distWidth = signSize;\n          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n        } else {\n          // two-way\n          distWidth = Math.cos(ratioRad) * signSize;\n          distHeight = Math.sin(ratioRad) * signSize;\n        }\n      }\n\n      scaleX = (width + distWidth) / width;\n      scaleY = (height + distHeight) / height;\n    }\n\n    scaleX = sizeDirection[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n    scaleY = sizeDirection[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n    if (scaleX === 0) {\n      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (scaleY === 0) {\n      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n    var scale = [scaleX, scaleY];\n\n    if (!isPinch && moveable.props.groupable) {\n      var snapRenderInfo = state.snapRenderInfo || {};\n      var stateDirection = snapRenderInfo.direction;\n\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = {\n          direction: direction,\n          request: e.isRequest\n        };\n      }\n    }\n\n    var snapDist = [0, 0];\n\n    if (!isPinch) {\n      snapDist = checkSnapScale(moveable, nowDist, direction, datas.fixedPosition, isRequest, datas);\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];\n        } else {\n          nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];\n        }\n      }\n\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        nowDist[0] += snapDist[0];\n        var snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n        nowDist[1] = snapHeight / height / startScale[1];\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        nowDist[1] += snapDist[1];\n        var snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n        nowDist[0] = snapWidth / width / startScale[0];\n      }\n    } else {\n      nowDist[0] += snapDist[0];\n      nowDist[1] += snapDist[1];\n\n      if (!snapDist[0]) {\n        nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];\n      }\n\n      if (!snapDist[1]) {\n        nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];\n      }\n    }\n\n    if (nowDist[0] === 0) {\n      nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (nowDist[1] === 0) {\n      nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n    scale = multiply2(nowDist, startScale);\n    datas.prevDist = nowDist;\n    var inverseDelta = getScaleDist(moveable, delta, direction, fixedPosition);\n\n    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function (num) {\n      return !num;\n    }) && !parentMoveable) {\n      return false;\n    }\n\n    var params = fillParams(moveable, e, {\n      offsetWidth: width,\n      offsetHeight: height,\n      scale: scale,\n      direction: direction,\n      dist: nowDist,\n      delta: delta,\n      transform: transform + \" scale(\" + scaleX + \", \" + scaleY + \")\",\n      isPinch: !!isPinch,\n      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent, isPinch, false))\n    });\n    triggerEvent(moveable, \"onScale\", params);\n    return params;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isScale) {\n      return false;\n    }\n\n    datas.isScale = false;\n    triggerEvent(moveable, \"onScaleEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var direction = params.direction;\n    var fixedPosition = datas.fixedPosition;\n    datas.moveableScale = moveable.scale;\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, function (child, childDatas) {\n      var pos = getAbsoluteFixedPosition(child, direction);\n\n      var _a = caculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      childDatas.originalX = originalX;\n      childDatas.originalY = originalY;\n      return e;\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var moveableScale = datas.moveableScale;\n    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];\n    var keepRatio = moveable.props.keepRatio;\n    var dist = params.dist,\n        scale = params.scale; // const fixedDirection = datas.fixedDirection;\n\n    var fixedPosition = datas.fixedPosition;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, function (_, childDatas) {\n      var _a = caculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * dist[0], childDatas.originalY * dist[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return __assign({}, e, {\n        parentDist: null,\n        parentScale: scale,\n        parentKeepRatio: keepRatio,\n        dragClient: plus(fixedPosition, [clientX, clientY])\n      });\n    });\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onScaleGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillEndParams(moveable, e, {\n      targets: moveable.props.targets\n    });\n    triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Scalable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to scale\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n   *\n   * // requestStart\n   * const requester = moveable.request(\"scalable\");\n   *\n   * // request\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function () {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function (e) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable.Scalable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n\nfunction getMiddleLinePos(pos1, pos2) {\n  return pos1.map(function (pos, i) {\n    return dot(pos, pos2[i], 1, 2);\n  });\n}\n\nfunction getTriangleRad(pos1, pos2, pos3) {\n  // pos1 Rad\n  var rad1 = getRad(pos1, pos2);\n  var rad2 = getRad(pos1, pos3);\n  var rad = rad2 - rad1;\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1, poses2) {\n  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  var pi = Math.PI;\n\n  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\n\n\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array\n  },\n  events: {\n    onWarpStart: \"warpStart\",\n    onWarp: \"warp\",\n    onWarpEnd: \"warpEnd\"\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        warpable = _a.warpable;\n\n    if (resizable || scalable || !warpable) {\n      return [];\n    }\n\n    var _b = moveable.state,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4;\n    var linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    var linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    var linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    var linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    var linePosTo1 = getMiddleLinePos(pos3, pos4);\n    var linePosTo2 = getMiddleLinePos(pos4, pos3);\n    var linePosTo3 = getMiddleLinePos(pos2, pos4);\n    var linePosTo4 = getMiddleLinePos(pos4, pos2);\n    return [React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(linePosFrom1, linePosTo1)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(linePosFrom2, linePosTo2)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(linePosFrom3, linePosTo3)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(linePosFrom4, linePosTo4)\n    })].concat(renderAllDirections(moveable, React));\n  },\n  dragControlCondition: function (e) {\n    if (e.isRequest) {\n      return false;\n    }\n\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n  },\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent;\n    var target = moveable.props.target;\n    var inputTarget = inputEvent.target;\n    var direction = getDirection(inputTarget);\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    var state = moveable.state;\n    var transformOrigin = state.transformOrigin,\n        is3d = state.is3d,\n        targetTransform = state.targetTransform,\n        targetMatrix = state.targetMatrix,\n        width = state.width,\n        height = state.height,\n        left = state.left,\n        top = state.top;\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n    datas.direction = direction;\n    datas.left = left;\n    datas.top = top;\n    setDragStart(moveable, {\n      datas: datas\n    });\n    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p) {\n      return minus(p, transformOrigin);\n    });\n    datas.nextPoses = datas.poses.map(function (_a) {\n      var x = _a[0],\n          y = _a[1];\n      return caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);\n    });\n    datas.startMatrix = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n    state.snapRenderInfo = {\n      request: e.isRequest,\n      direction: direction\n    };\n    var params = fillParams(moveable, e, {\n      set: function (matrix) {\n        datas.startMatrix = matrix;\n      }\n    });\n    var result = triggerEvent(moveable, \"onWarpStart\", params);\n\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n\n    return datas.isWarp;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        isRequest = e.isRequest;\n    var distX = e.distX,\n        distY = e.distY;\n    var targetInverseMatrix = datas.targetInverseMatrix,\n        prevMatrix = datas.prevMatrix,\n        isWarp = datas.isWarp,\n        startMatrix = datas.startMatrix,\n        poses = datas.poses,\n        posIndexes = datas.posIndexes,\n        absolutePoses = datas.absolutePoses;\n\n    if (!isWarp) {\n      return false;\n    }\n\n    if (hasGuidelines(moveable, \"warpable\")) {\n      var selectedPoses = posIndexes.map(function (index) {\n        return absolutePoses[index];\n      });\n\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);\n      }\n\n      var _a = checkSnapBounds(moveable, isRequest, selectedPoses.map(function (pos) {\n        return [pos[0] + distX, pos[1] + distY];\n      })),\n          horizontalSnapInfo = _a.horizontal,\n          verticalSnapInfo = _a.vertical;\n\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n\n    var dist = getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, true);\n    var nextPoses = datas.nextPoses.slice();\n    posIndexes.forEach(function (index) {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n\n    if (!NEARBY_POS.every(function (nearByPoses) {\n      return isValidPos(nearByPoses.map(function (i) {\n        return poses[i];\n      }), nearByPoses.map(function (i) {\n        return nextPoses[i];\n      }));\n    })) {\n      return false;\n    }\n\n    var h = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);\n\n    if (!h.length) {\n      return false;\n    }\n\n    var matrix = multiply(targetInverseMatrix, h, 4);\n    var transform = datas.targetTransform + \" \" + makeMatrixCSS(matrix, true);\n    var delta = multiply(invert(prevMatrix, 4), matrix, 4);\n    datas.prevMatrix = matrix;\n    triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, {\n      delta: delta,\n      matrix: multiply(startMatrix, matrix, 4),\n      multiply: multiply,\n      dist: matrix,\n      transform: transform\n    }));\n    return true;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isWarp) {\n      return false;\n    }\n\n    datas.isWarp = false;\n    triggerEvent(moveable, \"onWarpEnd\", fillEndParams(moveable, e, {}));\n    return isDrag;\n  }\n};\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n/**\n* Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n* @name Moveable.Warpable#renderDirections\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     warpable: true,\n*     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n* });\n*\n* moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n*/\n\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\nvar AREA = prefix(\"area\");\nvar AREA_PIECES = prefix(\"area-pieces\");\nvar AREA_PIECE = prefix(\"area-piece\");\nvar AVOID = prefix(\"avoid\");\n\nfunction restoreStyle(moveable) {\n  var el = moveable.areaElement;\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  removeClass(el, AVOID);\n  el.style.cssText += \"left: 0px; top: 0px; width: \" + width + \"px; height: \" + height + \"px\";\n}\n\nfunction renderPieces(React) {\n  return React.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\n\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean\n  },\n  events: {\n    onClick: \"click\",\n    onClickGroup: \"clickGroup\"\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        target = _a.target,\n        dragArea = _a.dragArea,\n        groupable = _a.groupable;\n    var _b = moveable.state,\n        width = _b.width,\n        height = _b.height,\n        renderPoses = _b.renderPoses;\n\n    if (groupable) {\n      return [React.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(moveable, \"areaElement\"),\n        className: AREA\n      }), renderPieces(React)];\n    }\n\n    if (!target || !dragArea) {\n      return [];\n    }\n\n    var h = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);\n    var transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n    return [React.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(moveable, \"areaElement\"),\n      className: AREA,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: width + \"px\",\n        height: height + \"px\",\n        transformOrigin: \"0 0\",\n        transform: transform\n      }\n    }), renderPieces(React)];\n  },\n  dragStart: function (moveable, _a) {\n    var datas = _a.datas,\n        clientX = _a.clientX,\n        clientY = _a.clientY,\n        inputEvent = _a.inputEvent;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    datas.isDragArea = false;\n    datas.inputTarget = inputEvent.target;\n    var areaElement = moveable.areaElement;\n    var _b = moveable.state,\n        moveableClientRect = _b.moveableClientRect,\n        renderPoses = _b.renderPoses,\n        rootMatrix = _b.rootMatrix,\n        is3d = _b.is3d;\n    var left = moveableClientRect.left,\n        top = moveableClientRect.top;\n\n    var _c = getRect(renderPoses),\n        relativeLeft = _c.left,\n        relativeTop = _c.top,\n        width = _c.width,\n        height = _c.height;\n\n    var n = is3d ? 4 : 3;\n\n    var _d = caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n),\n        posX = _d[0],\n        posY = _d[1];\n\n    posX -= relativeLeft;\n    posY -= relativeTop;\n    var rects = [{\n      left: relativeLeft,\n      top: relativeTop,\n      width: width,\n      height: posY - 10\n    }, {\n      left: relativeLeft,\n      top: relativeTop,\n      width: posX - 10,\n      height: height\n    }, {\n      left: relativeLeft,\n      top: relativeTop + posY + 10,\n      width: width,\n      height: height - posY - 10\n    }, {\n      left: relativeLeft + posX + 10,\n      top: relativeTop,\n      width: width - posX - 10,\n      height: height\n    }];\n    var children = [].slice.call(areaElement.nextElementSibling.children);\n    rects.forEach(function (rect, i) {\n      children[i].style.cssText = \"left: \" + rect.left + \"px;top: \" + rect.top + \"px; width: \" + rect.width + \"px; height: \" + rect.height + \"px;\";\n    });\n    addClass(areaElement, AVOID);\n    return true;\n  },\n  drag: function (moveable, _a) {\n    var datas = _a.datas,\n        inputEvent = _a.inputEvent;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd: function (moveable, e) {\n    if (!e.inputEvent) {\n      return false;\n    }\n\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n    var isDragArea = datas.isDragArea;\n\n    if (!isDragArea) {\n      restoreStyle(moveable);\n    }\n\n    var target = moveable.state.target;\n    var inputTarget = inputEvent.target;\n\n    if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n      return;\n    }\n\n    var containsTarget = target.contains(inputTarget);\n    triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      inputTarget: inputTarget,\n      isTarget: target === inputTarget,\n      containsTarget: containsTarget\n    }));\n  },\n  dragGroupStart: function (moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup: function (moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        isDragArea = e.isDragArea,\n        datas = e.datas;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!isDragArea) {\n      restoreStyle(moveable);\n    }\n\n    var prevInputTarget = datas.inputTarget;\n    var inputTarget = inputEvent.target;\n\n    if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n      return;\n    }\n\n    var targets = moveable.props.targets;\n    var targetIndex = targets.indexOf(inputTarget);\n    var isTarget = targetIndex > -1;\n    var containsTarget = false;\n\n    if (targetIndex === -1) {\n      targetIndex = findIndex(targets, function (parentTarget) {\n        return parentTarget.contains(inputTarget);\n      });\n      containsTarget = targetIndex > -1;\n    }\n\n    triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n      isDouble: e.isDouble,\n      targets: targets,\n      inputTarget: inputTarget,\n      targetIndex: targetIndex,\n      isTarget: isTarget,\n      containsTarget: containsTarget\n    }));\n  }\n};\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n\nvar Origin = {\n  name: \"origin\",\n  props: {\n    origin: Boolean\n  },\n  events: {},\n  render: function (moveable, React) {\n    var _a = moveable.state,\n        beforeOrigin = _a.beforeOrigin,\n        rotation = _a.rotation;\n    return [React.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(rotation, beforeOrigin),\n      key: \"beforeOrigin\"\n    })];\n  }\n};\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n\nfunction getDefaultScrollPosition(e) {\n  var scrollContainer = e.scrollContainer;\n  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\n\n\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: true,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number,\n    getScrollPosition: Function\n  },\n  events: {\n    onScroll: \"scroll\",\n    onScrollGroup: \"scrollGroup\"\n  },\n  dragStart: function (moveable, e) {\n    var props = moveable.props;\n    var _a = props.scrollContainer,\n        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;\n    var dragScroll = new DragScroll();\n    e.datas.dragScroll = dragScroll;\n    var draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n    var targets = e.targets;\n    dragScroll.on(\"scroll\", function (_a) {\n      var container = _a.container,\n          direction = _a.direction;\n      var params = fillParams(moveable, e, {\n        scrollContainer: container,\n        direction: direction\n      });\n      var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\n\n      if (targets) {\n        params.targets = targets;\n      }\n\n      triggerEvent(moveable, eventName, params);\n    }).on(\"move\", function (_a) {\n      var offsetX = _a.offsetX,\n          offsetY = _a.offsetY;\n      moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n    });\n    dragScroll.dragStart(e, {\n      container: scrollContainer\n    });\n  },\n  checkScroll: function (moveable, e) {\n    var dragScroll = e.datas.dragScroll;\n\n    if (!dragScroll) {\n      return;\n    }\n\n    var _a = moveable.props,\n        _b = _a.scrollContainer,\n        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,\n        _c = _a.scrollThreshold,\n        scrollThreshold = _c === void 0 ? 0 : _c,\n        _d = _a.getScrollPosition,\n        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;\n    dragScroll.drag(e, {\n      container: scrollContainer,\n      threshold: scrollThreshold,\n      getScrollPosition: function (ev) {\n        return getScrollPosition({\n          scrollContainer: ev.container,\n          direction: ev.direction\n        });\n      }\n    });\n    return true;\n  },\n  drag: function (moveable, e) {\n    return this.checkScroll(moveable, e);\n  },\n  dragEnd: function (moveable, e) {\n    e.datas.dragScroll.dragEnd();\n    e.datas.dragScroll = null;\n  },\n  dragControlStart: function (moveable, e) {\n    return this.dragStart(moveable, __assign({}, e, {\n      isControl: true\n    }));\n  },\n  dragControl: function (moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function (moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupStart: function (moveable, e) {\n    return this.dragStart(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroup: function (moveable, e) {\n    return this.drag(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupEnd: function (moveable, e) {\n    return this.dragEnd(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControlStart: function (moveable, e) {\n    return this.dragStart(moveable, __assign({}, e, {\n      targets: moveable.props.targets,\n      isControl: true\n    }));\n  },\n  dragGroupContro: function (moveable, e) {\n    return this.drag(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControEnd: function (moveable, e) {\n    return this.dragEnd(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  }\n};\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\nvar Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    dragTarget: Object,\n    container: Object,\n    rootContainer: Object,\n    zoom: Number,\n    transformOrigin: Array,\n    edge: Boolean,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number,\n    pinchOutside: Boolean,\n    triggerAblesSimultaneously: Boolean,\n    checkInput: Boolean,\n    cspNonce: String\n  },\n  events: {\n    onRenderStart: \"renderStart\",\n    onRender: \"render\",\n    onRenderEnd: \"renderEnd\",\n    onRenderGroupStart: \"renderGroupStart\",\n    onRenderGroup: \"renderGroup\",\n    onRenderGroupEnd: \"renderGroupEnd\"\n  }\n};\nvar Padding = {\n  name: \"padding\",\n  props: {\n    padding: Object\n  },\n  events: {},\n  render: function (moveable, React) {\n    var props = moveable.props;\n\n    if (props.dragArea) {\n      return [];\n    }\n\n    var padding = props.padding || {};\n    var _a = padding.left,\n        left = _a === void 0 ? 0 : _a,\n        _b = padding.top,\n        top = _b === void 0 ? 0 : _b,\n        _c = padding.right,\n        right = _c === void 0 ? 0 : _c,\n        _d = padding.bottom,\n        bottom = _d === void 0 ? 0 : _d;\n    var _e = moveable.state,\n        renderPoses = _e.renderPoses,\n        pos1 = _e.pos1,\n        pos2 = _e.pos2,\n        pos3 = _e.pos3,\n        pos4 = _e.pos4;\n    var poses = [pos1, pos2, pos3, pos4];\n    var paddingDirections = [];\n\n    if (left > 0) {\n      paddingDirections.push([0, 2]);\n    }\n\n    if (top > 0) {\n      paddingDirections.push([0, 1]);\n    }\n\n    if (right > 0) {\n      paddingDirections.push([1, 3]);\n    }\n\n    if (bottom > 0) {\n      paddingDirections.push([2, 3]);\n    }\n\n    return paddingDirections.map(function (_a, i) {\n      var dir1 = _a[0],\n          dir2 = _a[1];\n      var paddingPos1 = poses[dir1];\n      var paddingPos2 = poses[dir2];\n      var paddingPos3 = renderPoses[dir1];\n      var paddingPos4 = renderPoses[dir2];\n      var h = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);\n\n      if (!h.length) {\n        return undefined;\n      }\n\n      return React.createElement(\"div\", {\n        key: \"padding\" + i,\n        className: prefix(\"padding\"),\n        style: {\n          transform: makeMatrixCSS(h, true)\n        }\n      });\n    });\n  }\n};\n/**\n * Add padding around the target to increase the drag area. (default: null)\n * @name Moveable#padding\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n\nvar RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"];\n\nfunction caculateRatio(values, size) {\n  var sumSize = values[0] + values[1];\n  var sumRatio = sumSize > size ? size / sumSize : 1;\n  values[0] *= sumRatio;\n  values[1] = size - values[1] * sumRatio;\n  return values;\n}\n\nvar HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nvar VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nvar HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];\nvar VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];\n\nfunction getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {\n  if (left === void 0) {\n    left = 0;\n  }\n\n  if (top === void 0) {\n    top = 0;\n  }\n\n  if (right === void 0) {\n    right = width;\n  }\n\n  if (bottom === void 0) {\n    bottom = height;\n  }\n\n  var clipStyles = [];\n  var isVertical = false;\n  var raws = poses.map(function (pos, i) {\n    var _a = controlPoses[i],\n        horizontal = _a.horizontal,\n        vertical = _a.vertical;\n\n    if (vertical && !isVertical) {\n      isVertical = true;\n      clipStyles.push(\"/\");\n    }\n\n    if (isVertical) {\n      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n      clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n      return rawPos;\n    } else {\n      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n      clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n      return rawPos;\n    }\n  });\n  return {\n    styles: clipStyles,\n    raws: raws\n  };\n}\n\nfunction getRadiusRange(controlPoses) {\n  // [start, length]\n  var horizontalRange = [0, 0];\n  var verticalRange = [0, 0];\n  var length = controlPoses.length;\n\n  for (var i = 0; i < length; ++i) {\n    var clipPose = controlPoses[i];\n\n    if (!clipPose.sub) {\n      continue;\n    }\n\n    if (clipPose.horizontal) {\n      if (horizontalRange[1] === 0) {\n        horizontalRange[0] = i;\n      }\n\n      horizontalRange[1] = i - horizontalRange[0] + 1;\n      verticalRange[0] = i + 1;\n    }\n\n    if (clipPose.vertical) {\n      if (verticalRange[1] === 0) {\n        verticalRange[0] = i;\n      }\n\n      verticalRange[1] = i - verticalRange[0] + 1;\n    }\n  }\n\n  return {\n    horizontalRange: horizontalRange,\n    verticalRange: verticalRange\n  };\n}\n\nfunction getRadiusValues(values, width, height, left, top) {\n  var _a, _b, _c, _d;\n\n  var splitIndex = values.indexOf(\"/\");\n  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n  var horizontalValues = values.slice(0, splitLength);\n  var verticalValues = values.slice(splitLength + 1);\n  var _e = horizontalValues[0],\n      nwValue = _e === void 0 ? \"0\" : _e,\n      _f = horizontalValues[1],\n      neValue = _f === void 0 ? nwValue : _f,\n      _g = horizontalValues[2],\n      seValue = _g === void 0 ? nwValue : _g,\n      _h = horizontalValues[3],\n      swValue = _h === void 0 ? neValue : _h;\n  var _j = verticalValues[0],\n      wnValue = _j === void 0 ? nwValue : _j,\n      _k = verticalValues[1],\n      enValue = _k === void 0 ? wnValue : _k,\n      _l = verticalValues[2],\n      esValue = _l === void 0 ? wnValue : _l,\n      _m = verticalValues[3],\n      wsValue = _m === void 0 ? enValue : _m;\n  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function (pos) {\n    return getUnitSize(pos, width);\n  });\n  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function (pos) {\n    return getUnitSize(pos, height);\n  });\n  var horizontalPoses = horizontalRawPoses.slice();\n  var verticalPoses = verticalRawPoses.slice();\n  _a = caculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a[0], horizontalPoses[1] = _a[1];\n  _b = caculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];\n  _c = caculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];\n  _d = caculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];\n  var nextHorizontalPoses = horizontalPoses.slice(0, horizontalValues.length);\n  var nextVerticalPoses = verticalPoses.slice(0, verticalValues.length);\n  return nextHorizontalPoses.map(function (pos, i) {\n    var direction = RADIUS_DIRECTIONS[i];\n    return {\n      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n      vertical: 0,\n      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n      sub: true,\n      raw: horizontalRawPoses[i],\n      direction: direction\n    };\n  }).concat(nextVerticalPoses.map(function (pos, i) {\n    var direction = RADIUS_DIRECTIONS[i];\n    return {\n      horizontal: 0,\n      vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n      sub: true,\n      raw: verticalRawPoses[i],\n      direction: direction\n    };\n  }));\n}\n\nfunction removeRadiusPos(controlPoses, poses, index, startIndex, length) {\n  if (length === void 0) {\n    length = poses.length;\n  }\n\n  var _a = getRadiusRange(controlPoses.slice(startIndex)),\n      horizontalRange = _a.horizontalRange,\n      verticalRange = _a.verticalRange;\n\n  var radiuslIndex = index - startIndex;\n  var deleteCount = 0;\n\n  if (radiuslIndex === 0) {\n    deleteCount = length;\n  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n    deleteCount = horizontalRange[1] - radiuslIndex;\n  } else if (radiuslIndex >= verticalRange[0]) {\n    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n  } else {\n    return;\n  }\n\n  controlPoses.splice(index, deleteCount);\n  poses.splice(index, deleteCount);\n}\n\nfunction addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {\n  if (left === void 0) {\n    left = 0;\n  }\n\n  if (top === void 0) {\n    top = 0;\n  }\n\n  var _a = getRadiusRange(controlPoses.slice(startIndex)),\n      horizontalRange = _a.horizontalRange,\n      verticalRange = _a.verticalRange;\n\n  if (horizontalIndex > -1) {\n    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;\n\n    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n      var x = 0;\n\n      if (horizontalIndex === i) {\n        x = distX;\n      } else if (i === 0) {\n        x = left + radiusX;\n      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n        x = right - (poses[startIndex][0] - left);\n      }\n\n      controlPoses.splice(startIndex + i, 0, {\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n        vertical: 0,\n        pos: [x, y]\n      });\n      poses.splice(startIndex + i, 0, [x, y]);\n\n      if (i === 0) {\n        break;\n      }\n    }\n  } else if (verticalIndex > -1) {\n    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;\n\n    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n      var pos = [left + radiusY, top];\n      controlPoses.push({\n        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n        vertical: 0,\n        pos: pos\n      });\n      poses.push(pos);\n    }\n\n    var startVerticalIndex = verticalRange[0];\n\n    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {\n      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n      var y = 0;\n\n      if (verticalIndex === i) {\n        y = distY;\n      } else if (i === 0) {\n        y = top + radiusY;\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n        y = poses[startIndex + startVerticalIndex][1];\n      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n      }\n\n      controlPoses.push({\n        horizontal: 0,\n        vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n        pos: [x, y]\n      });\n      poses.push([x, y]);\n\n      if (i === 0) {\n        break;\n      }\n    }\n  }\n}\n\nfunction splitRadiusPoses(controlPoses, raws) {\n  if (raws === void 0) {\n    raws = controlPoses.map(function (pos) {\n      return pos.raw;\n    });\n  }\n\n  var horizontals = controlPoses.map(function (pos, i) {\n    return pos.horizontal ? raws[i] : null;\n  }).filter(function (pos) {\n    return pos != null;\n  });\n  var verticals = controlPoses.map(function (pos, i) {\n    return pos.vertical ? raws[i] : null;\n  }).filter(function (pos) {\n    return pos != null;\n  });\n  return {\n    horizontals: horizontals,\n    verticals: verticals\n  };\n}\n\nvar CLIP_DIRECTIONS = [[0, -1, \"n\"], [1, 0, \"e\"]];\nvar CLIP_RECT_DIRECTIONS = [[-1, -1, \"nw\"], [0, -1, \"n\"], [1, -1, \"ne\"], [1, 0, \"e\"], [1, 1, \"se\"], [0, 1, \"s\"], [-1, 1, \"sw\"], [-1, 0, \"w\"]]; // 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(moveable, clipPath, poses) {\n  var clipRelative = moveable.props.clipRelative;\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  var _b = clipPath,\n      clipType = _b.type,\n      clipPoses = _b.poses;\n  var isRect = clipType === \"rect\";\n  var isCircle = clipType === \"circle\";\n\n  if (clipType === \"polygon\") {\n    return poses.map(function (pos) {\n      return convertCSSSize(pos[0], width, clipRelative) + \" \" + convertCSSSize(pos[1], height, clipRelative);\n    });\n  } else if (isRect || clipType === \"inset\") {\n    var top = poses[1][1];\n    var right = poses[3][0];\n    var left = poses[7][0];\n    var bottom = poses[5][1];\n\n    if (isRect) {\n      return [top, right, bottom, left].map(function (pos) {\n        return pos + \"px\";\n      });\n    }\n\n    var clipStyles = [top, width - right, height - bottom, left].map(function (pos, i) {\n      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);\n    });\n\n    if (poses.length > 8) {\n      var _c = minus(poses[4], poses[0]),\n          subWidth = _c[0],\n          subHeight = _c[1];\n\n      clipStyles.push.apply(clipStyles, [\"round\"].concat(getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));\n    }\n\n    return clipStyles;\n  } else if (isCircle || clipType === \"ellipse\") {\n    var center = poses[0];\n    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);\n    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n    clipStyles.push(\"at\", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));\n    return clipStyles;\n  }\n}\n\nfunction getRectPoses(top, right, bottom, left) {\n  var xs = [left, (left + right) / 2, right];\n  var ys = [top, (top + bottom) / 2, bottom];\n  return CLIP_RECT_DIRECTIONS.map(function (_a) {\n    var dirx = _a[0],\n        diry = _a[1],\n        dir = _a[2];\n    var x = xs[dirx + 1];\n    var y = ys[diry + 1];\n    return {\n      vertical: Math.abs(diry),\n      horizontal: Math.abs(dirx),\n      direction: dir,\n      pos: [x, y]\n    };\n  });\n}\n\nfunction getClipPath(target, width, height, defaultClip, customClip) {\n  var _a, _b, _c, _d, _e, _f, _g;\n\n  var clipText = customClip;\n\n  if (!clipText) {\n    var style = getComputedStyle(target);\n    var clipPath = style.clipPath;\n    clipText = clipPath !== \"none\" ? clipPath : style.clip;\n  }\n\n  if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n    clipText = defaultClip;\n\n    if (!clipText) {\n      return;\n    }\n  }\n\n  var _h = splitBracket(clipText),\n      _j = _h.prefix,\n      clipPrefix = _j === void 0 ? clipText : _j,\n      _k = _h.value,\n      value = _k === void 0 ? \"\" : _k;\n\n  var isCircle = clipPrefix === \"circle\";\n  var splitter = \" \";\n\n  if (clipPrefix === \"polygon\") {\n    var values = splitComma(value || \"0% 0%, 100% 0%, 100% 100%, 0% 100%\");\n    splitter = \",\";\n    var poses = values.map(function (pos) {\n      var _a = pos.split(\" \"),\n          xPos = _a[0],\n          yPos = _a[1];\n\n      return {\n        vertical: 1,\n        horizontal: 1,\n        pos: [getUnitSize(xPos, width), getUnitSize(yPos, height)]\n      };\n    });\n    return {\n      type: clipPrefix,\n      clipText: clipText,\n      poses: poses,\n      splitter: splitter\n    };\n  } else if (isCircle || clipPrefix === \"ellipse\") {\n    var xPos = \"\";\n    var yPos = \"\";\n    var radiusX_1 = 0;\n    var radiusY_1 = 0;\n    var values = splitSpace(value);\n\n    if (isCircle) {\n      var radius = \"\";\n      _a = values[0], radius = _a === void 0 ? \"50%\" : _a, _b = values[2], xPos = _b === void 0 ? \"50%\" : _b, _c = values[3], yPos = _c === void 0 ? \"50%\" : _c;\n      radiusX_1 = getUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n      radiusY_1 = radiusX_1;\n    } else {\n      var xRadius = \"\";\n      var yRadius = \"\";\n      _d = values[0], xRadius = _d === void 0 ? \"50%\" : _d, _e = values[1], yRadius = _e === void 0 ? \"50%\" : _e, _f = values[3], xPos = _f === void 0 ? \"50%\" : _f, _g = values[4], yPos = _g === void 0 ? \"50%\" : _g;\n      radiusX_1 = getUnitSize(xRadius, width);\n      radiusY_1 = getUnitSize(yRadius, height);\n    }\n\n    var centerPos_1 = [getUnitSize(xPos, width), getUnitSize(yPos, height)];\n    var poses = [{\n      vertical: 1,\n      horizontal: 1,\n      pos: centerPos_1,\n      direction: \"nesw\"\n    }].concat(CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function (dir) {\n      return {\n        vertical: Math.abs(dir[1]),\n        horizontal: dir[0],\n        direction: dir[2],\n        sub: true,\n        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]\n      };\n    }));\n    return {\n      type: clipPrefix,\n      clipText: clipText,\n      radiusX: radiusX_1,\n      radiusY: radiusY_1,\n      left: centerPos_1[0] - radiusX_1,\n      top: centerPos_1[1] - radiusY_1,\n      poses: poses,\n      splitter: splitter\n    };\n  } else if (clipPrefix === \"inset\") {\n    var values = splitSpace(value || \"0 0 0 0\");\n    var roundIndex = values.indexOf(\"round\");\n    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n    var radiusValues = values.slice(rectLength + 1);\n\n    var _l = values.slice(0, rectLength),\n        topValue = _l[0],\n        _m = _l[1],\n        rightValue = _m === void 0 ? topValue : _m,\n        _o = _l[2],\n        bottomValue = _o === void 0 ? topValue : _o,\n        _p = _l[3],\n        leftValue = _p === void 0 ? rightValue : _p;\n\n    var _q = [topValue, bottomValue].map(function (pos) {\n      return getUnitSize(pos, height);\n    }),\n        top = _q[0],\n        bottom = _q[1];\n\n    var _r = [leftValue, rightValue].map(function (pos) {\n      return getUnitSize(pos, width);\n    }),\n        left = _r[0],\n        right = _r[1];\n\n    var nextRight = width - right;\n    var nextBottom = height - bottom;\n    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);\n    var poses = getRectPoses(top, nextRight, nextBottom, left).concat(radiusPoses);\n    return {\n      type: \"inset\",\n      clipText: clipText,\n      poses: poses,\n      top: top,\n      left: left,\n      right: nextRight,\n      bottom: nextBottom,\n      radius: radiusValues,\n      splitter: splitter\n    };\n  } else if (clipPrefix === \"rect\") {\n    // top right bottom left\n    var values = splitComma(value || \"0px, \" + width + \"px, \" + height + \"px, 0px\");\n    splitter = \",\";\n\n    var _s = values.map(function (pos, i) {\n      var posValue = splitUnit(pos).value;\n      return posValue;\n    }),\n        top = _s[0],\n        right = _s[1],\n        bottom = _s[2],\n        left = _s[3];\n\n    var poses = getRectPoses(top, right, bottom, left);\n    return {\n      type: \"rect\",\n      clipText: clipText,\n      poses: poses,\n      top: top,\n      right: right,\n      bottom: bottom,\n      left: left,\n      values: values,\n      splitter: splitter\n    };\n  }\n\n  return;\n}\n\nfunction addClipPath(moveable, e) {\n  var _a = caculatePointerDist(moveable, e),\n      distX = _a[0],\n      distY = _a[1];\n\n  var _b = e.datas,\n      clipPath = _b.clipPath,\n      index = _b.index;\n  var _c = clipPath,\n      clipType = _c.type,\n      clipPoses = _c.poses,\n      splitter = _c.splitter;\n  var poses = clipPoses.map(function (pos) {\n    return pos.pos;\n  });\n\n  if (clipType === \"polygon\") {\n    poses.splice(index, 0, [distX, distY]);\n  } else if (clipType === \"inset\") {\n    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n    var length = clipPoses.length;\n    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"added\",\n    clipType: clipType,\n    poses: poses,\n    clipStyles: clipStyles,\n    clipStyle: clipType + \"(\" + clipStyles.join(splitter) + \")\",\n    distX: 0,\n    distY: 0\n  }));\n}\n\nfunction removeClipPath(moveable, e) {\n  var _a = e.datas,\n      clipPath = _a.clipPath,\n      index = _a.index;\n  var _b = clipPath,\n      clipType = _b.type,\n      clipPoses = _b.poses,\n      splitter = _b.splitter;\n  var poses = clipPoses.map(function (pos) {\n    return pos.pos;\n  });\n  var length = poses.length;\n\n  if (clipType === \"polygon\") {\n    clipPoses.splice(index, 1);\n    poses.splice(index, 1);\n  } else if (clipType === \"inset\") {\n    if (index < 8) {\n      return;\n    }\n\n    removeRadiusPos(clipPoses, poses, index, 8, length);\n\n    if (length === clipPoses.length) {\n      return;\n    }\n  } else {\n    return;\n  }\n\n  var clipStyles = getClipStyles(moveable, clipPath, poses);\n  triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n    clipEventType: \"removed\",\n    clipType: clipType,\n    poses: poses,\n    clipStyles: clipStyles,\n    clipStyle: clipType + \"(\" + clipStyles.join(splitter) + \")\",\n    distX: 0,\n    distY: 0\n  }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\n\nvar Clippable = {\n  name: \"clippable\",\n  props: {\n    clippable: Boolean,\n    defaultClipPath: String,\n    customClipPath: String,\n    clipRelative: Boolean,\n    clipArea: Boolean,\n    dragWithClip: Boolean\n  },\n  events: {\n    onClipStart: \"clipStart\",\n    onClip: \"clip\",\n    onClipEnd: \"clipEnd\"\n  },\n  css: [\".control.clip-control {\\n    background: #6d6;\\n    cursor: pointer;\\n}\\n.control.clip-control.clip-radius {\\n    background: #d66;\\n}\\n.line.clip-line {\\n    background: #6e6;\\n    cursor: move;\\n    z-index: 1;\\n}\\n.clip-area {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n}\\n.clip-ellipse {\\n    position: absolute;\\n    cursor: move;\\n    border: 1px solid #6d6;\\n    border: var(--zoompx) solid #6d6;\\n    border-radius: 50%;\\n    transform-origin: 0px 0px;\\n}\"],\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        customClipPath = _a.customClipPath,\n        defaultClipPath = _a.defaultClipPath,\n        clipArea = _a.clipArea,\n        zoom = _a.zoom;\n    var _b = moveable.state,\n        target = _b.target,\n        width = _b.width,\n        height = _b.height,\n        matrix = _b.matrix,\n        is3d = _b.is3d,\n        left = _b.left,\n        top = _b.top,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4,\n        clipPathState = _b.clipPathState;\n\n    if (!target) {\n      return [];\n    }\n\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n    if (!clipPath) {\n      return [];\n    }\n\n    var n = is3d ? 4 : 3;\n    var type = clipPath.type;\n    var clipPoses = clipPath.poses;\n    var poses = clipPoses.map(function (pos) {\n      // return [x, y];\n      var caculatedPos = caculatePosition(matrix, pos.pos, n);\n      return [caculatedPos[0] - left, caculatedPos[1] - top];\n    });\n    var controls = [];\n    var lines = [];\n    var isRect = type === \"rect\";\n    var isInset = type === \"inset\";\n    var isPolygon = type === \"polygon\";\n\n    if (isRect || isInset || isPolygon) {\n      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;\n      lines = linePoses_1.map(function (to, i) {\n        var from = i === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i - 1];\n        var rad = getRad(from, to);\n        var dist = getDiagonalSize(from, to);\n        return React.createElement(\"div\", {\n          key: \"clipLine\" + i,\n          className: prefix(\"line\", \"clip-line\"),\n          \"data-clip-index\": i,\n          style: {\n            width: dist + \"px\",\n            transform: \"translate(\" + from[0] + \"px, \" + from[1] + \"px) rotate(\" + rad + \"rad)\"\n          }\n        });\n      });\n    }\n\n    controls = poses.map(function (pos, i) {\n      return React.createElement(\"div\", {\n        key: \"clipControl\" + i,\n        className: prefix(\"control\", \"clip-control\"),\n        \"data-clip-index\": i,\n        style: {\n          transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px)\"\n        }\n      });\n    });\n\n    if (isInset) {\n      controls.push.apply(controls, poses.slice(8).map(function (pos, i) {\n        return React.createElement(\"div\", {\n          key: \"clipRadiusControl\" + i,\n          className: prefix(\"control\", \"clip-control\", \"clip-radius\"),\n          \"data-clip-index\": 8 + i,\n          style: {\n            transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px)\"\n          }\n        });\n      }));\n    }\n\n    if (type === \"circle\" || type === \"ellipse\") {\n      var clipLeft = clipPath.left,\n          clipTop = clipPath.top,\n          radiusX = clipPath.radiusX,\n          radiusY = clipPath.radiusY;\n\n      var _c = minus(caculatePosition(matrix, [clipLeft, clipTop], n), caculatePosition(matrix, [0, 0], n)),\n          distLeft = _c[0],\n          distTop = _c[1];\n\n      var ellipseClipPath = \"none\";\n\n      if (!clipArea) {\n        var piece = Math.max(10, radiusX / 5, radiusY / 5);\n        var areaPoses = [];\n\n        for (var i = 0; i <= piece; ++i) {\n          var rad = Math.PI * 2 / piece * i;\n          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);\n        }\n\n        areaPoses.push([radiusX, -2]);\n        areaPoses.push([-2, -2]);\n        areaPoses.push([-2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);\n        areaPoses.push([radiusX * 2 + 2, -2]);\n        areaPoses.push([radiusX, -2]);\n        ellipseClipPath = \"polygon(\" + areaPoses.map(function (pos) {\n          return pos[0] + \"px \" + pos[1] + \"px\";\n        }).join(\", \") + \")\";\n      }\n\n      controls.push(React.createElement(\"div\", {\n        key: \"clipEllipse\",\n        className: prefix(\"clip-ellipse\"),\n        style: {\n          width: radiusX * 2 + \"px\",\n          height: radiusY * 2 + \"px\",\n          clipPath: ellipseClipPath,\n          transform: \"translate(\" + (-left + distLeft) + \"px, \" + (-top + distTop) + \"px) \" + makeMatrixCSS(matrix)\n        }\n      }));\n    }\n\n    if (clipArea) {\n      var _d = getRect([pos1, pos2, pos3, pos4].concat(poses)),\n          allWidth = _d.width,\n          allHeight = _d.height,\n          allLeft_1 = _d.left,\n          allTop_1 = _d.top;\n\n      if (isPolygon || isRect || isInset) {\n        var areaPoses = isInset ? poses.slice(0, 8) : poses;\n        controls.push(React.createElement(\"div\", {\n          key: \"clipArea\",\n          className: prefix(\"clip-area\"),\n          style: {\n            width: allWidth + \"px\",\n            height: allHeight + \"px\",\n            transform: \"translate(\" + allLeft_1 + \"px, \" + allTop_1 + \"px)\",\n            clipPath: \"polygon(\" + areaPoses.map(function (pos) {\n              return pos[0] - allLeft_1 + \"px \" + (pos[1] - allTop_1) + \"px\";\n            }).join(\", \") + \")\"\n          }\n        }));\n      }\n    }\n\n    return controls.concat(lines);\n  },\n  dragControlCondition: function (e) {\n    return e.inputEvent && (e.inputEvent.target.className || \"\").indexOf(\"clip\") > -1;\n  },\n  dragStart: function (moveable, e) {\n    var props = moveable.props;\n    var _a = props.dragWithClip,\n        dragWithClip = _a === void 0 ? true : _a;\n\n    if (dragWithClip) {\n      return false;\n    }\n\n    return this.dragControlStart(moveable, e);\n  },\n  drag: function (moveable, e) {\n    return this.dragControl(moveable, e);\n  },\n  dragEnd: function (moveable, e) {\n    return this.dragControlEnd(moveable, e);\n  },\n  dragControlStart: function (moveable, e) {\n    var state = moveable.state;\n    var _a = moveable.props,\n        defaultClipPath = _a.defaultClipPath,\n        customClipPath = _a.customClipPath;\n    var target = state.target,\n        width = state.width,\n        height = state.height;\n    var inputTarget = e.inputEvent ? e.inputEvent.target : null;\n    var className = inputTarget ? inputTarget.className : \"\";\n    var datas = e.datas;\n    var clipPath = getClipPath(target, width, height, defaultClipPath || \"inset\", customClipPath);\n\n    if (!clipPath) {\n      return false;\n    }\n\n    var clipText = clipPath.clipText,\n        type = clipPath.type,\n        poses = clipPath.poses;\n    var result = triggerEvent(moveable, \"onClipStart\", fillParams(moveable, e, {\n      clipType: type,\n      clipStyle: clipText,\n      poses: poses.map(function (pos) {\n        return pos.pos;\n      })\n    }));\n\n    if (result === false) {\n      datas.isClipStart = false;\n      return false;\n    }\n\n    datas.isControl = className.indexOf(\"clip-control\") > -1;\n    datas.isLine = className.indexOf(\"clip-line\") > -1;\n    datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n    datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n    datas.clipPath = clipPath;\n    datas.isClipStart = true;\n    state.clipPathState = clipText;\n    setDragStart(moveable, e);\n    return true;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        originalDatas = e.originalDatas;\n\n    if (!datas.isClipStart) {\n      return false;\n    }\n\n    var draggableData = originalDatas && originalDatas.draggable || {};\n    var _a = datas,\n        isControl = _a.isControl,\n        isLine = _a.isLine,\n        isArea = _a.isArea,\n        index = _a.index,\n        clipPath = _a.clipPath;\n\n    if (!clipPath) {\n      return false;\n    }\n\n    var _b = draggableData.isDrag ? draggableData.prevDist : getDragDist(e),\n        distX = _b[0],\n        distY = _b[1];\n\n    var state = moveable.state;\n    var isDragWithTarget = !isArea && !isControl && !isLine;\n    var clipType = clipPath.type,\n        clipPoses = clipPath.poses,\n        splitter = clipPath.splitter;\n    var poses = clipPoses.map(function (pos) {\n      return pos.pos;\n    });\n    var nextPoses = poses.map(function (pos) {\n      return pos.slice();\n    });\n\n    if (isDragWithTarget) {\n      distX = -distX;\n      distY = -distY;\n    }\n\n    var isAll = !isControl || clipPoses[index].direction === \"nesw\";\n\n    if (isControl && !isAll) {\n      moveControlPos(clipPoses, nextPoses, index, distX, distY);\n    }\n\n    if (isAll) {\n      poses.forEach(function (pos, i) {\n        nextPoses[i] = plus(pos, [distX, distY]);\n      });\n    } // const indexes: number[] = [];\n    // const clipStyles = getClipStyles(clipPath, width, height, clipPoses.map(pos => pos.pos))!;\n\n\n    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);\n    var clipStyle = clipType + \"(\" + nextClipStyles.join(splitter) + \")\";\n    state.clipPathState = clipStyle;\n    triggerEvent(moveable, \"onClip\", fillParams(moveable, e, {\n      clipEventType: \"changed\",\n      clipType: clipType,\n      poses: nextPoses,\n      clipStyle: clipStyle,\n      clipStyles: nextClipStyles,\n      distX: distX,\n      distY: distY\n    }));\n    return true;\n  },\n  dragControlEnd: function (moveable, e) {\n    moveable.state.clipPathState = \"\";\n    var isDrag = e.isDrag,\n        datas = e.datas,\n        isDouble = e.isDouble;\n    var isLine = datas.isLine,\n        isClipStart = datas.isClipStart,\n        isControl = datas.isControl;\n\n    if (!isClipStart) {\n      return false;\n    }\n\n    triggerEvent(moveable, \"onClipEnd\", fillEndParams(moveable, e, {}));\n\n    if (isDouble) {\n      if (isControl) {\n        removeClipPath(moveable, e);\n      } else if (isLine) {\n        // add\n        addClipPath(moveable, e);\n      }\n    }\n\n    return isDouble || isDrag;\n  },\n  unset: function (moveable) {\n    moveable.state.clipPathState = \"\";\n  }\n};\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea. (default: false)\n * @name Moveable.Clippable#clipArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\n\nvar OriginDraggable = {\n  name: \"originDraggable\",\n  props: {\n    originDraggable: Boolean,\n    originRelative: Boolean\n  },\n  events: {\n    onDragOriginStart: \"dragOriginStart\",\n    onDragOrigin: \"dragOrigin\",\n    onDragOriginEnd: \"dragOriginEnd\"\n  },\n  css: [\":host[data-able-origindraggable] .control.origin {\\n    pointer-events: auto;\\n}\"],\n  dragControlCondition: function (e) {\n    if (e.isRequest) {\n      return e.requestAble === \"originDraggable\";\n    }\n\n    return hasClass(e.inputEvent.target, prefix(\"origin\"));\n  },\n  dragControlStart: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n    setDragStart(moveable, e);\n    var params = fillParams(moveable, e, {\n      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))\n    });\n    var result = triggerEvent(moveable, \"onDragOriginStart\", params);\n    datas.startOrigin = moveable.state.transformOrigin;\n    datas.startTargetOrigin = moveable.state.targetOrigin;\n    datas.prevOrigin = [0, 0];\n    datas.isDragOrigin = true;\n\n    if (result === false) {\n      datas.isDragOrigin = false;\n      return false;\n    }\n\n    return params;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent,\n        isPinch = e.isPinch,\n        isRequest = e.isRequest;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n\n    var _a = getDragDist(e),\n        distX = _a[0],\n        distY = _a[1];\n\n    var state = moveable.state;\n    var width = state.width,\n        height = state.height,\n        offsetMatrix = state.offsetMatrix,\n        targetMatrix = state.targetMatrix,\n        is3d = state.is3d;\n    var _b = moveable.props.originRelative,\n        originRelative = _b === void 0 ? true : _b;\n    var n = is3d ? 4 : 3;\n    var dist = [distX, distY];\n\n    if (isRequest) {\n      var distOrigin = e.distOrigin;\n\n      if (distOrigin[0] || distOrigin[1]) {\n        dist = distOrigin;\n      }\n    }\n\n    var origin = plus(datas.startOrigin, dist);\n    var targetOrigin = plus(datas.startTargetOrigin, dist);\n    var delta = minus(dist, datas.prevOrigin);\n    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);\n    var rect = moveable.getRect();\n    var nextRect = getRect(caculatePoses(nextMatrix, width, height, n));\n    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];\n    datas.prevOrigin = dist;\n    var transformOrigin = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(\" \");\n    var params = fillParams(moveable, e, {\n      width: width,\n      height: height,\n      origin: origin,\n      dist: dist,\n      delta: delta,\n      transformOrigin: transformOrigin,\n      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, dragDelta, inputEvent, !!isPinch, false))\n    });\n    triggerEvent(moveable, \"onDragOrigin\", params);\n    return params;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isDragOrigin) {\n      return false;\n    }\n\n    triggerEvent(moveable, \"onDragOriginEnd\", fillEndParams(moveable, e, {}));\n    return true;\n  },\n  dragGroupControlCondition: function (e) {\n    return this.dragControlCondition(e);\n  },\n  dragGroupControlStart: function (moveable, e) {\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    return true;\n  },\n  dragGroupControl: function (moveable, e) {\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    moveable.transformOrigin = params.transformOrigin;\n    return true;\n  },\n\n  /**\n  * @method Moveable.OriginDraggable#request\n  * @param {object} e - the OriginDraggable's request parameter\n  * @param {number} [e.x] - x position\n  * @param {number} [e.y] - y position\n  * @param {number} [e.deltaX] - x number to move\n  * @param {number} [e.deltaY] - y number to move\n  * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n  * @param {array} [e.origin] - transform-origin position\n  * @param {number} [e.isInstant] - Whether to execute the request instantly\n  * @return {Moveable.Requester} Moveable Requester\n  * @example\n   * // Instantly Request (requestStart - request - requestEnd)\n  * // Use Relative Value\n  * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n  * // Use Transform Value\n  * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n  * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n  * // requestStart\n  * const requester = moveable.request(\"originDraggable\");\n  *\n  * // request\n  * // Use Relative Value\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * requester.request({ deltaX: 10, deltaY: 10 });\n  * // Use Absolute Value\n  * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n  * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n  *\n  * // requestEnd\n  * requester.requestEnd();\n  */\n  request: function (moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    var transformOrigin = rect.transformOrigin;\n    var distOrigin = [0, 0];\n    return {\n      isControl: true,\n      requestStart: function () {\n        return {\n          datas: datas\n        };\n      },\n      request: function (e) {\n        if (\"deltaOrigin\" in e) {\n          distOrigin[0] += e.deltaOrigin[0];\n          distOrigin[1] += e.deltaOrigin[1];\n        } else if (\"origin\" in e) {\n          distOrigin[0] = e.origin[0] - transformOrigin[0];\n          distOrigin[1] = e.origin[1] - transformOrigin[1];\n        } else {\n          if (\"x\" in e) {\n            distX = e.x - rect.left;\n          } else if (\"deltaX\" in e) {\n            distX += e.deltaX;\n          }\n\n          if (\"y\" in e) {\n            distY = e.y - rect.top;\n          } else if (\"deltaY\" in e) {\n            distY += e.deltaY;\n          }\n        }\n\n        return {\n          datas: datas,\n          distX: distX,\n          distY: distY,\n          distOrigin: distOrigin\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\nfunction addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {\n  var _a = splitRadiusPoses(controlPoses),\n      horizontals = _a.horizontals,\n      verticals = _a.verticals;\n\n  var horizontalsLength = horizontals.length;\n  var verticalsLength = verticals.length; // lineIndex\n  // 0 top\n  // 1 right\n  // 2 left\n  // 3 bottom\n  // 0 top - left\n  // 1 top - right\n  // 2 bottom - right\n  // 3 bottom - left\n  // 0 left - top\n  // 1 right - top\n  // 2 right - bottom\n  // 3 left - bottom\n\n  var horizontalIndex = -1;\n  var verticalIndex = -1;\n\n  if (lineIndex === 0) {\n    if (horizontalsLength === 0) {\n      horizontalIndex = 0;\n    } else if (horizontalsLength === 1) {\n      horizontalIndex = 1;\n    }\n  } else if (lineIndex === 3) {\n    if (horizontalsLength <= 2) {\n      horizontalIndex = 2;\n    } else if (horizontalsLength <= 3) {\n      horizontalIndex = 3;\n    }\n  }\n\n  if (lineIndex === 2) {\n    if (verticalsLength === 0) {\n      verticalIndex = 0;\n    } else if (verticalsLength < 4) {\n      verticalIndex = 3;\n    }\n  } else if (lineIndex === 1) {\n    if (verticalsLength <= 1) {\n      verticalIndex = 1;\n    } else if (verticalsLength <= 2) {\n      verticalIndex = 2;\n    }\n  }\n\n  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);\n}\n\nfunction getBorderRadius(target, width, height, state) {\n  var borderRadius;\n\n  if (!state) {\n    var style = window.getComputedStyle(target);\n\n    if (!style) {\n      return null;\n    }\n\n    borderRadius = style.borderRadius || \"\";\n  } else {\n    borderRadius = state;\n  }\n\n  if (!borderRadius || !state && borderRadius === \"0px\") {\n    return null;\n  }\n\n  var values = splitSpace(borderRadius);\n  return getRadiusValues(values, width, height, 0, 0);\n}\n\nfunction triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses) {\n  var state = moveable.state;\n  var width = state.width,\n      height = state.height;\n\n  var _a = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height),\n      raws = _a.raws,\n      styles = _a.styles;\n\n  var _b = splitRadiusPoses(controlPoses, raws),\n      horizontals = _b.horizontals,\n      verticals = _b.verticals;\n\n  var borderRadius = styles.join(\" \");\n  state.borderRadiusState = borderRadius;\n  triggerEvent(moveable, \"onRound\", fillParams(moveable, e, {\n    horizontals: horizontals,\n    verticals: verticals,\n    borderRadius: borderRadius,\n    width: width,\n    height: height,\n    delta: delta,\n    dist: dist\n  }));\n}\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\n\nvar Roundable = {\n  name: \"roundable\",\n  props: {\n    roundable: Boolean,\n    roundRelative: Boolean\n  },\n  events: {\n    onRoundStart: \"roundStart\",\n    onRound: \"round\",\n    onRoundEnd: \"roundEnd\"\n  },\n  css: [\".control.border-radius {\\n    background: #d66;\\n    cursor: pointer;\\n}\", \":host[data-able-roundable] .line.direction {\\n    cursor: pointer;\\n}\"],\n  render: function (moveable, React) {\n    var _a = moveable.state,\n        target = _a.target,\n        width = _a.width,\n        height = _a.height,\n        matrix = _a.matrix,\n        is3d = _a.is3d,\n        left = _a.left,\n        top = _a.top,\n        borderRadiusState = _a.borderRadiusState;\n\n    if (!target) {\n      return null;\n    }\n\n    var n = is3d ? 4 : 3;\n    var radiusValues = getBorderRadius(target, width, height, borderRadiusState);\n\n    if (!radiusValues) {\n      return null;\n    }\n\n    return radiusValues.map(function (v, i) {\n      var pos = minus(caculatePosition(matrix, v.pos, n), [left, top]);\n      return React.createElement(\"div\", {\n        key: \"borderRadiusControl\" + i,\n        className: prefix(\"control\", \"border-radius\"),\n        \"data-radius-index\": i,\n        style: {\n          transform: \"translate(\" + pos[0] + \"px, \" + pos[1] + \"px)\"\n        }\n      });\n    });\n  },\n  dragControlCondition: function (e) {\n    if (!e.inputEvent || e.isRequest) {\n      return false;\n    }\n\n    var className = e.inputEvent.target.className || \"\";\n    return className.indexOf(\"border-radius\") > -1 || className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n  },\n  dragControlStart: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n    var inputTarget = inputEvent.target;\n    var className = inputTarget.className || \"\";\n    var isControl = className.indexOf(\"border-radius\") > -1;\n    var isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n    var controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n    var lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n    if (!isControl && !isLine) {\n      return false;\n    }\n\n    var result = triggerEvent(moveable, \"onRoundStart\", fillParams(moveable, e, {}));\n\n    if (result === false) {\n      return false;\n    }\n\n    datas.lineIndex = lineIndex;\n    datas.controlIndex = controlIndex;\n    datas.isControl = isControl;\n    datas.isLine = isLine;\n    setDragStart(moveable, e);\n    var roundRelative = moveable.props.roundRelative;\n    var state = moveable.state;\n    var target = state.target,\n        width = state.width,\n        height = state.height;\n    datas.isRound = true;\n    datas.prevDist = [0, 0];\n    var controlPoses = getBorderRadius(target, width, height) || [];\n    datas.controlPoses = controlPoses;\n    state.borderRadiusState = getRadiusStyles(controlPoses.map(function (pos) {\n      return pos.pos;\n    }), controlPoses, roundRelative, width, height).styles.join(\" \");\n    return true;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n      return false;\n    }\n\n    var index = datas.controlIndex;\n    var controlPoses = datas.controlPoses;\n    var nextPoses = controlPoses.map(function (pos) {\n      return pos.pos.slice();\n    });\n\n    var _a = getDragDist(e),\n        distX = _a[0],\n        distY = _a[1];\n\n    var dist = [distX, distY];\n    var delta = minus(dist, datas.prevDist);\n    moveControlPos(controlPoses, nextPoses, index, distX, distY);\n    datas.prevDist = [distX, distY];\n    triggerRoundEvent(moveable, e, dist, delta, controlPoses, nextPoses);\n    return true;\n  },\n  dragControlEnd: function (moveable, e) {\n    var state = moveable.state;\n    state.borderRadiusState = \"\";\n    var datas = e.datas,\n        isDouble = e.isDouble;\n\n    if (!datas.isRound) {\n      return false;\n    }\n\n    var width = state.width,\n        height = state.height;\n    var isControl = datas.isControl,\n        controlIndex = datas.controlIndex,\n        isLine = datas.isLine,\n        lineIndex = datas.lineIndex;\n    var controlPoses = datas.controlPoses;\n    var poses = controlPoses.map(function (pos) {\n      return pos.pos;\n    });\n    var length = poses.length;\n\n    if (isDouble) {\n      if (isControl) {\n        removeRadiusPos(controlPoses, poses, controlIndex, 0);\n      } else if (isLine) {\n        var _a = caculatePointerDist(moveable, e),\n            distX = _a[0],\n            distY = _a[1];\n\n        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n      }\n\n      if (length !== controlPoses.length) {\n        triggerRoundEvent(moveable, e, [0, 0], [0, 0], controlPoses, poses);\n      }\n\n      triggerEvent(moveable, \"onRoundEnd\", fillEndParams(moveable, e, {}));\n    }\n\n    state.borderRadiusState = \"\";\n    return true;\n  },\n  unset: function (moveable) {\n    moveable.state.borderRadiusState = \"\";\n  }\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\nvar Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    defaultGroupOrigin: String,\n    groupable: Boolean\n  },\n  events: {},\n  render: function (moveable, React) {\n    var targets = moveable.props.targets || [];\n    moveable.moveables = [];\n    var _a = moveable.state,\n        left = _a.left,\n        top = _a.top;\n    var position = {\n      left: left,\n      top: top\n    };\n    return targets.map(function (target, i) {\n      return React.createElement(MoveableManager, {\n        key: \"moveable\" + i,\n        ref: refs(moveable, \"moveables\", i),\n        target: target,\n        origin: false,\n        parentMoveable: moveable,\n        parentPosition: position\n      });\n    });\n  }\n};\nvar MOVEABLE_ABLES = [Default, Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable];\nvar MOVEABLE_EVENTS_PROPS_MAP = MOVEABLE_ABLES.reduce(function (current, able) {\n  return __assign({}, current, able.events);\n}, {});\nvar MOVEABLE_PROPS_MAP = MOVEABLE_ABLES.reduce(function (current, able) {\n  return __assign({}, current, able.props);\n}, {});\nvar MOVEABLE_EVENTS_MAP = invert$1(MOVEABLE_EVENTS_PROPS_MAP);\nvar MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);\nvar MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);\nvar cssMap = {};\nMOVEABLE_ABLES.forEach(function (_a) {\n  var css = _a.css;\n\n  if (!css) {\n    return;\n  }\n\n  css.forEach(function (text) {\n    cssMap[text] = true;\n  });\n});\nvar ABLE_CSS = Object.keys(cssMap).join(\"\\n\");\nvar ControlBoxElement = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + ABLE_CSS));\n\nfunction renderLine(direction, pos1, pos2, index) {\n  var rad = getRad(pos1, pos2);\n  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;\n  return createElement(\"div\", {\n    key: \"line\" + index,\n    className: prefix(\"line\", \"direction\", direction),\n    \"data-rotation\": rotation,\n    \"data-line-index\": index,\n    \"data-direction\": direction,\n    style: getLineStyle(pos1, pos2, rad)\n  });\n}\n\nvar MoveableManager = /*#__PURE__*/function (_super) {\n  __extends(MoveableManager, _super);\n\n  function MoveableManager() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      container: null,\n      target: null,\n      beforeMatrix: createIdentityMatrix3(),\n      matrix: createIdentityMatrix3(),\n      targetMatrix: createIdentityMatrix3(),\n      offsetMatrix: createIdentityMatrix3(),\n      targetTransform: \"\",\n      is3d: false,\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0,\n      transformOrigin: [0, 0],\n      direction: 1,\n      beforeDirection: 1,\n      beforeOrigin: [0, 0],\n      origin: [0, 0],\n      pos1: [0, 0],\n      pos2: [0, 0],\n      pos3: [0, 0],\n      pos4: [0, 0],\n      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n      targetClientRect: resetClientRect(),\n      containerClientRect: resetClientRect(),\n      moveableClientRect: resetClientRect(),\n      rotation: 0\n    };\n    _this.targetAbles = [];\n    _this.controlAbles = [];\n    _this.rotation = 0;\n    _this.scale = [1, 1];\n    _this.isUnmounted = false;\n    return _this;\n  }\n\n  var __proto = MoveableManager.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var state = this.state;\n    var edge = props.edge,\n        parentPosition = props.parentPosition,\n        className = props.className,\n        propsTarget = props.target,\n        zoom = props.zoom,\n        cspNonce = props.cspNonce;\n    this.checkUpdate();\n    this.updateRenderPoses();\n\n    var _a = parentPosition || {\n      left: 0,\n      top: 0\n    },\n        parentLeft = _a.left,\n        parentTop = _a.top;\n\n    var left = state.left,\n        top = state.top,\n        stateTarget = state.target,\n        direction = state.direction,\n        renderPoses = state.renderPoses;\n    var groupTargets = props.targets;\n    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;\n    var isDragging = this.isDragging();\n    var ableAttributes = {};\n    this.getEnabledAbles().forEach(function (able) {\n      ableAttributes[\"data-able-\" + able.name.toLowerCase()] = true;\n    });\n    return createElement(ControlBoxElement, __assign({\n      cspNonce: cspNonce,\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\") + \" \" + className\n    }, ableAttributes, {\n      style: {\n        \"position\": \"absolute\",\n        \"display\": isDisplay ? \"block\" : \"none\",\n        \"transform\": \"translate(\" + (left - parentLeft) + \"px, \" + (top - parentTop) + \"px) translateZ(50px)\",\n        \"--zoom\": zoom,\n        \"--zoompx\": zoom + \"px\"\n      }\n    }), this.renderAbles(), renderLine(edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], 0), renderLine(edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], 1), renderLine(edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], 2), renderLine(edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], 3));\n  };\n\n  __proto.componentDidMount = function () {\n    this.controlBox.getElement();\n    var props = this.props;\n    var parentMoveable = props.parentMoveable,\n        container = props.container;\n    this.updateEvent(props);\n\n    if (!container && !parentMoveable) {\n      this.updateRect(\"End\", false, true);\n    }\n\n    this.updateCheckInput();\n  };\n\n  __proto.componentDidUpdate = function (prevProps) {\n    this.updateEvent(prevProps);\n    this.updateCheckInput();\n  };\n\n  __proto.componentWillUnmount = function () {\n    this.isUnmounted = true;\n    unset(this, \"targetDragger\");\n    unset(this, \"controlDragger\");\n  };\n\n  __proto.getContainer = function () {\n    var _a = this.props,\n        parentMoveable = _a.parentMoveable,\n        container = _a.container;\n    return container || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;\n  };\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n\n\n  __proto.isMoveableElement = function (target) {\n    return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n  };\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n\n\n  __proto.dragStart = function (e) {\n    if (this.targetDragger) {\n      this.targetDragger.triggerDragStart(e);\n    }\n\n    return this;\n  };\n  /**\n   * Hit test an element or rect on a moveable target.\n   * @method Moveable#hitTest\n   * @param - element or rect to test\n   * @return - Get hit test rate (rate > 0 is hitted)\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.hitTest(e.target) > 0) {\n   *          console.log(\"hiited\");\n   *     }\n   * });\n   */\n\n\n  __proto.hitTest = function (el) {\n    var rect;\n\n    if (el instanceof Element) {\n      var clientRect = el.getBoundingClientRect();\n      rect = {\n        left: clientRect.left,\n        top: clientRect.top,\n        width: clientRect.width,\n        height: clientRect.height\n      };\n    } else {\n      rect = __assign({\n        width: 0,\n        height: 0\n      }, el);\n    }\n\n    var _a = this.state.targetClientRect,\n        rectLeft = _a.left,\n        rectTop = _a.top,\n        rectWidth = _a.width,\n        rectHeight = _a.height;\n    var left = rect.left,\n        top = rect.top,\n        width = rect.width,\n        height = rect.height;\n    var right = left + width;\n    var bottom = top + height;\n    var rectRight = rectLeft + rectWidth;\n    var rectBottom = rectTop + rectHeight;\n    var testLeft = Math.max(rectLeft, left);\n    var testRight = Math.min(rectRight, right);\n    var testTop = Math.max(rectTop, top);\n    var testBottom = Math.min(rectBottom, bottom);\n\n    if (testRight < testLeft || testBottom < testTop) {\n      return 0;\n    }\n\n    var rectSize = (Math.min(rectRight, right) - Math.max(left, rectLeft)) * (Math.min(rectBottom, bottom) - Math.max(rectTop, top));\n    return Math.min(100, (testRight - testLeft) * (testBottom - testTop) / rectSize * 100);\n  };\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n\n\n  __proto.isInside = function (clientX, clientY) {\n    var _a = this.state,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        target = _a.target,\n        targetClientRect = _a.targetClientRect;\n\n    if (!target) {\n      return false;\n    }\n\n    var left = targetClientRect.left,\n        top = targetClientRect.top;\n    var pos = [clientX - left, clientY - top];\n    return isInside(pos, pos1, pos2, pos3, pos4);\n  };\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    var props = this.props;\n    var parentMoveable = props.parentMoveable;\n    var state = this.state;\n    var target = state.target || this.props.target;\n    var container = this.getContainer();\n    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;\n    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container, isTarget ? state : undefined), parentMoveable ? false : isSetState);\n  };\n\n  __proto.updateEvent = function (prevProps) {\n    var controlBoxElement = this.controlBox.getElement();\n    var hasTargetAble = this.targetAbles.length;\n    var hasControlAble = this.controlAbles.length;\n    var props = this.props;\n    var target = props.dragTarget || props.target;\n    var prevTarget = prevProps.dragTarget || prevProps.target;\n    var dragArea = props.dragArea;\n    var prevDragArea = prevProps.dragArea;\n    var isTargetChanged = !dragArea && prevTarget !== target;\n    var isUnset = !hasTargetAble && this.targetDragger || isTargetChanged || prevDragArea !== dragArea;\n\n    if (isUnset) {\n      unset(this, \"targetDragger\");\n      this.updateState({\n        dragger: null\n      });\n    }\n\n    if (!hasControlAble) {\n      unset(this, \"controlDragger\");\n    }\n\n    if (target && hasTargetAble && !this.targetDragger) {\n      this.targetDragger = getTargetAbleDragger(this, target, \"\");\n    }\n\n    if (!this.controlDragger && hasControlAble) {\n      this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n    }\n\n    if (isUnset) {\n      this.unsetAbles();\n    }\n  };\n  /**\n   * Check if the moveable state is being dragged.\n   * @method Moveable#isDragging\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // false\n   * console.log(moveable.isDragging());\n   *\n   * moveable.on(\"drag\", () => {\n   *   // true\n   *   console.log(moveable.isDragging());\n   * });\n   */\n\n\n  __proto.isDragging = function () {\n    return (this.targetDragger ? this.targetDragger.isFlag() : false) || (this.controlDragger ? this.controlDragger.isFlag() : false);\n  };\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * @method Moveable#updateTarget\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n\n\n  __proto.updateTarget = function (type) {\n    this.updateRect(type, true);\n  };\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n\n\n  __proto.getRect = function () {\n    var state = this.state;\n    var poses = getAbsolutePosesByState(this.state);\n    var pos1 = poses[0],\n        pos2 = poses[1],\n        pos3 = poses[2],\n        pos4 = poses[3];\n    var rect = getRect(poses);\n    var offsetWidth = state.width,\n        offsetHeight = state.height;\n    var width = rect.width,\n        height = rect.height,\n        left = rect.left,\n        top = rect.top;\n    var statePos = [state.left, state.top];\n    var origin = plus(statePos, state.origin);\n    var beforeOrigin = plus(statePos, state.beforeOrigin);\n    var transformOrigin = state.transformOrigin;\n    return {\n      width: width,\n      height: height,\n      left: left,\n      top: top,\n      pos1: pos1,\n      pos2: pos2,\n      pos3: pos3,\n      pos4: pos4,\n      offsetWidth: offsetWidth,\n      offsetHeight: offsetHeight,\n      beforeOrigin: beforeOrigin,\n      origin: origin,\n      transformOrigin: transformOrigin,\n      rotation: this.getRotation()\n    };\n  };\n\n  __proto.getRotation = function () {\n    var _a = this.state,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        direction = _a.direction;\n    var deg = getRad(pos1, pos2) / Math.PI * 180;\n    deg = direction >= 0 ? deg : 180 - deg;\n    deg = deg >= 0 ? deg : 360 + deg;\n    return deg;\n  };\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n   * @param - ableName\n   * @param - request to be able params.\n   * @param - If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n\n\n  __proto.request = function (ableName, param, isInstant) {\n    if (param === void 0) {\n      param = {};\n    }\n\n    var _a = this.props,\n        ables = _a.ables,\n        groupable = _a.groupable;\n    var requsetAble = ables.filter(function (able) {\n      return able.name === ableName;\n    })[0];\n\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request: function () {\n          return this;\n        },\n        requestEnd: function () {\n          return this;\n        }\n      };\n    }\n\n    var self = this;\n    var ableRequester = requsetAble.request(this);\n    var requestInstant = isInstant || param.isInstant;\n    var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n    var eventAffix = \"\" + (groupable ? \"Group\" : \"\") + (ableRequester.isControl ? \"Control\" : \"\");\n    var requester = {\n      request: function (ableParam) {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"\", __assign({}, ableRequester.request(ableParam), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      },\n      requestEnd: function () {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"End\", __assign({}, ableRequester.requestEnd(), {\n          requestAble: ableName,\n          isRequest: true\n        }), requestInstant);\n        return this;\n      }\n    };\n    triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", __assign({}, ableRequester.requestStart(param), {\n      requestAble: ableName,\n      isRequest: true\n    }), requestInstant);\n    return requestInstant ? requester.request(param).requestEnd() : requester;\n  };\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n\n\n  __proto.destroy = function () {\n    this.componentWillUnmount();\n  };\n\n  __proto.updateRenderPoses = function () {\n    var state = this.state;\n    var props = this.props;\n    var beforeOrigin = state.beforeOrigin,\n        transformOrigin = state.transformOrigin,\n        matrix = state.matrix,\n        is3d = state.is3d,\n        pos1 = state.pos1,\n        pos2 = state.pos2,\n        pos3 = state.pos3,\n        pos4 = state.pos4,\n        stateLeft = state.left,\n        stateTop = state.top;\n\n    var _a = props.padding || {},\n        _b = _a.left,\n        left = _b === void 0 ? 0 : _b,\n        _c = _a.top,\n        top = _c === void 0 ? 0 : _c,\n        _d = _a.bottom,\n        bottom = _d === void 0 ? 0 : _d,\n        _e = _a.right,\n        right = _e === void 0 ? 0 : _e;\n\n    var n = is3d ? 4 : 3;\n    var absoluteOrigin = props.groupable ? beforeOrigin : plus(beforeOrigin, [stateLeft, stateTop]);\n    state.renderPoses = [plus(pos1, caculatePadding(matrix, [-left, -top], transformOrigin, absoluteOrigin, n)), plus(pos2, caculatePadding(matrix, [right, -top], transformOrigin, absoluteOrigin, n)), plus(pos3, caculatePadding(matrix, [-left, bottom], transformOrigin, absoluteOrigin, n)), plus(pos4, caculatePadding(matrix, [right, bottom], transformOrigin, absoluteOrigin, n))];\n  };\n\n  __proto.checkUpdate = function () {\n    var _a = this.props,\n        target = _a.target,\n        container = _a.container,\n        parentMoveable = _a.parentMoveable;\n    var _b = this.state,\n        stateTarget = _b.target,\n        stateContainer = _b.container;\n\n    if (!stateTarget && !target) {\n      return;\n    }\n\n    this.updateAbles();\n    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n    if (!isChanged) {\n      return;\n    }\n\n    this.updateState({\n      target: target,\n      container: container\n    });\n\n    if (!parentMoveable && (container || this.controlBox)) {\n      this.updateRect(\"End\", false, false);\n    }\n  };\n\n  __proto.triggerEvent = function (name, e) {\n    var callback = this.props[name];\n    return callback && callback(e);\n  };\n\n  __proto.unsetAbles = function () {\n    var _this = this;\n\n    if (this.targetAbles.filter(function (able) {\n      if (able.unset) {\n        able.unset(_this);\n        return true;\n      }\n\n      return false;\n    }).length) {\n      this.forceUpdate();\n    }\n  };\n\n  __proto.updateAbles = function (ables, eventAffix) {\n    if (ables === void 0) {\n      ables = this.props.ables;\n    }\n\n    if (eventAffix === void 0) {\n      eventAffix = \"\";\n    }\n\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var enabledAbles = ables.filter(function (able) {\n      return able && props[able.name];\n    });\n    var dragStart = \"drag\" + eventAffix + \"Start\";\n    var pinchStart = \"pinch\" + eventAffix + \"Start\";\n    var dragControlStart = \"drag\" + eventAffix + \"ControlStart\";\n    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  };\n\n  __proto.updateState = function (nextState, isSetState) {\n    if (isSetState) {\n      this.setState(nextState);\n    } else {\n      var state = this.state;\n\n      for (var name in nextState) {\n        state[name] = nextState[name];\n      }\n    }\n  };\n\n  __proto.getEnabledAbles = function () {\n    var props = this.props;\n    var ables = props.ables;\n    return ables.filter(function (able) {\n      return able && props[able.name];\n    });\n  };\n\n  __proto.renderAbles = function () {\n    var _this = this;\n\n    var props = this.props;\n    var triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n    var Renderer = {\n      createElement: createElement\n    };\n    return groupByMap(flat(filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(function (_a) {\n      var render = _a.render;\n      return render(_this, Renderer) || [];\n    })).filter(function (el) {\n      return el;\n    }), function (_a) {\n      var key = _a.key;\n      return key;\n    }).map(function (group) {\n      return group[0];\n    });\n  };\n\n  __proto.updateCheckInput = function () {\n    this.targetDragger && (this.targetDragger.options.checkInput = this.props.checkInput);\n  };\n\n  MoveableManager.defaultProps = {\n    target: null,\n    dragTarget: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    edge: false,\n    parentMoveable: null,\n    parentPosition: null,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1,\n    triggerAblesSimultaneously: false,\n    padding: {},\n    pinchOutside: true,\n    checkInput: false,\n    groupable: false,\n    cspNonce: \"\"\n  };\n  return MoveableManager;\n}(PureComponent);\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n\n/**\n * Zooms in the elements of a moveable. (default: 1)\n * @name Moveable#zoom\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s) (default: target)\n * @name Moveable#dragTarget\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n\n\nfunction getMaxPos(poses, index) {\n  return Math.max.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getMinPos(poses, index) {\n  return Math.min.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getGroupRect(moveables, rotation) {\n  if (!moveables.length) {\n    return [0, 0, 0, 0];\n  }\n\n  var moveablePoses = moveables.map(function (_a) {\n    var state = _a.state;\n    return getAbsolutePosesByState(state);\n  });\n  var minX = MAX_NUM;\n  var minY = MAX_NUM;\n  var groupWidth = 0;\n  var groupHeight = 0;\n  var fixedRotation = throttle(rotation, TINY_NUM);\n\n  if (fixedRotation % 90) {\n    var rad_1 = rotation / 180 * Math.PI;\n    var a1_1 = Math.tan(rad_1);\n    var a2_1 = -1 / a1_1;\n    var b1s_1 = [MIN_NUM, MAX_NUM];\n    var b2s_1 = [MIN_NUM, MAX_NUM];\n    moveablePoses.forEach(function (poses) {\n      poses.forEach(function (pos) {\n        // ax + b = y\n        //  = y - ax\n        var b1 = pos[1] - a1_1 * pos[0];\n        var b2 = pos[1] - a2_1 * pos[0];\n        b1s_1[0] = Math.max(b1s_1[0], b1);\n        b1s_1[1] = Math.min(b1s_1[1], b1);\n        b2s_1[0] = Math.max(b2s_1[0], b2);\n        b2s_1[1] = Math.min(b2s_1[1], b2);\n      });\n    });\n    b1s_1.forEach(function (b1) {\n      // a1x + b1 = a2x + b2\n      b2s_1.forEach(function (b2) {\n        // (a1 - a2)x = b2 - b1\n        var x = (b2 - b1) / (a1_1 - a2_1);\n        var y = a1_1 * x + b1;\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n      });\n    });\n    var rotatePoses = moveablePoses.map(function (_a) {\n      var pos1 = _a[0],\n          pos2 = _a[1],\n          pos3 = _a[2],\n          pos4 = _a[3];\n      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];\n    });\n    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n  } else {\n    minX = getMinPos(moveablePoses, 0);\n    minY = getMinPos(moveablePoses, 1);\n    groupWidth = getMaxPos(moveablePoses, 0) - minX;\n    groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n    if (fixedRotation % 180) {\n      var changedWidth = groupWidth;\n      groupWidth = groupHeight;\n      groupHeight = changedWidth;\n    }\n  }\n\n  return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\n\n\nvar MoveableGroup = /*#__PURE__*/function (_super) {\n  __extends(MoveableGroup, _super);\n\n  function MoveableGroup() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.differ = new ChildrenDiffer();\n    _this.moveables = [];\n    _this.transformOrigin = \"50% 50%\";\n    return _this;\n  }\n\n  var __proto = MoveableGroup.prototype;\n\n  __proto.updateEvent = function (prevProps) {\n    var state = this.state;\n    var props = this.props;\n\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.getElement().style.display = \"block\";\n      this.targetDragger = getTargetAbleDragger(this, state.target, \"Group\");\n      this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n    }\n\n    var isContainerChanged = !equals(prevProps.container, props.container);\n\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n\n    var _a = this.differ.update(props.targets),\n        added = _a.added,\n        changed = _a.changed,\n        removed = _a.removed;\n\n    if (isContainerChanged || added.length || changed.length || removed.length) {\n      this.updateRect();\n    }\n  };\n\n  __proto.checkUpdate = function () {\n    this.updateAbles();\n  };\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    var _a;\n\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    if (!this.controlBox) {\n      return;\n    }\n\n    this.moveables.forEach(function (moveable) {\n      moveable.updateRect(type, false, false);\n    });\n    var state = this.state;\n    var props = this.props;\n    var target = state.target || props.target;\n\n    if (!isTarget || type !== \"\" && props.updateGroup) {\n      // reset rotataion\n      this.rotation = props.defaultGroupRotate;\n      this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n      this.scale = [1, 1];\n    }\n\n    var rotation = this.rotation;\n    var scale = this.scale;\n\n    var _b = getGroupRect(this.moveables, rotation),\n        left = _b[0],\n        top = _b[1],\n        width = _b[2],\n        height = _b[3]; // tslint:disable-next-line: max-line-length\n\n\n    target.style.cssText += \"left:0px;top:0px; transform-origin: \" + this.transformOrigin + \"; width:\" + width + \"px; height:\" + height + \"px;transform:rotate(\" + rotation + \"deg)\" + (\" scale(\" + (scale[0] >= 0 ? 1 : -1) + \", \" + (scale[1] >= 0 ? 1 : -1) + \")\");\n    state.width = width;\n    state.height = height;\n    var container = this.getContainer();\n    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container, state);\n    var pos = [info.left, info.top];\n    _a = getAbsolutePosesByState(info), info.pos1 = _a[0], info.pos2 = _a[1], info.pos3 = _a[2], info.pos4 = _a[3];\n    info.origin = plus(pos, info.origin);\n    info.beforeOrigin = plus(pos, info.beforeOrigin);\n    var clientRect = info.targetClientRect;\n    clientRect.top += top - info.top - state.top;\n    clientRect.left += left - info.left - state.left;\n    var direction = scale[0] * scale[1] > 0 ? 1 : -1;\n    this.updateState(__assign({}, info, {\n      direction: direction,\n      beforeDirection: direction,\n      left: left - info.left,\n      top: top - info.top\n    }), isSetState);\n  };\n\n  __proto.triggerEvent = function (name, e) {\n    if (name.indexOf(\"Group\") > -1) {\n      return _super.prototype.triggerEvent.call(this, name, e);\n    }\n  };\n\n  __proto.updateAbles = function () {\n    _super.prototype.updateAbles.call(this, this.props.ables.concat([Groupable]), \"Group\");\n  };\n\n  MoveableGroup.defaultProps = __assign({}, MoveableManager.defaultProps, {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0,\n    defaultGroupOrigin: \"50% 50%\"\n  });\n  return MoveableGroup;\n}(MoveableManager);\n\nvar Moveable = /*#__PURE__*/function (_super) {\n  __extends(Moveable, _super);\n\n  function Moveable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = Moveable.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var ables = props.ables || [];\n    var target = this.props.target || this.props.targets;\n    var isArr = isArray(target);\n    var isGroup = isArr && target.length > 1;\n\n    if (isGroup) {\n      var nextProps = __assign({}, this.props, {\n        target: null,\n        targets: target,\n        ables: MOVEABLE_ABLES.concat([Groupable], ables)\n      });\n\n      return createElement(MoveableGroup, __assign({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, nextProps));\n    } else {\n      var moveableTarget = isArr ? target[0] : target;\n      return createElement(MoveableManager, __assign({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, __assign({}, this.props, {\n        target: moveableTarget,\n        ables: MOVEABLE_ABLES.concat(ables)\n      })));\n    }\n  };\n\n  __decorate([withMethods(MOVEABLE_METHODS)], Moveable.prototype, \"moveable\");\n\n  return Moveable;\n}(PureComponent);\n\nexport default Moveable;\nexport { MOVEABLE_ABLES, MOVEABLE_EVENTS, MOVEABLE_EVENTS_MAP, MOVEABLE_EVENTS_PROPS_MAP, MOVEABLE_METHODS, MOVEABLE_PROPS, MOVEABLE_PROPS_MAP };","map":{"version":3,"sources":["../src/react-moveable/consts.ts","../src/react-moveable/matrix/index.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/CustomDragger.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/ables/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/Padding.tsx","../src/react-moveable/ables/roundable/borderRadius.tsx","../src/react-moveable/ables/Clippable.tsx","../src/react-moveable/ables/OriginDraggable.tsx","../src/react-moveable/ables/Roundable.tsx","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/ables/consts.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"names":["x1","getSVGCursor","x2","degree45","Math","degree","defaultCursor","agent","getAgent","IS_WEBKIT","PREFIX","MOVEABLE_CSS","getCursorCSS","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","MIN_NUM","DIRECTIONS","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","MOVEABLE_METHODS","i","x","startIndex","fromX","fromIndex","matrix","inverseMatrix","v","iv","ignoreDimension","m","newMatrix","invert","createIdentityMatrix","identityIndex","j","swap","divide","targetStartIndex","targetIndex","target","add","transpose","getRad","pos1","pos2","distX","distY","rad","getOrigin","originMatrix","convertPositionMatrix","convertDimension","length","multiplies","matrixes","multiply","matrix2","k","l","average","nums","total","plus","nextPos","minus","convertCSStoMatrix","a","is2d","convertMatrixtoCSS","caculate","result","rotate","pos","createRotateMatrix","cos","sin","createScaleMatrix","scale","createOriginMatrix","origin","createWarpMatrix","pos0","pos3","nextPos0","nextPos1","nextPos2","nextPos3","x0","y0","y1","y2","x3","y3","u0","v0","u1","v1","u2","v2","u3","v3","h","setDragStart","moveable","_a","datas","_b","beforeMatrix","is3d","left","top","offsetMatrix","targetMatrix","transformOrigin","getDragDist","isBefore","inverseBeforeMatrix","startDragBeforeDist","startDragDist","absoluteOrigin","getInverseDragDist","caculateTransformOrigin","width","height","prevWidth","prevHeight","prevOrigin","value","unit","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","direction","indexes","getPosesByDirection","poses","getPosByDirection","nextPoses","getPosByReverseDirection","caculatePoses","startPos","getNextMatrix","getAbsoluteMatrix","scaleMatrix","state","getScaleDist","fixedPosition","groupable","nextMatrix","groupLeft","groupTop","dist","getDist","getResizeDist","nextOrigin","getStartDirection","baseDirection","getAbsoluteFixedPosition","getAbsolutePosesByState","multiply2","prefix","classNames","prefixNames","createIdentityMatrix3","getTransformMatrix","transform","isObject","splitBracket","parseFloat","measureSVGSize","el","isHorizontal","viewBox","getSVGViewBox","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","style","getOffsetInfo","lastParent","isParent","body","document","isEnd","position","isStatic","offsetParent","getOffsetPosInfo","container","isFixed","tagName","offsetLeft","offsetTop","containerClientRect","isSVG","isUndefined","hasOffset","targetOrigin","offset","getMatrixStackInfo","prevMatrix","offsetContainer","matrixesLength","offsetPos","getSVGMatrix","isOffsetEnd","parentClientLeft","parentClientTop","targetTransformOrigin","caculateMatrixStack","rootContainer","prevRootMatrix","prevN","prevTargetMatrix","rootMatrixes","isRoot3d","isSVGGraphicElement","originalContainer","allMatrix","rootMatrix","endContainer","isMatrix3d","makeMatrixCSS","clientWidth","clientHeight","baseVal","y","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","translate","xAlign","yAlign","scaleDimension","getSVGGraphicsOffset","bbox","caculatePosition","getRect","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","mat","_c","prevLeft","prevTop","posOrigin","rectOrigin","count","mat2","_d","nextLeft","nextTop","distLeft","distTop","caculateMoveablePosition","_e","x4","y4","_f","originX","originY","center","pos1Rad","pos2Rad","getDistSize","vec","getDiagonalSize","getLineStyle","getControlTransform","rotation","prev","getCSSSize","window","getSize","isOffset","isBoxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","moveableElement","parentContainer","beforeDirection","targetTransform","beforeOrigin","targetClientRect","resetClientRect","moveableClientRect","beforePos","getClientRect","pos4","clientLeft","clientTop","scrollWidth","scrollHeight","isExtends","getDirection","direciton","dir","getAbsolutePoses","roundSign","num","throttle","throttleArray","unset","self","name","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","sign","fillParams","params","nextParams","clientX","clientY","inputEvent","currentTarget","fillEndParams","isDrag","lastEvent","isDouble","triggerEvent","isManager","MoveableManager","pseudoElt","filterAbles","ables","methods","triggerAblesSimultaneously","enabledAbles","ableGroups","able","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","selectValue","values","groupBy","arr","func","groups","groupKeys","groupKey","keyIndex","group","groupByMap","flat","maxOffset","args","minOffset","caculateInversePosition","convertDragDist","caculatePadding","checkSize","targetSize","compareSize","isMax","caculateBoundSize","minSize","maxSize","keepRatio","minWidth","minHeight","maxWidth","maxHeight","getUnitSize","convertCSSSize","isRelative","moveControlPos","controlPoses","index","horizontal","vertical","sub","isVertical","dirDir","dirHorizontal","dirVertical","controlPos","caculatePointerDist","posX","posY","getTinyDist","triggerRenderStart","isGroup","isPinch","eventAffix","triggerRender","triggerRenderEnd","triggerAble","ableType","eventOperation","eventType","requestInstant","isStart","eventName","conditionName","isAfter","isFirstStart","requestAble_1","events","renderDatas","renderEvent","originalDatas","results","hasCondition","ableName","nextDatas","isUpdate","childeMoveable","getTargetAbleDragger","moveableTarget","controlBox","targets","startFunc","eventTarget","areaElement","getAbleDragger","dragstart","pinchstart","conditionFunctions","pinchOutside","pinchThreshold","options","updateRect","props","pinchable","Boolean","onPinchStart","onPinch","onPinchEnd","onPinchGroupStart","onPinchGroup","onPinchGroupEnd","pinchStart","angle","controlEventName","pinchAbles","ableEvent","parentRotate","request","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","setCustomDrag","delta","isConvert","draggableDatas","parentEvent","draggable","type","client","deltaX","deltaY","parentDragger","triggerChildDragger","childs","childEvent","child","parentFlag","triggerChildAble","eachEvent","callback","ableDatas","childDatas","isFunction","directionCondition","hasClass","obj","nextObj","getGapGuidelines","guidelines","snapThreshold","start","end","otherStart","otherEnd","totalGuidelines","otherIndex","otherType","elementGuidelines","guidelineType","element","sizes","elementStart","guideline1","elementEnd","guideline2Pos","guideline2Sizes","guideline2Element","targetStart","targetEnd","gap","canSnap","gapGuidelines","centerPos","getTotalGuidelines","containerHeight","containerWidth","verticalGuidelines","horizontalGuidelines","_g","snapHorizontal","snapVertical","checkSnapPoses","snapCenter","customSnapThreshold","checkSnap","checkSnapKeepRatio","endPos","endX","endY","startX","startY","dx","dy","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","b","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","getNearestSnapGuidelineInfo","snapInfo","guideline","posInfo","guidelineInfo","posInfos","targetType","posType","snapPosInfos","guidelineInfos","targetPos","snapPosInfo","getSnapInfosByDirection","snapDirection","alignPoses","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","aDist","bDist","cx","line","cy","dot","test1","test2","error","centerSign","hitTestLine","dots","threshold","isBound","bounds","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","isHorizontalStart","isVerticalStart","isSameStartLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","verticalOffset","horizontalOffset","dot1","dot2","boundDot1","boundLine","boundDot2","dy1","dx1","dy2","dx2","isRender","checkInnerBoundDot","getInnerBoundInfo","lines","multiple","sizeOffset","getInnerBoundDragInfo","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","lineDirections","getCheckSnapLines","dir1","dir2","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","isBoundRotate","dotInfos","lineRad","solveReverseLine","lineDist","getDistPointLine","dotDist","dotRad","distRad","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","innerBounds","horizontalPoses","verticalPoses","boundMap","checkBoundPoses","checkBound","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","relativePoses","boundRect","boundRotate","boundPos","r","checkRotateBounds","relativeRad1","caculateContainerPos","containerRect","clientPos","snapStart","containerLeft","containerTop","targetLeft","targetTop","elementLeft","elementTop","elementRight","elementBottom","hasGuidelines","snappable","enableSnap","solveEquation","widthOffset","heightOffset","boundInfo","checkSnapBoundsKeepRatio","isRequest","horizontalBoundInfo","verticalBoundInfo","getSnapBoundOffset","horizontalDist","verticalDist","checkSnapBounds","boundPoses","getSnapBound","normalized","checkMaxBounds","fixedPos","fixedDirection","directions","isCheckVertical","otherDirection","isCheckHorizontal","otherPos","verticalDirection","horizontalDirection","deg","nextOtherPos","startDirection","endDirection","otherStartPos","otherEndPos","snapBoundInfo","otherHorizontalDist","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalDist","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","getCheckSnapDirections","getSizeOffsetInfo","getSnapBoundInfo","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapSize","getNextFixedPoses","checkSnapScale","sizeDist","snapOffset","startCheckSnapDrag","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapDrag","snapPoses","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","relativePos","elementPos","groupInfos","groupInfo","find","groupElement","groupPos","getElementGuidelineDist","directionName","posName1","posName2","sizeName","isFirstRenderSize","linePos","lineSize","isRenderSize","snapSize","isDisplaySnapDigit","className","snapDistFormat","key","absGap","guidelinePos","targetSizes","gapPos","aPos","bPos","gapSizes","renderPos","gapGuideline","getGapGuidelinesToStart","getGapGuidelinesToEnd","verticalBoundPos","horizontalBoundPos","verticalSnapPoses","horizontalSnapPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","innerPos","snapElement","snapGap","snapDigit","Function","onSnap","css","render","snapRenderInfo","minLeft","minTop","containerPos","_h","snapInfos","verticalPosInfos","horizontalPosInfos","getSnapGuidelines","addBoundGuidelines","elementHorizontalGroup","groupByElementGuidelines","elementVerticalGroup","gapVerticalGuidelines","gapHorizontalGuidelines","allGuidelines","elements","gaps","renderGapGuidelines","renderElementGroup","renderSnapPoses","renderGuidelines","dragStart","snap","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlStart","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","throttleDrag","startDragRotate","Number","onDragStart","onDrag","onDragEnd","onDragGroupStart","onDragGroup","onDragGroupEnd","dragInfo","dragger","set","startRect","drag","prevDist","prevBeforeDist","startTranslate","parentMoveable","dragRotateRad","ry","rx","beforeTranslate","beforeDist","beforeDelta","nextTransform","dragGroup","passDeltaX","passDeltaY","isControl","requestStart","requestEnd","startAbsoluteOrigin","prevDeg","startRotate","prevSnapDeg","startDeg","prevLoop","loop","absolutePrevSnapDeg","absoluteDeg","getDeg","getPositions","rotationPosition","radPoses","isReverse","canPinch","rotatable","throttleRotate","onRotateStart","onRotate","onRotateEnd","onRotateGroupStart","onRotateGroup","onRotateGroupEnd","renderPoses","rotationRad","externalRotate","controlRect","setRotateStartInfo","dragControl","beforeInfo","afterInfo","isRotate","parentDist","beforeRotate","dragGroupControlCondition","parentLeft","parentTop","parentBeforeOrigin","childClient","eventParams","Draggable","dragGroupControl","prevX","prevY","dragResult","distRotate","startRotation","renderControls","defaultDirections","React","directionMap","directionRotation","renderAllDirections","renderDiagonalDirections","ableGroup","resizable","throttleResize","renderDirections","onResizeStart","onResize","onResizeEnd","onResizeGroupStart","onResizeGroup","onResizeGroupEnd","edge","parentDirection","padding","isString","startWidth","startHeight","setMin","setMax","setOrigin","parentScale","parentKeepRatio","dragClient","isResize","startOffsetWidth","startOffsetHeight","sizeDirection","distWidth","distHeight","standardRad","ratioRad","signSize","snapDist","isNoSnap","inverseDelta","offsetWidth","offsetHeight","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","scalable","throttleScale","onScaleStart","onScale","onScaleEnd","onScaleGroupStart","onScaleGroup","onScaleGroupEnd","isScale","startScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","moveableScale","rad1","rad2","getTriangleRad","poses1","poses2","pi","warpable","Array","onWarpStart","onWarp","onWarpEnd","linePosFrom1","getMiddleLinePos","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","inputTarget","targetInverseMatrix","isWarp","startMatrix","posIndexes","absolutePoses","selectedPoses","AREA","AREA_PIECES","AREA_PIECE","AVOID","removeClass","dragArea","onClick","onClickGroup","ref","renderPieces","rects","children","addClass","restoreStyle","isDragArea","containsTarget","isTarget","prevInputTarget","findIndex","parentTarget","scrollContainer","scrollable","scrollThreshold","getScrollPosition","onScroll","onScrollGroup","dragScroll","draggerName","checkScroll","ev","dragGroupContro","dragGroupControEnd","dragTarget","zoom","checkInput","cspNonce","String","onRenderStart","onRender","onRenderEnd","onRenderGroupStart","onRenderGroup","onRenderGroupEnd","Object","paddingDirections","paddingPos1","paddingPos2","paddingPos3","paddingPos4","RADIUS_DIRECTIONS","sumSize","sumRatio","HORIZONTAL_RADIUS_ORDER","VERTICAL_RADIUS_ORDER","HORIZONTAL_RADIUS_DIRECTIONS","VERTICAL_RADIUS_DIRECTIONS","getRadiusStyles","clipStyles","raws","rawPos","styles","getRadiusRange","horizontalRange","verticalRange","clipPose","getRadiusValues","splitIndex","splitLength","horizontalValues","verticalValues","_j","_k","_l","_m","horizontalRawPoses","verticalRawPoses","nextHorizontalPoses","nextVerticalPoses","raw","removeRadiusPos","radiuslIndex","deleteCount","addRadiusPos","horizontalIndex","verticalIndex","radiusX","radiusY","startVerticalIndex","splitRadiusPoses","horizontals","verticals","CLIP_DIRECTIONS","CLIP_RECT_DIRECTIONS","clipRelative","clipType","clipPoses","isRect","isCircle","subWidth","subHeight","xs","ys","dirx","diry","clipText","clipPath","clipPrefix","splitter","splitComma","xPos","yPos","radiusX_1","radiusY_1","splitSpace","radius","xRadius","yRadius","centerPos_1","roundIndex","rectLength","radiusValues","topValue","_o","_p","nextRight","nextBottom","radiusPoses","getRectPoses","getClipStyles","clipEventType","clipStyle","clippable","defaultClipPath","customClipPath","clipArea","dragWithClip","onClipStart","onClip","onClipEnd","clipPathState","getClipPath","caculatedPos","controls","isInset","isPolygon","linePoses_1","from","clipLeft","clipTop","ellipseClipPath","piece","areaPoses","allWidth","allHeight","allLeft_1","allTop_1","parseInt","draggableData","isLine","isArea","isDragWithTarget","isAll","nextClipStyles","isClipStart","removeClipPath","addClipPath","originDraggable","originRelative","onDragOriginStart","onDragOrigin","onDragOriginEnd","distOrigin","nextRect","dragDelta","horizontalsLength","verticalsLength","lineIndex","borderRadius","roundable","roundRelative","onRoundStart","onRound","onRoundEnd","borderRadiusState","getBorderRadius","controlIndex","triggerRoundEvent","addBorderRadius","defaultGroupRotate","defaultGroupOrigin","refs","parentPosition","MOVEABLE_ABLES","MOVEABLE_EVENTS_PROPS_MAP","current","MOVEABLE_PROPS_MAP","MOVEABLE_EVENTS_MAP","MOVEABLE_EVENTS","MOVEABLE_PROPS","cssMap","ABLE_CSS","ControlBoxElement","styled","prefixCSS","tslib_1","_this","propsTarget","stateTarget","groupTargets","isDisplay","isDragging","ableAttributes","renderLine","clientRect","rectRight","rectBottom","testLeft","testRight","testTop","testBottom","rectSize","isSetState","controlBoxElement","hasTargetAble","hasControlAble","prevTarget","prevProps","prevDragArea","isTargetChanged","isUnset","statePos","param","requsetAble","ableRequester","isInstant","requester","requestAble","stateLeft","stateTop","stateContainer","isChanged","targetAbles","controlAbles","nextState","Renderer","createElement","moveables","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","getMaxPos","getMinPos","changedWidth","MoveableGroup","defaultProps","isContainerChanged","added","changed","removed","info","_super","withMethods","isArr","nextProps"],"mappings":"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","sourcesContent":["import getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableInterface } from \"./types\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    const defaultCursor\n        = degree45 === 135\n        ? \"nwse-resize\"\n        : degree45 === 45\n        ? \"nesw-resize\"\n        : degree45 === 90\n        ? \"ew-resize\"\n        : \"ns-resize\"; // 135\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent((((typeof navigator !== \"undefined\" && navigator) || {} as any).userAgent) || \"\");\nexport const IS_WEBKIT\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = `\n{\n\tposition: fixed;\n\twidth: 1px;\n\theight: 1px;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --zoom: 1;\n    --zoompx: 1px;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    width: calc(14 * var(--zoompx));\n    height: calc(14 * var(--zoompx));\n    margin-top: calc(-7 * var(--zoompx));\n    margin-left: calc(-7 * var(--zoompx));\n    border: calc(2 * var(--zoompx)) solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n    height: 1px;\n    width: var(--zoompx);\n    height: var(--zoompx);\n\tbackground: #4af;\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top: var(--zoompx) dashed #4af;\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left: var(--zoompx) dashed #4af;\n}\n.line.dashed:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #4af;\n    font-size: 12px;\n    font-weight: bold;\n}\n.line.dashed.horizontal:before, .line.gap.horizontal:before {\n    left: 50%;\n    transform: translateX(-50%);\n    bottom: 5px;\n}\n.line.dashed.vertical:before, .line.gap.vertical:before {\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.line.rotation-line {\n\theight: 40px;\n    width: 1px;\n    transform-origin: 50% calc(100% - 0.5px);\n    top: -40px;\n    width: var(--zoompx);\n    height: calc(40 * var(--zoompx));\n    top: calc(-40 * var(--zoompx));\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n    cursor: alias;\n    left: 50%;\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n    width: calc(2 * var(--zoompx));\n}\n.line.horizontal.bold {\n    height: 2px;\n    height: calc(2 * var(--zoompx));\n}\n\n.line.gap {\n    background: #f55;\n}\n.line.gap:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n    width: calc(12 * var(--zoompx));\n    height: calc(12 * var(--zoompx));\n    margin-top: calc(-6 * var(--zoompx));\n    margin-left: calc(-6 * var(--zoompx));\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n${IS_WEBKIT ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`;\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTIONS = [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"];\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n\nexport const MOVEABLE_METHODS: Array<keyof MoveableInterface> = [\n    \"isMoveableElement\",\n    \"updateRect\",\n    \"updateTarget\",\n    \"destroy\",\n    \"dragStart\",\n    \"isInside\",\n    \"hitTest\",\n    \"setState\",\n    \"getRect\",\n    \"request\",\n    \"isDragging\",\n];\n","function add(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        matrix[x] += matrix[fromX] * k;\n        inverseMatrix[x] += inverseMatrix[fromX] * k;\n    }\n}\n\nfunction swap(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        const v = matrix[x];\n        const iv = inverseMatrix[x];\n\n        matrix[x] = matrix[fromX];\n        matrix[fromX] = v;\n\n        inverseMatrix[x] = inverseMatrix[fromX];\n        inverseMatrix[fromX] = iv;\n    }\n}\n\nfunction divide(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n\n        matrix[x] /= k;\n        inverseMatrix[x] /= k;\n    }\n}\n\nexport function ignoreDimension(\n    matrix: number[],\n    m: number,\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n\n    for (let i = 0; i < n; ++i) {\n        newMatrix[i * n + m - 1] = 0;\n        newMatrix[(m - 1) * n + i] = 0;\n    }\n    newMatrix[(m - 1) * (n + 1)] = 1;\n\n    return newMatrix;\n}\n\nexport function invert(\n    matrix: number[],\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n    const inverseMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n; ++i) {\n        // diagonal\n        const identityIndex = n * i + i;\n\n        if (newMatrix[identityIndex] === 0) {\n            for (let j = i + 1; j < n; ++j) {\n                if (newMatrix[n * i + j]) {\n                    swap(newMatrix, inverseMatrix, i, j, n);\n                    break;\n                }\n            }\n        }\n        if (newMatrix[identityIndex]) {\n            divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n        } else {\n            // no inverse matrix\n            return [];\n        }\n        for (let j = 0; j < n; ++j) {\n            const targetStartIndex = j;\n            const targetIndex = j + i * n;\n            const target = newMatrix[targetIndex];\n\n            if (target === 0 || i === j) {\n                continue;\n            }\n            add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n        }\n    }\n\n    return inverseMatrix;\n}\n\nexport function transpose(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            newMatrix[j * n + i] = matrix[n * i + j];\n        }\n    }\n    return newMatrix;\n}\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getOrigin(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const originMatrix: number[] = [];\n\n    for (let i = 0; i < n - 1; ++i) {\n        originMatrix[i] = matrix[n * (n - 1) + i];\n    }\n    originMatrix[n - 1] = 0;\n    return originMatrix;\n}\n\nexport function convertPositionMatrix(matrix: number[], n: number) {\n    const newMatrix = matrix.slice();\n\n    for (let i = matrix.length; i < n - 1; ++i) {\n        newMatrix[i] = 0;\n    }\n    newMatrix[n - 1] = 1;\n    return newMatrix;\n}\n\nexport function convertDimension(matrix: number[], n: number = Math.sqrt(matrix.length), m: number) {\n    // n < m\n    if (n === m) {\n        return matrix;\n    }\n    const newMatrix = createIdentityMatrix(m);\n\n    const length = Math.min(n, m);\n    for (let i = 0; i < length - 1; ++i) {\n        for (let j = 0; j < length - 1; ++j) {\n            newMatrix[i * m + j] = matrix[i * n + j];\n        }\n\n        newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n        newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n    }\n    newMatrix[m * m - 1] = matrix[n * n - 1];\n\n    return newMatrix;\n}\n\nexport function multiplies(n: number, ...matrixes: number[][]) {\n    let m: number[] = createIdentityMatrix(n);\n\n    matrixes.forEach(matrix => {\n        m = multiply(m, matrix, n);\n    });\n    return m;\n}\n\nexport function multiply(matrix: number[], matrix2: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n    // 1 y: n\n    // 1 x: m\n    // 2 x: m\n    // 2 y: k\n    // n * m X m * k\n    const m = matrix.length / n;\n    const k = matrix2.length / m;\n\n    if (!m) {\n        return matrix2;\n    } else if (!k) {\n        return matrix;\n    }\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < k; ++j) {\n            newMatrix[j * n + i] = 0;\n            for (let l = 0; l < m; ++l) {\n                // m1 x: m(l), y: n(i)\n                // m2 x: k(j):  y: m(l)\n                // nw x: n(i), y: k(j)\n                newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n            }\n        }\n    }\n    // n * k\n    return newMatrix;\n}\n\nexport function sum(...nums: number[]) {\n    const length = nums.length;\n    let total = 0;\n\n    for (let i = length - 1; i >= 0; --i) {\n        total += nums[i];\n    }\n    return total;\n}\nexport function average(...nums: number[]) {\n    const length = nums.length;\n    let total = 0;\n\n    for (let i = length - 1; i >= 0; --i) {\n        total += nums[i];\n    }\n    return length ? total / length : 0;\n}\nexport function plus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] + pos2[i];\n    }\n    return nextPos;\n}\n\nexport function minus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] - pos2[i];\n    }\n    return nextPos;\n}\n\nexport function convertCSStoMatrix(a: number[], is2d: boolean = a.length === 6) {\n    if (is2d) {\n        return [\n            a[0], a[1], 0,\n            a[2], a[3], 0,\n            a[4], a[5], 1,\n        ];\n    }\n    return a;\n}\nexport function convertMatrixtoCSS(a: number[], is2d: boolean = a.length === 9) {\n    if (is2d) {\n        return [\n            a[0], a[1],\n            a[3], a[4],\n            a[6], a[7],\n        ];\n    }\n    return a;\n}\n\nexport function caculate(matrix: number[], matrix2: number[], n: number = matrix2.length) {\n    const result = multiply(matrix, matrix2, n);\n    const k = result[n - 1];\n    return result.map(v => v / k);\n}\n\nexport function rotate(pos: number[], rad: number) {\n    return caculate(\n        createRotateMatrix(rad, 3),\n        convertPositionMatrix(pos, 3),\n    );\n}\n\nexport function createRotateMatrix(rad: number, n: number) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    const m = createIdentityMatrix(n);\n\n    // cos -sin\n    // sin cos\n    m[0] = cos;\n    m[1] = sin;\n    m[n] = -sin;\n    m[n + 1] = cos;\n\n    return m;\n}\n\nexport function createIdentityMatrix(n: number) {\n    const length = n * n;\n    const matrix: number[] = [];\n\n    for (let i = 0; i < length; ++i) {\n        matrix[i] = i % (n + 1) ? 0 : 1;\n    }\n    return matrix;\n}\nexport function createScaleMatrix(scale: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(scale.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[(n + 1) * i] = scale[i];\n    }\n    return m;\n}\nexport function createOriginMatrix(origin: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(origin.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[n * (n - 1) + i] = origin[i];\n    }\n    return m;\n}\n\nexport function createWarpMatrix(\n    pos0: number[],\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    nextPos0: number[],\n    nextPos1: number[],\n    nextPos2: number[],\n    nextPos3: number[],\n) {\n    const [x0, y0] = pos0;\n    const [x1, y1] = pos1;\n    const [x2, y2] = pos2;\n    const [x3, y3] = pos3;\n\n    const [u0, v0] = nextPos0;\n    const [u1, v1] = nextPos1;\n    const [u2, v2] = nextPos2;\n    const [u3, v3] = nextPos3;\n\n    const matrix = [\n        x0, 0, x1, 0, x2, 0, x3, 0,\n        y0, 0, y1, 0, y2, 0, y3, 0,\n        1, 0, 1, 0, 1, 0, 1, 0,\n        0, x0, 0, x1, 0, x2, 0, x3,\n        0, y0, 0, y1, 0, y2, 0, y3,\n        0, 1, 0, 1, 0, 1, 0, 1,\n        -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3,\n        -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3,\n    ];\n    const inverseMatrix = invert(matrix, 8);\n\n    if (!inverseMatrix.length) {\n        return [];\n    }\n    const h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n\n    h[8] = 1;\n    return convertDimension(transpose(h), 3, 4);\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"./matrix\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, ResizableProps, MoveableManagerInterface } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManagerInterface<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\n\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    const nextPoses = getPosesByDirection(poses, direction);\n\n    return [\n        average(...nextPoses.map(pos => pos[0])),\n        average(...nextPoses.map(pos => pos[1])),\n    ];\n}\nexport function getPosByReverseDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection(poses, direction.map(dir => -dir));\n}\n\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManagerInterface<any>,\n    scale: number[],\n    direction: number[],\n    fixedPosition: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManagerInterface<any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    if (!direction[0] && !direction[1]) {\n        return [0, 0];\n    }\n    const baseDirection = [-1, -1];\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getAbsoluteFixedPosition(\n    moveable: MoveableManagerInterface<ResizableProps>,\n    direction: number[],\n) {\n    return getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { PREFIX, IS_WEBKIT, TINY_NUM } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n    ignoreDimension,\n    convertCSStoMatrix,\n    convertMatrixtoCSS,\n} from \"./matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport {\n    MoveableManagerState, Able, MoveableClientRect,\n    MoveableProps, ControlPose, MoveableManagerInterface\n} from \"./types\";\nimport { getDragDist } from \"./DraggerUtils\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = getSVGViewBox(el.ownerSVGElement!);\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    container: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration,\n    isFixed: boolean,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    if (isFixed) {\n        const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n        offsetLeft -= containerClientRect.left;\n        offsetTop -= containerClientRect.top;\n    }\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    let targetOrigin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        targetOrigin = origin.slice();\n        hasOffset = true;\n\n        if (tagName === \"g\") {\n            offsetLeft = 0;\n            offsetTop = 0;\n        } else {\n            [\n                offsetLeft, offsetTop, origin[0], origin[1],\n            ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n        }\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n        targetOrigin = origin.slice();\n    }\n    return {\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft, offsetTop],\n        origin,\n        targetOrigin,\n    };\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetTransformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        isEnd = target === container;\n        if (prevMatrix.length > 10) {\n            is3d = true;\n            n = 4;\n        }\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(style.transform!));\n\n        // convert 3 to 4\n        const length = matrix.length;\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d && length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            hasOffset,\n            isSVG,\n            origin,\n            targetOrigin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, container, style, isFixed);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                // scale matrix for svg's SVGElements.\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (IS_WEBKIT && hasOffset && !isSVG && isStatic && (position === \"relative\" || position === \"static\")) {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (hasOffset && offsetContainer !== offsetParent) {\n            // border\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            // absolute matrix\n            getAbsoluteMatrix(matrix, n, origin),\n            // offset matrix (offsetPos + clientPos(border))\n            createOriginMatrix(hasOffset ? [\n                offsetLeft - el.scrollLeft + parentClientLeft,\n                offsetTop - el.scrollTop + parentClientTop,\n            ] : [el, origin] as any, n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (!targetTransformOrigin) {\n            targetTransformOrigin = targetOrigin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    if (!targetTransformOrigin) {\n        targetTransformOrigin = [0, 0];\n    }\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        targetTransformOrigin,\n        is3d,\n    };\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevRootMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], number[], string, number[], number[], boolean] {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        targetTransformOrigin,\n        offsetContainer,\n    } = getMatrixStackInfo(target, container, prevMatrix);\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix);\n\n    const n = isRoot3d || is3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    const originalContainer = container || document.body;\n    let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let targetMatrix = prevTargetMatrix;\n    let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isRoot3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n        matrixes.forEach((matrix, i) => {\n            matrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n    if (is3d && !isRoot3d) {\n        rootMatrixes.forEach((matrix, i) => {\n            rootMatrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    if (!prevRootMatrix) {\n        rootMatrixes.forEach(matrix => {\n            rootMatrix = multiply(rootMatrix, matrix, n);\n        });\n    }\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // caculate for SVGElement\n        if (isObject(matrix[n * (n - 1)])) {\n            [matrix[n * (n - 1)], matrix[n * (n - 1) + 1]] =\n                getSVGOffset(\n                    matrix[n * (n - 1)] as any,\n                    endContainer,\n                    n,\n                    matrix[n * (n - 1) + 1] as any,\n                    allMatrix,\n                    matrixes[i + 1],\n                );\n        }\n        allMatrix = multiply(allMatrix, matrix, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const transform = makeMatrixCSS(\n        isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix,\n        isMatrix3d,\n    );\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n    return [\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        transform,\n        transformOrigin,\n        targetTransformOrigin,\n        is3d || isRoot3d,\n    ];\n}\nexport function makeMatrixCSS(matrix: number[], is3d: boolean = matrix.length > 9) {\n    return `${is3d ? \"matrix3d\" : \"matrix\"}(${convertMatrixtoCSS(matrix, !is3d).join(\",\")})`;\n}\nexport function getSVGViewBox(el: SVGSVGElement) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = el.viewBox;\n    const baseVal = (viewBox && viewBox.baseVal) || { x: 0, y: 0, width: 0, height: 0 };\n\n    return {\n        x: baseVal.x,\n        y: baseVal.y,\n        width: baseVal.width || clientWidth,\n        height: baseVal.height || clientHeight,\n    };\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const {\n        width: viewBoxWidth,\n        height: viewBoxHeight,\n    } = getSVGViewBox(el);\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = el.preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n * (n - 1)],\n        scaleMatrix[n * (n - 1) + 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const viewBox = getSVGViewBox(el.ownerSVGElement!);\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    return [[0, 0], [width, 0], [0, height], [width, height]].map(pos => caculatePosition(matrix, pos, n));\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el, undefined, true);\n    const containerClientRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0);\n    const rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0);\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[][],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [[x1, y1], [x2, y2], [x3, y3], [x4, y4]],\n        direction,\n    ];\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    if (!hasOffset && target.tagName.toLowerCase() !== \"svg\") {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n        return [bbox.width, bbox.height];\n    }\n\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    moveableElement?: HTMLElement,\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let poses = [[0, 0], [0, 0], [0, 0], [0, 0]];\n    let rootMatrix = createIdentityMatrix3();\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let moveableClientRect = resetClientRect();\n    let targetOrigin = [0, 0];\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevRootMatrix = state ? state.rootMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            rootMatrix,\n            beforeMatrix,\n            offsetMatrix,\n            matrix,\n            targetMatrix,\n            targetTransform,\n            transformOrigin,\n            targetOrigin,\n            is3d,\n        ] = caculateMatrixStack(\n            target, container!, rootContainer!,\n            prevMatrix, prevRootMatrix, prevN,\n        );\n\n        [\n            [left, top, right, bottom],\n            origin,\n            poses,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n            true,\n        );\n        if (moveableElement) {\n            moveableClientRect = getClientRect(moveableElement);\n        }\n        rotation = getRotationRad([poses[0], poses[1]], direction);\n    }\n\n    return {\n        rotation,\n        targetClientRect,\n        containerClientRect,\n        moveableClientRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1: poses[0],\n        pos2: poses[1],\n        pos3: poses[2],\n        pos4: poses[3],\n        width,\n        height,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        targetMatrix,\n        matrix,\n        targetTransform,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n        targetOrigin,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, right: 0,\n        top: 0, bottom: 0,\n        width: 0, height: 0,\n        clientLeft: 0, clientTop: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    const rect: MoveableClientRect = {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n\n    if (isExtends) {\n        rect.clientLeft = el.clientLeft;\n        rect.clientTop = el.clientTop;\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos3);\n    const k3 = getOrientationDirection(pos, pos3, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos3);\n    const k5 = getOrientationDirection(pos, pos3, pos4);\n    const k6 = getOrientationDirection(pos, pos4, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    const nextParams = {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n\n    if (datas.isStartEvent) {\n        datas.lastEvent = nextParams;\n    } else {\n        datas.isStartEvent = true;\n    }\n    return nextParams;\n}\nexport function fillEndParams<T extends IObject<any>>(\n    moveable: any,\n    e: any,\n    params: Pick<T, Exclude<\n        keyof T,\n        \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" |\n        \"datas\" | \"currentTarget\" | \"lastEvent\" | \"isDrag\" | \"isDouble\">\n    > & { isDrag?: boolean },\n): T {\n    const datas = e.datas;\n    const isDrag = \"isDrag\" in params ? params.isDrag : e.isDrag;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n\n    return {\n        isDrag,\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        lastEvent: datas.lastEvent,\n        isDouble: e.isDouble,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any> = MoveableProps, U extends keyof T = string>(\n    moveable: any,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : IObject<any>,\n    isManager?: boolean,\n): any {\n    if (isManager) {\n        MoveableManager.prototype.triggerEvent.call(moveable, name, params);\n    }\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(\n    ables: Able[], methods: Array<keyof Able>,\n    triggerAblesSimultaneously?: boolean,\n) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (!triggerAblesSimultaneously && able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => any) {\n    const groups: T[][] = [];\n    const groupKeys: any[] = [];\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        const keyIndex = groupKeys.indexOf(groupKey);\n        const group = groups[keyIndex] || [];\n\n        if (keyIndex === -1) {\n            groupKeys.push(groupKey);\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function groupByMap<T>(arr: T[], func: (el: T, index: number, arr: T[]) => string | number) {\n    const groups: T[][] = [];\n    const groupKeys: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n        let group = groupKeys[groupKey];\n\n        if (!group) {\n            group = [];\n            groupKeys[groupKey] = group;\n            groups.push(group);\n        }\n        group.push(el);\n    });\n    return groups;\n}\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function minOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function caculateInversePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(\n        invert(matrix, n),\n        convertPositionMatrix(pos, n),\n        n,\n    );\n}\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = caculateInversePosition(rootMatrix, [e.distX, e.distY], n);\n\n    return e;\n}\n\nexport function caculatePadding(\n    matrix: number[], pos: number[],\n    transformOrigin: number[], origin: number[], n: number,\n) {\n    return minus(caculatePosition(matrix, plus(transformOrigin, pos), n), origin);\n}\nexport function checkSize(targetSize: number[], compareSize: number[], isMax: boolean) {\n    return [\n        [compareSize[0], compareSize[0] * targetSize[1] / targetSize[0]],\n        [compareSize[1] * targetSize[0] / targetSize[1], compareSize[1]],\n    ].filter(size => size.every((value, i) => {\n        return isMax ? value <= compareSize[i] : value >= compareSize[i];\n    }))[0] || targetSize;\n}\nexport function caculateBoundSize(\n    size: number[], minSize: number[],\n    maxSize: number[], keepRatio?: boolean,\n) {\n    if (!keepRatio) {\n        return size.map((value, i) => Math.min(maxSize[i], Math.max(value, minSize[i])));\n    }\n    let [width, height] = size;\n    // width : height = minWidth : minHeight;\n    const [minWidth, minHeight] = checkSize(size, minSize, false);\n    const [maxWidth, maxHeight] = checkSize(size, maxSize, true);\n\n    if (width < minWidth || height < minHeight) {\n        width = minWidth;\n        height = minHeight;\n    } else if (width > maxWidth || height > maxHeight) {\n        width = maxWidth;\n        height = maxHeight;\n    }\n    return [width, height];\n}\n\nexport function getUnitSize(pos: string, size: number) {\n    const { value, unit } = splitUnit(pos);\n\n    return unit === \"%\" ? value * size / 100 : value;\n}\n\nexport function convertCSSSize(value: number, size: number, isRelative?: boolean) {\n    return isRelative ? `${value / size * 100}%` : `${value}px`;\n}\n\nexport function moveControlPos(\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n    index: number,\n    distX: number,\n    distY: number,\n) {\n    const { direction, pos, horizontal, vertical, sub } = controlPoses[index];\n    const dist = [\n        distX * Math.abs(horizontal),\n        distY * Math.abs(vertical),\n    ];\n    if (direction && !sub) {\n        direction.split(\"\").forEach(dir => {\n            const isVertical = dir === \"n\" || dir === \"s\";\n\n            controlPoses.forEach((controlPose, i) => {\n                const {\n                    direction: dirDir,\n                    horizontal: dirHorizontal,\n                    vertical: dirVertical,\n                    pos: controlPos,\n                } = controlPose;\n\n                if (!dirDir || dirDir.indexOf(dir) === -1) {\n                    return;\n                }\n                nextPoses[i] = plus(controlPos, [\n                    isVertical || !dirHorizontal ? 0 : dist[0],\n                    !isVertical || !dirVertical ? 0 : dist[1],\n                ]);\n            });\n        });\n    } else {\n        nextPoses[index] = plus(pos, dist);\n    }\n}\n\nexport function caculatePointerDist(moveable: MoveableManagerInterface, e: any) {\n    const { clientX, clientY, datas } = e;\n    const {\n        moveableClientRect,\n        rootMatrix,\n        is3d,\n        pos1,\n    } = moveable.state;\n    const { left, top } = moveableClientRect;\n    const n = is3d ? 4 : 3;\n    const [posX, posY] = minus(caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1);\n    const [distX, distY] = getDragDist({ datas, distX: posX, distY: posY });\n\n    return [distX, distY];\n}\n\nexport function getTinyDist(v: number) {\n    return  Math.abs(v) <= TINY_NUM ? 0 : v;\n}\n","import { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\nimport { MoveableManagerInterface } from \"../types\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManagerInterface<any, any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent<any>(moveable, `onRender${eventAffix}End`, params);\n}\n","import { Able, MoveableManagerInterface, MoveableGroupInterface } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\nimport { convertDragDist } from \"./utils\";\nimport Dragger from \"@daybrush/drag\";\n\nexport function triggerAble<T extends IObject<any>>(\n    moveable: MoveableManagerInterface<any, any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    requestInstant?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n    const target = moveable.state.target;\n\n    if (\n        !target\n        || (isStart && eventAffix.indexOf(\"Control\") > -1\n            && !e.isRequest && moveable.areaElement === e.inputEvent.target)\n    ) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n    const isFirstStart = isStart && (\n        !moveable.targetDragger || !moveable.controlDragger\n        || (!moveable.targetDragger.isFlag() || !moveable.controlDragger.isFlag())\n    );\n\n    if (isFirstStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isAfter) {\n        convertDragDist(moveable.state, e);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Able[] = (moveable as any)[ableType].slice();\n\n    if (e.isRequest) {\n        const requestAble = e.requestAble;\n        if (!ables.some(able => able.name === requestAble)) {\n            ables.push(...moveable.props.ables!.filter(able => able.name === requestAble));\n        }\n    }\n\n    if (!ables.length) {\n        return false;\n    }\n    const events = ables.filter((able: any) => able[eventName]);\n    const datas = e.datas;\n    const renderDatas = datas.render || (datas.render = {});\n    const renderEvent = { ...e, datas: renderDatas, originalDatas: datas };\n\n    if (isFirstStart) {\n        events.forEach(able => {\n            able.unset && able.unset(moveable);\n        });\n    }\n    const results = events.filter((able: any) => {\n        const hasCondition = isStart && able[conditionName];\n        const ableName = able.name;\n        const nextDatas = datas[ableName] || (datas[ableName] = {});\n\n        if (!hasCondition || able[conditionName](e, moveable)) {\n            return able[eventName](moveable, { ...e, datas: nextDatas, originalDatas: datas });\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        if (events.length && !isUpdate) {\n            moveable.state.dragger = null;\n\n            if ((moveable as MoveableGroupInterface).moveables) {\n                (moveable as MoveableGroupInterface).moveables.forEach(childeMoveable => {\n                    childeMoveable.state.dragger = null;\n                });\n            }\n\n            return false;\n        }\n        triggerRenderStart(moveable, isGroup, renderEvent);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, renderEvent);\n    } else if (!isAfter || isUpdate) {\n        triggerRender(moveable, isGroup, renderEvent);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (moveable.isUnmounted) {\n        return false;\n    }\n    if ((!isStart && isUpdate && !requestInstant) || isEnd) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\n\nexport function getTargetAbleDragger<T>(\n    moveable: MoveableManagerInterface<T>,\n    moveableTarget: HTMLElement | SVGElement,\n    eventAffix: string,\n) {\n    const controlBox = moveable.controlBox.getElement();\n    const targets: Array<HTMLElement | SVGElement> = [];\n\n    targets.push(controlBox);\n\n    if (!moveable.props.dragArea) {\n        targets.push(moveableTarget);\n    }\n\n    const startFunc = (e: any) => {\n        const eventTarget = e.inputEvent.target;\n        const areaElement = moveable.areaElement;\n\n        return eventTarget === areaElement\n            || !moveable.isMoveableElement(eventTarget)\n            || eventTarget.className.indexOf(\"moveable-area\") > -1\n            || eventTarget.className.indexOf(\"moveable-padding\") > -1;\n    };\n\n    return getAbleDragger(moveable, targets, \"targetAbles\", eventAffix, {\n        dragstart: startFunc,\n        pinchstart: startFunc,\n    });\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManagerInterface<T>,\n    target: HTMLElement | SVGElement | Array<HTMLElement | SVGElement>,\n    ableType: string,\n    eventAffix: string,\n    conditionFunctions: IObject<any> = {},\n) {\n    const {\n        pinchOutside,\n        pinchThreshold,\n    } = moveable.props;\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold,\n        pinchOutside,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            const eventName = `${eventOperation}${eventType.toLowerCase()}`;\n            options[eventName]\n                = (e: any) => {\n                    if (conditionFunctions[eventName] && !conditionFunctions[eventName](e)) {\n                        return false;\n                    }\n                    return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n                };\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import { triggerEvent, fillParams, fillEndParams } from \"../utils\";\nimport {\n    PinchableProps, Able, SnappableState,\n    OnPinchStart, OnPinch, OnPinchEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\n\n/**\n * @namespace Moveable.Pinchable\n * @description Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n */\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    props: {\n        pinchable: Boolean,\n    } as const,\n    events: {\n        onPinchStart: \"pinchStart\",\n        onPinch: \"pinch\",\n        onPinchEnd: \"pinchEnd\",\n        onPinchGroupStart: \"pinchGroupStart\",\n        onPinchGroup: \"pinchGroup\",\n        onPinchGroupEnd: \"pinchGroupEnd\",\n    } as const,\n    pinchStart(\n        moveable: MoveableManagerInterface<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, targets, angle } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n\n            if (!able[controlEventName]) {\n                return;\n            }\n            const ableEvent: any = {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                parentRotate: angle,\n                isPinch: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const {\n            datas, scale: pinchScale, distance,\n            inputEvent, targets,\n            angle,\n        } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate: angle,\n                isPinch: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManagerInterface<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillEndParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            if (!able[controlEventName]) {\n                return;\n            }\n            able[controlEventName]!(moveable, {\n                ...e,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                isPinch: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be pinched with draggable, resizable, scalable, rotatable (default: false)\n * @name Moveable.Pinchable#pinchable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.pinchable = true;\n */\n\n/**\n * When the pinch starts, the pinchStart event is called with part of scaleStart, rotateStart, resizeStart\n * @memberof Moveable.Pinchable\n * @event pinchStart\n * @param {Moveable.Pinchable.OnPinchStart} - Parameters for the pinchStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When pinching, the pinch event is called with part of scale, rotate, resize\n * @memberof Moveable.Pinchable\n * @event pinch\n * @param {Moveable.Pinchable.OnPinch} - Parameters for the pinch event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinch\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotate\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scale\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When the pinch finishes, the pinchEnd event is called.\n * @memberof Moveable.Pinchable\n * @event pinchEnd\n * @param {Moveable.Pinchable.OnPinchEnd} - Parameters for the pinchEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     rotatable: true,\n *     scalable: true,\n *     pinchable: true, // [\"rotatable\", \"scalable\"]\n * });\n * moveable.on(\"pinchEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"rotateEnd\", ({ target }) => {\n *     console.log(target);\n * });\n * moveable.on(\"scaleEnd\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n * When the group pinch starts, the `pinchGroupStart` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupStart\n * @param {Moveable.Pinchable.OnPinchGroupStart} - Parameters for the `pinchGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupStart\", ({ targets }) => {\n *     console.log(\"onPinchGroupStart\", targets);\n * });\n */\n\n/**\n * When the group pinch, the `pinchGroup` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroup\n * @param {Moveable.Pinchable.OnPinchGroup} - Parameters for the `pinchGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroup\", ({ targets, events }) => {\n *     console.log(\"onPinchGroup\", targets);\n * });\n */\n\n/**\n * When the group pinch finishes, the `pinchGroupEnd` event is called.\n * @memberof Moveable.Pinchable\n * @event pinchGroupEnd\n * @param {Moveable.Pinchable.OnPinchGroupEnd} - Parameters for the `pinchGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     pinchable: true\n * });\n * moveable.on(\"pinchGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onPinchGroupEnd\", targets, isDrag);\n * });\n */\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\nimport { convertDragDist } from \"./utils\";\n\nexport function setCustomDrag(\n    state: MoveableManagerState<any>,\n    delta: number[],\n    inputEvent: any,\n    isPinch: boolean,\n    isConvert: boolean,\n) {\n    const result = state.dragger!.move(delta, inputEvent);\n    const datas = result.originalDatas || result.datas;\n    const draggableDatas = datas.draggable || (datas.draggable = {});\n\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        isDrag: true,\n        isPinch: !!isPinch,\n        parentEvent: true,\n        datas: draggableDatas,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas: any = {\n        draggable: {},\n    };\n\n    public dragStart(client: number[], inputEvent: any) {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {\n            draggable: {},\n        };\n        return {\n            ...this.move(client, inputEvent),\n            type: \"dragstart\",\n        };\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            type: \"drag\",\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas.draggable,\n            originalDatas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { Able, MoveableGroupInterface, MoveableManagerInterface } from \"./types\";\nimport { IObject, isFunction } from \"@daybrush/utils\";\nimport CustomDragger, { setCustomDrag } from \"./CustomDragger\";\nexport function triggerChildDragger(\n    moveable: MoveableGroupInterface<any, any>,\n    able: Able,\n    type: string,\n    delta: number[],\n    e: any,\n    isConvert: boolean,\n) {\n    const isStart = !!type.match(/Start$/g);\n    const isEnd = !!type.match(/End$/g);\n    const inputEvent = e.inputEvent;\n    const isPinch = e.isPinch;\n    const datas = e.datas;\n    const childs = moveable.moveables.map((child, i) => {\n        let childEvent = {};\n\n        if (isStart) {\n            childEvent = new CustomDragger().dragStart(delta, inputEvent);\n        } else {\n            if (!child.state.dragger) {\n                child.state.dragger = datas.childDraggers[i];\n            }\n            childEvent = setCustomDrag(child.state, delta, inputEvent, isPinch, isConvert);\n        }\n        const result = (able as any)[type]!(child,  { ...childEvent, parentFlag: true });\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n    if (isStart) {\n        datas.childDraggers = moveable.moveables.map(child => child.state.dragger);\n    }\n    return childs;\n}\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroupInterface<any, any>,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManagerInterface<any, any>, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManagerInterface<any, any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import { prefix } from \"../utils\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { InvertTypes } from \"../types\";\n\nexport function directionCondition(e: any) {\n    if (e.isRequest) {\n        if (e.requestAble === \"resizable\" || e.requestAble === \"scalable\") {\n            return e.parentDirection!;\n        } else {\n            return false;\n        }\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n\n// MatchTypes<typeof Draggable[\"props\"], AnyProps<DraggableOptions>>;\n// MatchTypes<typeof Resizable[\"events\"], DraggableEvents>;\nexport function invert<T extends IObject<any>>(obj: T): InvertTypes<T> {\n    const nextObj: IObject<any> = {};\n\n    for (const name in obj) {\n        nextObj[obj[name]] = name;\n    }\n    return nextObj as any;\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    Guideline, ResizableProps, ScalableProps, SnapOffsetInfo, MoveableManagerInterface\n} from \"../../types\";\nimport { selectValue, throttle, getAbsolutePosesByState, getRect, groupBy, getTinyDist } from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../DraggerUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"../../matrix\";\n\nexport function getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    snapThreshold: number,\n    index: number,\n    [start, end]: number[],\n    [otherStart, otherEnd]: number[],\n) {\n    const totalGuidelines: Guideline[] = [];\n    const otherIndex = index ? 0 : 1;\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n\n    const elementGuidelines\n        = groupBy(guidelines.filter(({ type: guidelineType }) => guidelineType === type), ({ element }) => element)\n            .map(group => group[0])\n            .filter(({ pos, sizes }) => pos[otherIndex] <= otherEnd\n                && otherStart <= pos[otherIndex] + sizes![otherIndex]);\n\n    elementGuidelines.forEach(guideline1 => {\n        const elementStart = guideline1.pos[index];\n        const elementEnd = elementStart + guideline1.sizes![index];\n\n        elementGuidelines.forEach(({\n            pos: guideline2Pos,\n            sizes: guideline2Sizes,\n            element: guideline2Element,\n        }) => {\n            const targetStart = guideline2Pos[index];\n            const targetEnd = targetStart + guideline2Sizes![index];\n            let pos = 0;\n            let gap = 0;\n            let canSnap = true;\n\n            if (elementEnd <= targetStart) {\n                // gap -\n                gap = elementEnd - targetStart;\n                pos = targetEnd - gap;\n\n                if (start < pos - snapThreshold) {\n                    canSnap = false;\n                }\n                // element target moveable\n            } else if (targetEnd <= elementStart) {\n                // gap +\n                gap = elementStart - targetEnd;\n                pos = targetStart - gap;\n\n                if (end > pos + snapThreshold) {\n                    canSnap = false;\n                }\n                // moveable target element\n            } else {\n                return;\n            }\n            if (canSnap) {\n                totalGuidelines.push({\n                    pos: otherType === \"vertical\" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],\n                    element: guideline2Element,\n                    sizes: guideline2Sizes,\n                    size: 0,\n                    type: otherType,\n                    gap,\n                    gapGuidelines: elementGuidelines,\n                });\n            }\n            if (elementEnd <= start && end <= targetStart) {\n                // elementEnd   moveable   target\n                const centerPos = ((targetStart + elementEnd) - (end - start)) / 2;\n\n                if (throttle(start - (centerPos - snapThreshold), 0.1) >= 0) {\n                    totalGuidelines.push({\n                        pos: otherType === \"vertical\" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],\n                        element: guideline2Element,\n                        sizes: guideline2Sizes,\n                        size: 0,\n                        type: otherType,\n                        gap: elementEnd - start,\n                        gapGuidelines: elementGuidelines,\n                    });\n                }\n            }\n        });\n    });\n    return totalGuidelines;\n}\nexport function getTotalGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n) {\n    const {\n        guidelines,\n        containerClientRect: {\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n        },\n    } = moveable.state;\n    const props = moveable.props;\n    const {\n        snapHorizontal = true,\n        snapVertical = true,\n        snapGap = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n        snapThreshold = 5,\n    } = props;\n    const totalGuidelines: Guideline[] = [...guidelines];\n\n    if (snapGap) {\n        const { top, left, bottom, right } = getRect(getAbsolutePosesByState(moveable.state));\n        const elementGuidelines = (guidelines as Guideline[]).filter(({ element }) => element);\n\n        totalGuidelines.push(...getGapGuidelines(\n            elementGuidelines,\n            \"horizontal\",\n            snapThreshold,\n            0,\n            [left, right],\n            [top, bottom],\n        ), ...getGapGuidelines(\n            elementGuidelines,\n            \"vertical\",\n            snapThreshold,\n            1,\n            [top, bottom],\n            [left, right],\n        ));\n    }\n\n    if (snapHorizontal && horizontalGuidelines) {\n        horizontalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"horizontal\", pos: [0, throttle(pos, 0.1)], size: containerWidth! });\n        });\n    }\n    if (snapVertical && verticalGuidelines) {\n        verticalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"vertical\", pos: [throttle(pos, 0.1), 0], size: containerHeight! });\n        });\n    }\n\n    return totalGuidelines;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const totalGuidelines = getTotalGuidelines(moveable);\n    const props = moveable.props;\n    const {\n        snapElement = true,\n    } = props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return {\n        vertical: checkSnap(\n            totalGuidelines,\n            \"vertical\", posesX, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n        horizontal: checkSnap(\n            totalGuidelines,\n            \"horizontal\", posesY, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n    };\n}\n\nexport function checkSnapKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): {\n    vertical: SnapOffsetInfo,\n    horizontal: SnapOffsetInfo,\n} {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    let [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    dx = getTinyDist(dx);\n    dy = getTinyDist(dy);\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    snapCenter: boolean,\n    snapElement: boolean,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map(targetPos => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n        return {\n            pos: targetPos,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    return {\n        isSnap: snapPosInfos.length > 0,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManagerInterface<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses: number[][] = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n}\n\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        const aDist = Math.abs(aOffset);\n        const bDist = Math.abs(bOffset);\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        } else if (a.isBound && b.isBound) {\n            return bDist - aDist;\n        } else if (a.isBound) {\n            return -1;\n        } else if (b.isBound) {\n            return 1;\n        } else if (a.isSnap && b.isSnap) {\n            return aDist - bDist;\n        } else if (a.isSnap) {\n            return -1;\n        } else if (b.isSnap) {\n            return 1;\n        } else if (aDist < TINY_NUM) {\n            return 1;\n        } else if (bDist < TINY_NUM) {\n            return -1;\n        }\n        return aDist - bDist;\n    })[0];\n}\n","import { maxOffset, getDistSize, throttle, getTinyDist } from \"../../utils\";\nimport { average, rotate, getRad } from \"../../matrix\";\nimport { SnappableProps, DraggableProps, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../DraggerUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average(line[0][0], line[1][0]);\n    const cy = average(line[0][1], line[1][1]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], error: number = TINY_NUM) {\n    const centerSign = hitTestLine(dots[0], line) <= 0;\n\n    return dots.slice(1).every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold: number = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    line: number[][],\n    center: number[],\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const {\n        horizontal: isHorizontalStart,\n        vertical: isVerticalStart,\n    } = isStartLine(center, line);\n\n    if (isSameStartLine([\n        center,\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n    const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n    const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n    isRender?: boolean,\n) {\n    const dot1 = line[0];\n    const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n    const dy1 = getTinyDist(dot2[1] - dot1[1]);\n    const dx1 = getTinyDist(dot2[0] - dot1[0]);\n\n    const dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);\n    const dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);\n\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        if (isRender && !dy1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dx1) {\n            // const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n            const y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        } else {\n            const offset = boundDot1[0] - dot1[0];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    } else if (!dy2) {\n        // horizontal\n        if (isRender && !dx1) {\n            // 90deg\n            return {\n                isBound: false,\n                offset: 0,\n            };\n        } else if (dy1) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            // const a = dy1 / dx1;\n            // const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n            const x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        } else {\n            const offset = boundDot1[1] - dot1[1];\n\n            const isBound = Math.abs(offset) <= (threshold || 0);\n\n            return {\n                isBound,\n                offset: isBound ? offset : 0,\n            };\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    lines: number[][][],\n    center: number[],\n    datas: any,\n) {\n    return lines.map(([multiple, pos1, pos2]) => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, [pos1, pos2], center);\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckSnapLines(poses, [0, 0], false).map(([sign, pos1, pos2]) => {\n        return [\n            sign.map(dir => Math.abs(dir) * 2),\n            pos1,\n            pos2,\n        ];\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport function getCheckSnapLines(\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n) {\n    return getCheckSnapLineDirections(direction, keepRatio).map(([sign, dir1, dir2]) => {\n        return [\n            sign,\n            getPosByDirection(poses, dir1),\n            getPosByDirection(poses, dir2),\n        ];\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    const dots = [\n        center,\n        ...boundDots,\n    ];\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some((line, i) => !isSameStartLine(dots, line));\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce<number[]>((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    const lines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n    ];\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lines.forEach(line => {\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);\n        const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);\n        const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import { BoundInfo, SnappableProps, BoundType, RotatableProps, MoveableManagerInterface } from \"../../types\";\nimport { rotate, getRad, minus } from \"../../matrix\";\nimport { getDistSize, throttle } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n    const bounds = { left, top, right, bottom };\n\n    return {\n        vertical: checkBound(bounds, verticalPoses, true),\n        horizontal: checkBound(bounds, horizontalPoses, false),\n    };\n}\n\nexport function checkBoundKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n\n    const [endX, endY] = endPos;\n    let [dx, dy] = minus(endPos, startPos);\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        }\n        if (isBound) {\n            if (y < top || y > bottom) {\n                isBound = false;\n            }\n        }\n        if (!isBound) {\n            if (isBottom && bottom <= endY) {\n                y = bottom;\n                x = (y - b) / a;\n                isBound = true;\n            } else if (!isBottom &&  endY <= top) {\n                y = top;\n                x = (y - b) / a;\n                isBound = true;\n            }\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBound(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n\n    if (startBoundPos + 1 > minPos) {\n        return {\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        };\n    }\n    if (endBoundPos - 1 < maxPos) {\n        return {\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        };\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.bounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index], i) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","\nimport {\n    Renderer,\n    SnappableProps,\n    SnappableState, Guideline,\n    SnapInfo, BoundInfo,\n    ScalableProps, SnapPosInfo, RotatableProps,\n    RectInfo, DraggableProps, SnapOffsetInfo, GapGuideline,\n    SnappableOptions, MoveableClientRect, MoveableManagerInterface, SnappableRenderType,\n} from \"../types\";\nimport {\n    prefix, caculatePoses, getRect,\n    getAbsolutePosesByState, getAbsolutePoses, throttle, roundSign,\n    getDistSize, groupBy, flat, maxOffset, minOffset, triggerEvent, caculateInversePosition, caculatePosition,\n} from \"../utils\";\nimport { IObject, find, findIndex } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus, rotate, plus, getRad } from \"../matrix\";\nimport {\n    dragControlCondition as rotatableDragControlCondtion,\n} from \"./Rotatable\";\nimport { TINY_NUM } from \"../consts\";\nimport { directionCondition } from \"./utils\";\nimport {\n    getInnerBoundInfo, getCheckSnapLines,\n    getInnerBoundDragInfo, checkRotateInnerBounds, checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport { checkBoundPoses, checkRotateBounds, checkBoundKeepRatio } from \"./snappable/bounds\";\nimport {\n    checkSnaps, getSnapInfosByDirection,\n    checkSnapPoses, getNearestSnapGuidelineInfo,\n    getNearOffsetInfo,\n    checkSnapKeepRatio,\n} from \"./snappable/snap\";\n\nexport function caculateContainerPos(\n    rootMatrix: number[],\n    containerRect: MoveableClientRect,\n    n: number,\n) {\n    const clientPos = caculatePosition(\n        rootMatrix, [containerRect.clientLeft!, containerRect.clientTop!], n);\n\n    return [\n        containerRect.left + clientPos[0],\n        containerRect.top + clientPos[1],\n    ];\n}\nexport function snapStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        innerBounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (\n        !innerBounds && !bounds\n        && !horizontalGuidelines.length\n        && !verticalGuidelines.length && !elementGuidelines.length\n    ) {\n        return;\n    }\n\n    const {\n        containerClientRect,\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n        rootMatrix,\n        is3d,\n    } = state;\n    const n = is3d ? 4 : 3;\n    const [containerLeft, containerTop] = caculateContainerPos(rootMatrix, containerClientRect, n);\n    const poses = getAbsolutePosesByState(state);\n    const targetLeft = Math.min(...poses.map(pos => pos[0]));\n    const targetTop = Math.min(...poses.map(pos => pos[1]));\n    const [distLeft, distTop] = minus([targetLeft, targetTop], caculateInversePosition(rootMatrix, [\n        clientLeft - containerLeft,\n        clientTop - containerTop,\n    ], n)).map(pos => roundSign(pos));\n\n    const guidelines: Guideline[] = [];\n\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const left = rect.left - containerLeft;\n        const top = rect.top - containerTop;\n        const bottom = top + rect.height;\n        const right = left + rect.width;\n        const [elementLeft, elementTop] = caculateInversePosition(rootMatrix, [left, top], n);\n        const [elementRight, elementBottom] = caculateInversePosition(rootMatrix, [right, bottom], n);\n        const width = elementRight - elementLeft;\n        const height = elementBottom - elementTop;\n        const sizes = [width, height];\n\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementLeft + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementRight + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementTop + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementBottom + distTop, 0.1),\n            ], size: width,\n            sizes,\n        });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                sizes,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                sizes,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\n\nexport function hasGuidelines(\n    moveable: MoveableManagerInterface<any, any>,\n    ableName: string,\n): moveable is MoveableManagerInterface<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            innerBounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        bounds || innerBounds\n        || (guidelines && guidelines.length)\n        || (verticalGuidelines && verticalGuidelines.length)\n        || (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return [0, 0];\n    }\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return [widthOffset, heightOffset];\n}\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n    isRequest: boolean,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n\n    const horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkSnapBounds(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    isRequest: boolean,\n    poses: number[][],\n    boundPoses: number[][] = poses,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundPoses(\n        moveable,\n        boundPoses.map(pos => pos[0]),\n        boundPoses.map(pos => pos[1]),\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = isRequest ? {\n        horizontal: { isSnap: false },\n        vertical: { isSnap: false },\n    } as any : checkSnapPoses(\n        moveable,\n        poses.map(pos => pos[0]),\n        poses.map(pos => pos[1]),\n    );\n\n    const horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function normalized(value: number) {\n    return value ? value / Math.abs(value) : 0;\n}\nexport function checkMaxBounds(\n    moveable: MoveableManagerInterface<SnappableProps>,\n    poses: number[][],\n    direction: number[],\n    fixedPos: number[],\n    datas: any,\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach(otherDirection => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n\n            const verticalDirection = normalized(otherDirection[1] - fixedDirection[1]);\n            const horizontalDirection = normalized(otherDirection[0] - fixedDirection[0]);\n            const deg = getRad(fixedPos, otherPos) * 360 / Math.PI;\n\n            if (isCheckHorizontal) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 360) < 2 || Math.abs(deg - 180) < 2) {\n                    nextOtherPos[1] = fixedPos[1];\n                }\n                const [\n                    ,\n                    heightOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[1] < otherPos[1] ? bottom : top) - otherPos[1],\n                    false, datas,\n                );\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + verticalDirection * heightOffset;\n                }\n            }\n            if (isCheckVertical) {\n                const nextOtherPos = otherPos.slice();\n\n                if (Math.abs(deg - 90) < 2 || Math.abs(deg - 270) < 2) {\n                    nextOtherPos[0] = fixedPos[0];\n                }\n                const [\n                    widthOffset,\n                ] = solveNextOffset(\n                    fixedPos, nextOtherPos,\n                    (fixedPos[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true, datas,\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + horizontalDirection * widthOffset;\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\nfunction getSnapBoundInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n        const snapBoundInfo\n            = keepRatio\n                ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest)\n                : checkSnapBounds(moveable, isRequest, [otherEndPos]);\n\n        const {\n            horizontal: {\n                dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const isVertical = otherHorizontalDist < otherVerticalDist;\n        const sizeOffset = solveNextOffset(\n            otherStartPos,\n            otherEndPos,\n            -(isVertical ? otherVerticalOffset : otherHorizontalOffset),\n            isVertical,\n            datas,\n        ).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\nexport function getCheckSnapDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const directions: number[][][] = [];\n    const fixedDirection = [-direction[0], -direction[1]];\n\n    if (direction[0] && direction[1]) {\n        directions.push(\n            [fixedDirection, [direction[0], -direction[1]]],\n            [fixedDirection, [-direction[0], direction[1]]],\n        );\n        if (keepRatio) {\n            // pass two direction condition\n            directions.push(\n                [fixedDirection, direction],\n            );\n        }\n    } else if (direction[0]) {\n        // vertcal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [fixedDirection[0], -1]],\n                [fixedDirection, [fixedDirection[0], 1]],\n                [fixedDirection, [direction[0], -1]],\n                [fixedDirection, direction],\n                [fixedDirection, [direction[0], 1]],\n            );\n        } else {\n            directions.push(\n                [[fixedDirection[0], -1], [direction[0], -1]],\n                [[fixedDirection[0], 0], [direction[0], 0]],\n                [[fixedDirection[0], 1], [direction[0], 1]],\n            );\n        }\n    } else if (direction[1]) {\n        // horizontal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [-1, fixedDirection[1]]],\n                [fixedDirection, [1, fixedDirection[1]]],\n                [fixedDirection, [-1, direction[1]]],\n                [fixedDirection, [1, direction[1]]],\n                [fixedDirection, direction],\n            );\n        } else {\n            directions.push(\n                [[-1, fixedDirection[1]], [-1, direction[1]]],\n                [[0, fixedDirection[1]], [0, direction[1]]],\n                [[1, fixedDirection[1]], [1, direction[1]]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        directions.push(\n            [fixedDirection, [1, 0]],\n            [fixedDirection, [-1, 0]],\n            [fixedDirection, [0, -1]],\n            [fixedDirection, [0, 1]],\n\n            [[1, 0], [1, -1]],\n            [[1, 0], [1, 1]],\n            [[0, 1], [1, 1]],\n            [[0, 1], [-1, 1]],\n\n            [[-1, 0], [-1, -1]],\n            [[-1, 0], [-1, 1]],\n            [[0, -1], [1, -1]],\n            [[0, -1], [-1, -1]],\n        );\n    }\n\n    return directions;\n}\nexport function getSizeOffsetInfo(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    isRequest: boolean,\n    datas: any,\n) {\n    const directions = getCheckSnapDirections(direction, keepRatio);\n    const lines = getCheckSnapLines(poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas),\n        ...getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: {\n            offset: horizontalOffset,\n        },\n        vertical: {\n            offset: verticalOffset,\n        },\n    } = checkSnapBounds(moveable, isRequest, [snapPos]);\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n\n        const nextWidth\n            = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n        const nextHeight\n            = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n\n        return [\n            nextWidth - width,\n            nextHeight - height,\n        ];\n    }\n    return [\n        0,\n        0,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManagerInterface<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            isRequest,\n            datas,\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset\n                = isWidthBound && isHeightBound ? widthDist < heightDist\n                    : isHeightBound || (!isWidthBound && widthDist < heightDist);\n\n            // height * widthOffset = width * heighOffset\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = width * nextHeightOffset / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = height * nextWidthOffset / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    if (direction[0] && direction[1]) {\n        const {\n            maxWidth,\n            maxHeight,\n        } = checkMaxBounds(moveable, poses, direction, fixedPos, datas);\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            isRequest,\n            datas,\n        );\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [\n        widthOffset,\n        heightOffset,\n    ];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManagerInterface<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number,\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    const rad = rotation * Math.PI / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map(pos => minus(pos, origin));\n    const nextPoses = prevPoses.map(pos => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapSize(\n    moveable: MoveableManagerInterface<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                matrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        }, width, height, direction, fixedPos, isRequest, datas,\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManagerInterface<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const is3d = datas.is3d;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])),\n                width,\n                height,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        },\n        width, height,\n        direction,\n        fixedPos,\n        isRequest,\n        datas,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[],\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses: number[][] = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalBound) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalSnap) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n                    const scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = (distX || isVerticalBound) ? -verticalOffset : 0;\n        offsetY = (distY || isHorizontalBound) ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\nexport function checkSnapDrag(\n    moveable: MoveableManagerInterface<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    isRequest: boolean,\n    datas: any,\n) {\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n    const snapCenter = moveable.props.snapCenter;\n    const snapPoses = [\n        [left, top],\n        [right, top],\n        [left, bottom],\n        [right, bottom],\n    ];\n\n    if (snapCenter) {\n        snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n    }\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkSnapBounds(moveable, isRequest, snapPoses, poses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound\n        = verticalSnapBoundInfo.isBound\n        || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound\n        = horizontalSnapBoundInfo.isBound\n        || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n    const horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset],\n    );\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Guideline[] = [];\n\n    posInfos.forEach(posInfo => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number,\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\nfunction groupByElementGuidelines(\n    guidelines: Guideline[],\n    clientPos: number,\n    size: number,\n    index: number,\n) {\n    const groupInfos: Array<[Element, number, any]> = [];\n\n    const group = groupBy(guidelines.filter(({ element, gap }) => element && !gap), ({ element, pos }) => {\n        const elementPos = pos[index];\n        const sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n        const groupKey = `${sign}_${pos[index ? 0 : 1]}`;\n        const groupInfo = find(groupInfos, ([groupElement, groupPos]) => {\n            return element === groupElement && elementPos === groupPos;\n        });\n        if (groupInfo) {\n            return groupInfo[2];\n        }\n        groupInfos.push([element!, elementPos, groupKey]);\n        return groupKey;\n    });\n    group.forEach(elementGuidelines => {\n        elementGuidelines.sort((a, b) => {\n            const result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size\n                - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n\n            return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n        });\n    });\n    return group;\n}\nfunction renderElementGroup(\n    group: Guideline[][],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    clientPos: number,\n    clientSize: number,\n    targetPos: number,\n    snapThreshold: number,\n    isDisplaySnapDigit: boolean,\n    snapDigit: number,\n    index: number,\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: Renderer,\n) {\n    return flat(group.map((elementGuidelines, i) => {\n        let isFirstRenderSize = true;\n\n        return elementGuidelines.map(({ pos, size }, j) => {\n            const {\n                pos: linePos,\n                size: lineSize,\n            } = getElementGuidelineDist(pos[index], size, clientPos, clientSize);\n\n            if (lineSize < snapThreshold) {\n                return null;\n            }\n            const isRenderSize = isFirstRenderSize;\n\n            isFirstRenderSize = false;\n            const snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n\n            return <div className={prefix(\n                \"line\",\n                directionName,\n                \"guideline\",\n                \"dashed\",\n            )}\n                data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n                key={`${directionName}LinkGuidline${i}-${j}`} style={{\n                    [posName1]: `${minPos + linePos}px`,\n                    [posName2]: `${-targetPos + pos[index ? 0 : 1]}px`,\n                    [sizeName]: `${lineSize}px`,\n                }} />;\n        });\n    }));\n}\nfunction renderSnapPoses(\n    snapPoses: SnappableRenderType[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    React: Renderer,\n) {\n    return snapPoses.map(({ type, pos }, i) => {\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"target\",\n            \"bold\",\n            type,\n        )} key={`${directionName}TargetGuidline${i}`} style={{\n            [posName1]: `${minPos}px`,\n            [posName2]: `${-targetPos + pos}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\nfunction renderGuidelines(\n    guidelines: Guideline[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    targetPos1: number,\n    targetPos2: number,\n    index: number,\n    React: Renderer,\n) {\n    return guidelines.map((guideline, i) => {\n        const { pos, size, element } = guideline;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            element ? \"bold\" : \"\",\n        )} key={`${directionName}Guidline${i}`} style={{\n            [posName1]: `${-targetPos1 + pos[index]}px`,\n            [posName2]: `${-targetPos2 + pos[index ? 0 : 1]}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\n\nfunction getGapGuidelinesToStart(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap > 0 ? targetSizes[0] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] <= targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => bPos[index] - aPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos + gapSizes![index], 0.0001) === throttle(start - absGap, 0.0001)) {\n                start = nextPos;\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] + gapGuideline.sizes![index];\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelinesToEnd(\n    guidelines: Guideline[],\n    index: number,\n    targetPos: number[],\n    targetSizes: number[],\n    guidelinePos: number[],\n    gap: number,\n    otherPos: number,\n): GapGuideline[] {\n    const absGap = Math.abs(gap);\n    let start = guidelinePos[index] + (gap < 0 ? targetSizes[index] : 0);\n\n    return guidelines.filter(({ pos: gapPos }) => gapPos[index] > targetPos[index])\n        .sort(({ pos: aPos }, { pos: bPos }) => aPos[index] - bPos[index])\n        .filter(({ pos: gapPos, sizes: gapSizes }) => {\n            const nextPos = gapPos[index];\n\n            if (throttle(nextPos, 0.0001) === throttle(start + absGap, 0.0001)) {\n                start = nextPos + gapSizes![index];\n                return true;\n            }\n            return false;\n        }).map(gapGuideline => {\n            const renderPos = -targetPos[index] + gapGuideline.pos[index] - absGap;\n\n            return {\n                ...gapGuideline,\n                gap,\n                renderPos: index ? [otherPos, renderPos] : [renderPos, otherPos],\n            };\n        });\n}\nfunction getGapGuidelines(\n    guidelines: Guideline[],\n    type: \"vertical\" | \"horizontal\",\n    targetPos: number[],\n    targetSizes: number[],\n): GapGuideline[] {\n    const elementGuidelines = guidelines.filter(\n        ({ element, gap, type: guidelineType }) => element && gap && guidelineType === type);\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return flat(elementGuidelines.map((guideline, i) => {\n        const pos = guideline.pos;\n        const gap = guideline.gap!;\n        const gapGuidelines = guideline.gapGuidelines!;\n        const sizes = guideline.sizes!;\n\n        let offset = minOffset(\n            pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex],\n            pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex],\n        );\n        const minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);\n\n        if (offset > 0 && offset > minSize) {\n            offset = (offset - minSize / 2) * 2;\n        } else if (offset < 0 && offset < -minSize) {\n            offset = (offset + minSize / 2) * 2;\n        }\n\n        const otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;\n        return [\n            ...getGapGuidelinesToStart(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n            ...getGapGuidelinesToEnd(gapGuidelines, index, targetPos, targetSizes, pos, gap, otherPos),\n        ];\n    }));\n}\nfunction renderGapGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    gapGuidelines: GapGuideline[],\n    type: \"vertical\" | \"horizontal\",\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    snapDistFormat: Required<SnappableOptions>[\"snapDistFormat\"],\n    React: any,\n) {\n    const {\n        snapDigit = 0,\n        isDisplaySnapDigit = true,\n    } = moveable.props;\n\n    const otherType = type === \"vertical\" ? \"horizontal\" : \"vertical\";\n    const [index, otherIndex] = type === \"vertical\" ? [0, 1] : [1, 0];\n\n    return gapGuidelines.map(({ renderPos, gap }, i) => {\n        const absGap = Math.abs(gap!);\n        const snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"gap\",\n        )}\n            data-size={snapSize > 0 ? snapDistFormat(snapSize) : \"\"}\n            key={`${otherType}GapGuideline${i}`} style={{\n                [posName1]: `${renderPos[index]}px`,\n                [posName2]: `${renderPos[otherIndex]}px`,\n                [sizeName]: `${absGap}px`,\n            }} />;\n    });\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManagerInterface<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: SnappableRenderType[],\n    horizontalSnapPoses: SnappableRenderType[],\n) {\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            pos: verticalBoundPos,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            pos: horizontalBoundPos,\n        },\n    } = checkBoundPoses(moveable, verticalPoses, horizontalPoses);\n\n    if (isVerticalBound) {\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: verticalBoundPos,\n        });\n    }\n    if (isHorizontalBound) {\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: horizontalBoundPos,\n        });\n    }\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalInnerBoundPoses.forEach(innerPos => {\n        if (findIndex(verticalSnapPoses, ({ type, pos }) => type === \"bounds\" && pos === innerPos) >= 0) {\n            return;\n        }\n        verticalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n\n    horizontalInnerBoundPoses.forEach(innerPos => {\n        if (findIndex(horizontalSnapPoses, ({ type, pos }) => type === \"bounds\" && pos === innerPos) >= 0) {\n            return;\n        }\n        horizontalSnapPoses.push({\n            type: \"bounds\",\n            pos: innerPos,\n        });\n    });\n}\n/**\n * @namespace Moveable.Snappable\n * @description Whether or not target can be snapped to the guideline. (default: false)\n * @sort 2\n */\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        snapGap: Boolean,\n        isDisplaySnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n        innerBounds: Object,\n        snapDistFormat: Function,\n    } as const,\n    events: {\n        onSnap: \"snap\",\n    } as const,\n    css: [\n        `:host {\n    --bounds-color: #d66;\n}`,\n        `.guideline {\n    pointer-events: none;\n    z-index: 1;\n}`,\n        `.line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n            is3d,\n            rootMatrix,\n        } = moveable.state;\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n\n        const n = is3d ? 4 : 3;\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n        const containerPos = caculateContainerPos(rootMatrix, containerClientRect, n);\n        const [clientLeft, clientTop] = caculateInversePosition(rootMatrix, [\n            targetClientRect.left - containerPos[0],\n            targetClientRect.top - containerPos[1],\n        ], n);\n\n        const {\n            snapThreshold = 5,\n            snapDigit = 0,\n            isDisplaySnapDigit = true,\n            snapDistFormat = (v: number) => v,\n        } = moveable.props;\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const verticalSnapPoses: SnappableRenderType[] = [];\n        const horizontalSnapPoses: SnappableRenderType[] = [];\n        const verticalGuidelines: Guideline[] = [];\n        const horizontalGuidelines: Guideline[] = [];\n        const snapInfos: Array<{ vertical: SnapInfo, horizontal: SnapInfo }> = [];\n\n        if (!snapRenderInfo.request) {\n            if (snapRenderInfo.direction) {\n                snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n            }\n            if (snapRenderInfo.snap) {\n                const rect = getRect(poses);\n\n                if (snapRenderInfo.center) {\n                    (rect as any).middle = (rect.top + rect.bottom) / 2;\n                    (rect as any).center = (rect.left + rect.right) / 2;\n                }\n                snapInfos.push(checkSnaps(moveable, rect, true, 1));\n            }\n            snapInfos.forEach(snapInfo => {\n                const {\n                    vertical: {\n                        posInfos: verticalPosInfos,\n                    },\n                    horizontal: {\n                        posInfos: horizontalPosInfos,\n                    },\n                } = snapInfo;\n                verticalSnapPoses.push(...verticalPosInfos.map(posInfo => ({\n                    type: \"snap\",\n                    pos: posInfo.pos,\n                } as const)));\n                horizontalSnapPoses.push(...horizontalPosInfos.map(posInfo => ({\n                    type: \"snap\",\n                    pos: posInfo.pos,\n                } as const)));\n                verticalGuidelines.push(...getSnapGuidelines(verticalPosInfos));\n                horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n            });\n        }\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses,\n        );\n        const elementHorizontalGroup = groupByElementGuidelines(\n            horizontalGuidelines,\n            clientLeft,\n            width,\n            0,\n        );\n        const elementVerticalGroup = groupByElementGuidelines(\n            verticalGuidelines,\n            clientTop,\n            height,\n            1,\n        );\n        const horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"] as const;\n        const verticalNames = [\"vertical\", \"top\", \"left\", \"height\"] as const;\n\n        const gapVerticalGuidelines = getGapGuidelines(\n            verticalGuidelines, \"vertical\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n        const gapHorizontalGuidelines = getGapGuidelines(\n            horizontalGuidelines, \"horizontal\",\n            [targetLeft, targetTop],\n            [width, height],\n        );\n\n        const allGuidelines = [\n            ...verticalGuidelines,\n            ...horizontalGuidelines,\n        ];\n        triggerEvent(moveable, \"onSnap\", {\n            guidelines: allGuidelines.filter(({ element }) => !element),\n            elements: groupBy(allGuidelines.filter(({ element }) => element), ({ element }) => element),\n            gaps: [\n                ...gapVerticalGuidelines,\n                ...gapHorizontalGuidelines,\n            ],\n        }, true);\n\n        return [\n            ...renderGapGuidelines(\n                moveable,\n                gapVerticalGuidelines,\n                \"vertical\",\n                horizontalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderGapGuidelines(\n                moveable,\n                gapHorizontalGuidelines,\n                \"horizontal\",\n                verticalNames,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementHorizontalGroup,\n                horizontalNames,\n                minLeft,\n                clientLeft,\n                width,\n                targetTop,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                0,\n                snapDistFormat,\n                React,\n            ),\n            ...renderElementGroup(\n                elementVerticalGroup,\n                verticalNames,\n                minTop,\n                clientTop,\n                height,\n                targetLeft,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                1,\n                snapDistFormat,\n                React,\n            ),\n            ...renderSnapPoses(\n                horizontalSnapPoses,\n                horizontalNames,\n                minLeft,\n                targetTop,\n                width,\n                React,\n            ),\n            ...renderSnapPoses(\n                verticalSnapPoses,\n                verticalNames,\n                minTop,\n                targetLeft,\n                height,\n                React,\n            ),\n            ...renderGuidelines(\n                horizontalGuidelines,\n                horizontalNames,\n                targetLeft,\n                targetTop,\n                0,\n                React,\n            ),\n            ...renderGuidelines(\n                verticalGuidelines,\n                verticalNames,\n                targetTop,\n                targetLeft,\n                1,\n                React,\n            ),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition(e: any) {\n        return directionCondition(e) || rotatableDragControlCondtion(e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n\n/**\n* Whether or not target can be snapped to the guideline. (default: false)\n* @name Moveable.Snappable#snappable\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.snappable = true;\n*/\n/**\n * When you drag, make the snap in the center of the target. (default: false)\n * @name Moveable.Snappable#snapCenter\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n * });\n *\n * moveable.snapCenter = true;\n */\n\n/**\n * When you drag, make the snap in the vertical guidelines. (default: true)\n * @name Moveable.Snappable#snapVertical\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapVertical = false;\n */\n/**\n * When you drag, make the snap in the horizontal guidelines. (default: true)\n * @name Moveable.Snappable#snapHorizontal\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapHorizontal = false;\n */\n/**\n * When you drag, make the gap snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapGap\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n *   snapGap: true,\n * });\n *\n * moveable.snapGap = false;\n */\n/**\n * When you drag, make the snap in the element guidelines. (default: true)\n * @name Moveable.Snappable#snapElement\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   snappable: true,\n *   snapVertical: true,\n *   snapHorizontal: true,\n *   snapElement: true,\n * });\n *\n * moveable.snapElement = false;\n */\n/**\n * Distance value that can snap to guidelines. (default: 5)\n * @name Moveable.Snappable#snapThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapThreshold = 5;\n */\n\n/**\n * Add guidelines in the horizontal direction. (default: [])\n * @name Moveable.Snappable#horizontalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.horizontalGuidlines = [100, 200, 500];\n */\n\n/**\n * Add guidelines in the vertical direction. (default: [])\n * @name Moveable.Snappable#verticalGuidlines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.verticalGuidlines = [100, 200, 500];\n */\n/**\n * Add guidelines for the element. (default: [])\n * @name Moveable.Snappable#elementGuidelines\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.elementGuidelines = [\n *   document.querySelector(\".element\"),\n * ];\n */\n/**\n * You can set up boundaries. (default: null)\n * @name Moveable.Snappable#bounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.bounds = { left: 0, right: 1000, top: 0, bottom: 1000};\n */\n/**\n * You can set up inner boundaries. (default: null)\n * @name Moveable.Snappable#innerBounds\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.innerBounds = { left: 500, top: 500, width: 100, height: 100};\n */\n/**\n * snap distance digits (default: 0)\n * @name Moveable.Snappable#snapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.snapDigit = 0\n */\n/**\n * Whether to show snap distance (default: true)\n * @name Moveable.Snappable#isDisplaySnapDigit\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.isDisplaySnapDigit = true;\n */\n\n/**\n * You can set the text format of the distance shown in the guidelines. (default: self)\n * @name Moveable.Snappable#snapDistFormat\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  snappable: true,\n *  snapDistFormat: v => v,\n * });\n * moveable.snapDistFormat = v => `${v}px`;\n */\n\n/**\n * When you drag or dragControl, the `snap` event is called.\n * @memberof Moveable.Snappable\n * @event snap\n * @param {Moveable.Snappable.OnSnap} - Parameters for the `snap` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     snappable: true\n * });\n * moveable.on(\"snap\", e => {\n *     console.log(\"onSnap\", e);\n * });\n */\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams, throttle, getDistSize, prefix, fillEndParams } from \"../utils\";\nimport { minus, plus, getRad } from \"../matrix\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState,\n    Renderer, OnDragGroupEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildDragger } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { IObject } from \"@daybrush/utils\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n * @description Draggable refers to the ability to drag and move targets.\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n        startDragRotate: Number,\n    } as const,\n    events: {\n        onDragStart: \"dragStart\",\n        onDrag: \"drag\",\n        onDragEnd: \"dragEnd\",\n        onDragGroupStart: \"dragGroupStart\",\n        onDragGroup: \"dragGroup\",\n        onDragGroupEnd: \"dragGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        React: Renderer,\n    ): any[] {\n        const throttleDragRotate = moveable.props.throttleDragRotate;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return [];\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return [];\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return [<div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad)`,\n        }} />];\n    },\n    dragStart(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManagerInterface<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag, isPinch, isRequest } = e;\n        let { distX, distY } = e;\n        const { isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {\n            const startDragRotate = props.startDragRotate || 0;\n            const deg\n                = throttle(startDragRotate + getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate)\n                - startDragRotate;\n            const ry = distY * Math.abs(Math.cos((deg - 90) / 180 * Math.PI));\n            const rx = distX * Math.abs(Math.cos(deg / 180 * Math.PI));\n            const r = getDistSize([rx, ry]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(\n                moveable, distX, distY, throttleDragRotate, isRequest, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        datas.passDeltaX = distX - (datas.passDistX || 0);\n        datas.passDeltaY = distY - (datas.passDistY || 0);\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManagerInterface<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.dragger = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent<DraggableProps>(moveable, \"onDragEnd\", fillEndParams<OnDragEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, clientX, clientY } = e;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildDragger(moveable, this, \"dragStart\", [\n            clientX || 0,\n            clientY || 0,\n        ], e, false);\n\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDeltaX, passDeltaY } = e.datas;\n        const events = triggerChildDragger(moveable, this, \"drag\", [passDeltaX, passDeltaY], e, false);\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildDragger(moveable, this, \"dragEnd\", [0, 0], e, false);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillEndParams<OnDragGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100 });\n     * moveable.request(\"draggable\", { x: 220, y: 100 });\n     * moveable.request(\"draggable\", { x: 240, y: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n\n/**\n * Whether or not target can be dragged. (default: false)\n * @name Moveable.Draggable#draggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.draggable = true;\n */\n\n/**\n * throttle of x, y when drag.\n * @name Moveable.Draggable#throttleDrag\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleDrag = 1;\n */\n\n/**\n* throttle of angle of x, y when drag.\n* @name Moveable.Draggable#throttleDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* moveable.throttleDragRotate = 45;\n*/\n\n/**\n* start angle of throttleDragRotate of x, y when drag.\n* @name Moveable.Draggable#startDragRotate\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body);\n*\n* // 45, 135, 225, 315\n* moveable.throttleDragRotate = 90;\n* moveable.startDragRotate = 45;\n*/\n\n/**\n * When the drag starts, the dragStart event is called.\n * @memberof Moveable.Draggable\n * @event dragStart\n * @param {Moveable.Draggable.OnDragStart} - Parameters for the dragStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When dragging, the drag event is called.\n * @memberof Moveable.Draggable\n * @event drag\n * @param {Moveable.Draggable.OnDrag} - Parameters for the drag event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"drag\", ({ target, transform }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the drag finishes, the dragEnd event is called.\n * @memberof Moveable.Draggable\n * @event dragEnd\n * @param {Moveable.Draggable.OnDragEnd} - Parameters for the dragEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { draggable: true });\n * moveable.on(\"dragEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group drag starts, the `dragGroupStart` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupStart\n * @param {Moveable.Draggable.OnDragGroupStart} - Parameters for the `dragGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupStart\", ({ targets }) => {\n *     console.log(\"onDragGroupStart\", targets);\n * });\n */\n\n /**\n * When the group drag, the `dragGroup` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroup\n * @param {Moveable.Draggable.OnDragGroup} - Parameters for the `dragGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroup\", ({ targets, events }) => {\n *     console.log(\"onDragGroup\", targets);\n *     events.forEach(ev => {\n *          // drag event\n *          console.log(\"onDrag left, top\", ev.left, ev.top);\n *          // ev.target!.style.left = `${ev.left}px`;\n *          // ev.target!.style.top = `${ev.top}px`;\n *          console.log(\"onDrag translate\", ev.dist);\n *          ev.target!.style.transform = ev.transform;)\n *     });\n * });\n */\n\n/**\n * When the group drag finishes, the `dragGroupEnd` event is called.\n * @memberof Moveable.Draggable\n * @event dragGroupEnd\n * @param {Moveable.Draggable.OnDragGroupEnd} - Parameters for the `dragGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     draggable: true\n * });\n * moveable.on(\"dragGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onDragGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    throttle, prefix, triggerEvent, fillParams,\n    getRotationRad, getClientRect, caculatePosition, fillEndParams\n} from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps, SnappableState, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapRotate } from \"./Snappable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n * @description Rotatable indicates whether the target can be rotated.\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n\n    const n = moveable.state.is3d ? 4 : 3;\n    const nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.prevSnapDeg = datas.prevDeg;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getParentDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    parentDist: number,\n    direction: number,\n    startRotate: number,\n) {\n    const {\n        prevDeg,\n    } = datas;\n\n    // const absoluteDeg = startRotate + parentDist;\n    const dist = checkSnapRotate(\n        moveable,\n        moveableRect,\n        datas.origin,\n        parentDist,\n    );\n    datas.prevDeg = dist;\n\n    const delta = dist - prevDeg;\n\n    return [delta, dist, startRotate + dist];\n}\nfunction getDeg(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        prevSnapDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    let dist = direction * (absoluteDeg - startRotate);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startRotate;\n    }\n    datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    const delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n\n    return [delta, dist, startRotate + dist];\n}\nfunction getRotateInfo(\n    moveable: MoveableManagerInterface<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getReversePositionX(dir: string) {\n    if (dir === \"left\") {\n        return \"right\";\n    } else if (dir === \"right\") {\n        return \"left\";\n    }\n    return dir;\n}\nexport function getReversePositionY(dir: string) {\n    if (dir === \"top\") {\n        return \"bottom\";\n    } else if (dir === \"bottom\") {\n        return \"top\";\n    }\n    return dir;\n}\nexport function getPositions(\n    rotationPosition: RotatableProps[\"rotationPosition\"],\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number,\n) {\n    const [dir1, dir2] = (rotationPosition || \"top\").split(\"-\");\n    let radPoses = [pos1, pos2];\n\n    // if (scale[0] < 0) {\n    //     dir1 = getReversePositionX(dir1);\n    //     dir2 = getReversePositionX(dir2);\n    // }\n    // if (scale[1] < 0) {\n    //     dir1 = getReversePositionY(dir1);\n    //     dir2 = getReversePositionY(dir2);\n    // }\n    if (dir1 === \"left\") {\n        radPoses = [pos3, pos1];\n    } else if (dir1 === \"right\") {\n        radPoses = [pos2, pos4];\n    } else if (dir1 === \"bottom\") {\n        radPoses = [pos4, pos3];\n    }\n    let pos = [\n        (radPoses[0][0] + radPoses[1][0]) / 2,\n        (radPoses[0][1] + radPoses[1][1]) / 2,\n    ];\n    const rad = getRotationRad(radPoses, direction);\n\n    if (dir2) {\n        const isStart = dir2 === \"top\" || dir2 === \"left\";\n        const isReverse = dir1 === \"bottom\" || dir1 === \"left\";\n\n        pos = radPoses[(isStart && !isReverse) || (!isStart && isReverse) ? 0 : 1];\n    }\n    return [pos, rad] as const;\n}\n\nexport function dragControlCondition(e: any) {\n    if (e.isRequest) {\n        return e.requestAble === \"rotatable\";\n    }\n    return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n    } as const,\n    events: {\n        onRotateStart: \"rotateStart\",\n        onRotate: \"rotate\",\n        onRotateEnd: \"rotateEnd\",\n        onRotateGroupStart: \"rotateGroupStart\",\n        onRotateGroup: \"rotateGroup\",\n        onRotateGroupEnd: \"rotateGroupEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { renderPoses, direction } = moveable.state;\n        const [pos, rotationRad] = getPositions(rotationPosition!, renderPoses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(-50%) translate(${pos[0]}px, ${pos[1]}px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<RotatableProps & SnappableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, isPinch,\n            isRequest,\n        } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n        } = moveable.state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        if (isRequest || isPinch || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n            datas.afterInfo = {\n                origin: rect.origin,\n                prevDeg: externalRotate, startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n        } else {\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n\n            const controlRect = getClientRect(moveable.controlBox.getElement());\n\n            setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n            setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {\n            request: e.isRequest,\n        };\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, isPinch } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (!parentFlag && \"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            [delta, dist, rotate]\n                = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate);\n\n        } else if (isPinch || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!isPinch,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillEndParams<OnRotateEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(datas.beforeDirection * moveable.rotation);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const direction = datas.beforeDirection;\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad * direction);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent, !!e.isPinch, false),\n                );\n                result.drag = dragResult;\n            },\n        );\n        moveable.rotation = direction * params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillEndParams<OnRotateGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.rotate=0] - absolute number of moveable's rotation\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10 }, true);\n     *\n     * * moveable.request(\"rotatable\", { rotate: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * requester.request({ rotate: 10 });\n     * requester.request({ rotate: 20 });\n     * requester.request({ rotate: 30 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<RotatableProps>) {\n        const datas = {};\n        let distRotate = 0;\n\n        const startRotation = moveable.getRotation();\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaRotate\" in e) {\n                    distRotate += e.deltaRotate;\n                } else if (\"rotate\" in e) {\n                    distRotate = e.rotate - startRotation;\n                }\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether or not target can be rotated. (default: false)\n * @name Moveable.Rotatable#rotatable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.rotatable = true;\n */\n/**\n * You can specify the position of the rotation. (default: \"top\")\n * @name Moveable.Rotatable#rotationPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   rotationPosition: \"top\",\n * });\n *\n * moveable.rotationPosition = \"bottom\"\n */\n\n/**\n * throttle of angle(degree) when rotate.\n * @name Moveable.Rotatable#throttleRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleRotate = 1;\n */\n\n/**\n * When the rotate starts, the rotateStart event is called.\n * @memberof Moveable.Rotatable\n * @event rotateStart\n * @param {Moveable.Rotatable.OnRotateStart} - Parameters for the rotateStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n\n/**\n* When rotating, the rotate event is called.\n* @memberof Moveable.Rotatable\n* @event rotate\n* @param {Moveable.Rotatable.OnRotate} - Parameters for the rotate event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { rotatable: true });\n* moveable.on(\"rotate\", ({ target, transform, dist }) => {\n*     target.style.transform = transform;\n* });\n*/\n/**\n * When the rotate finishes, the rotateEnd event is called.\n * @memberof Moveable.Rotatable\n * @event rotateEnd\n * @param {Moveable.Rotatable.OnRotateEnd} - Parameters for the rotateEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { rotatable: true });\n * moveable.on(\"rotateEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n * When the group rotate starts, the `rotateGroupStart` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupStart\n * @param {Moveable.Rotatable.OnRotateGroupStart} - Parameters for the `rotateGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupStart\", ({ targets }) => {\n *     console.log(\"onRotateGroupStart\", targets);\n * });\n */\n\n/**\n* When the group rotate, the `rotateGroup` event is called.\n* @memberof Moveable.Rotatable\n* @event rotateGroup\n* @param {Moveable.Rotatable.OnRotateGroup} - Parameters for the `rotateGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     rotatable: true\n* });\n* moveable.on(\"rotateGroup\", ({ targets, events }) => {\n*     console.log(\"onRotateGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group rotate.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const deg = ev.beforeDist;\n*     });\n* });\n*/\n\n/**\n * When the group rotate finishes, the `rotateGroupEnd` event is called.\n * @memberof Moveable.Rotatable\n * @event rotateGroupEnd\n * @param {Moveable.Rotatable.OnRotateGroupEnd} - Parameters for the `rotateGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     rotatable: true\n * });\n * moveable.on(\"rotateGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onRotateGroupEnd\", targets, isDrag);\n * });\n */\n","import { prefix, getControlTransform, throttle } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer, MoveableManagerInterface } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS, DIRECTIONS } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        renderPoses,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const {\n        direction,\n    } = moveable.state;\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(dir => {\n        directionMap[dir] = true;\n    });\n    return directions.map(dir => {\n        const indexes = DIRECTION_INDEXES[dir];\n\n        if (!indexes || !directionMap[dir]) {\n            return null;\n        }\n        let directionRotation = throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[dir];\n\n        if (direction < 1) {\n            directionRotation = 360 - directionRotation;\n        }\n        directionRotation %= 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", dir)}\n                data-rotation={directionRotation} data-direction={dir} key={`direction-${dir}`}\n                style={getControlTransform(rotation, ...indexes.map(index => renderPoses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, DIRECTIONS, React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize, caculateBoundSize, fillEndParams,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getStartDirection,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\nimport {\n    directionCondition,\n} from \"./utils\";\nimport { IObject, isString } from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n * @description Resizable indicates whether the target's width and height can be increased or decreased.\n */\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onResizeStart: \"resizeStart\",\n        onResize: \"resize\",\n        onResizeEnd: \"resizeEnd\",\n\n        onResizeGroupStart: \"resizeGroupStart\",\n        onResizeGroup: \"resizeGroup\",\n        onResizeGroupEnd: \"resizeGroupEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            isPinch,\n            parentDirection,\n            datas,\n            parentFlag,\n        } = e;\n\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !isPinch && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        const padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];\n        datas.minSize = padding;\n        datas.maxSize = [Infinity, Infinity];\n\n        if (!parentFlag) {\n            const style = window.getComputedStyle(target);\n\n            datas.minSize = plus([\n                parseFloat(style.minWidth!) || 0,\n                parseFloat(style.minHeight!) || 0,\n            ], padding);\n            datas.maxSize = plus([\n                parseFloat(style.maxWidth!) || Infinity,\n                parseFloat(style.maxHeight!) || Infinity,\n            ], padding);\n        }\n        const transformOrigin = moveable.props.transformOrigin || \"% %\";\n\n        datas.transformOrigin = transformOrigin && isString(transformOrigin)\n            ? transformOrigin.split(\" \")\n            : transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setMin: (minSize: number[]) => {\n                datas.minSize = minSize;\n            },\n            setMax: (maxSize: number[]) => {\n                datas.maxSize = maxSize;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, isPinch,\n            parentDistance, parentScale, inputEvent,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n            minSize,\n            maxSize,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        let fixedPosition = dragClient;\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n            }\n        }\n\n        if (parentDist) {\n            distWidth = parentDist[0];\n            distHeight = parentDist[1];\n        } else if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n        } else if (isPinch) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = sizeDirection[0] * dist[0];\n            distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = sizeDirection[0] || keepRatio\n            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n        let nextHeight = sizeDirection[1] || keepRatio\n            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n        if (keepRatio && startOffsetWidth && startOffsetHeight) {\n            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n            nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapSize(\n                moveable, nextWidth,\n                nextHeight, direction,\n                datas.fixedOriginalPosition,\n                isRequest,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        [nextWidth, nextHeight] = caculateBoundSize(\n            [nextWidth, nextHeight],\n            minSize,\n            maxSize,\n            keepRatio,\n        );\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        const inverseDelta = getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        if (!parentMoveable && delta.every(num => !num) && inverseDelta.every(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, !!isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent<ResizableProps>(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillEndParams<OnResizeEnd>(moveable, e, {});\n        triggerEvent<ResizableProps>(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent<ResizableProps>(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillEndParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent<ResizableProps>(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to resize\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.offsetWidth] - offset number of width\n     * @param {number} [e.offsetHeight] - offset number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100 });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManagerInterface<any>) {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can be resized. (default: false)\n * @name Moveable.Resizable#resizable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     resizable: false,\n * });\n *\n * moveable.resizable = true;\n */\n\n/**\n * throttle of width, height when resize.\n * @name Moveable.Resizable#throttleResize\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   throttleResize: 0,\n * });\n *\n * moveable.throttleResize = 1;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Resizable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Resizable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   resizable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n\n/**\n * When the resize starts, the resizeStart event is called.\n * @memberof Moveable.Resizable\n * @event resizeStart\n * @param {Moveable.Resizable.OnResizeStart} - Parameters for the resizeStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When resizing, the resize event is called.\n * @memberof Moveable.Resizable\n * @event resize\n * @param {Moveable.Resizable.OnResize} - Parameters for the resize event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resize\", ({ target, width, height }) => {\n *     target.style.width = `${e.width}px`;\n *     target.style.height = `${e.height}px`;\n * });\n */\n/**\n * When the resize finishes, the resizeEnd event is called.\n * @memberof Moveable.Resizable\n * @event resizeEnd\n * @param {Moveable.Resizable.OnResizeEnd} - Parameters for the resizeEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { resizable: true });\n * moveable.on(\"resizeEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n /**\n * When the group resize starts, the `resizeGroupStart` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupStart\n * @param {Moveable.Resizable.OnResizeGroupStart} - Parameters for the `resizeGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupStart\", ({ targets }) => {\n *     console.log(\"onResizeGroupStart\", targets);\n * });\n */\n\n /**\n * When the group resize, the `resizeGroup` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroup\n * @param {Moveable.Resizable.onResizeGroup} - Parameters for the `resizeGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroup\", ({ targets, events }) => {\n *     console.log(\"onResizeGroup\", targets);\n *     events.forEach(ev => {\n *         const offset = [\n *             direction[0] < 0 ? -ev.delta[0] : 0,\n *             direction[1] < 0 ? -ev.delta[1] : 0,\n *         ];\n *         // ev.drag is a drag event that occurs when the group resize.\n *         const left = offset[0] + ev.drag.beforeDist[0];\n *         const top = offset[1] + ev.drag.beforeDist[1];\n *         const width = ev.width;\n *         const top = ev.top;\n *     });\n * });\n */\n\n/**\n * When the group resize finishes, the `resizeGroupEnd` event is called.\n * @memberof Moveable.Resizable\n * @event resizeGroupEnd\n * @param {Moveable.Resizable.OnResizeGroupEnd} - Parameters for the `resizeGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     resizable: true\n * });\n * moveable.on(\"resizeGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onResizeGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    throttle, getDirection, triggerEvent, multiply2,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getDistSize, fillEndParams,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, getDragDist,\n    getScaleDist,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart,\n    OnScale, OnScaleEnd, MoveableManagerInterface, MoveableGroupInterface,\n} from \"../types\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"../matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray, IObject } from \"@daybrush/utils\";\nimport {\n    directionCondition,\n} from \"./utils\";\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n * @description Scalable indicates whether the target's x and y can be scale of transform.\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    } as const,\n    events: {\n        onScaleStart: \"scaleStart\",\n        onScale: \"scale\",\n        onScaleEnd: \"scaleEnd\",\n        onScaleGroupStart: \"scaleGroupStart\",\n        onScaleGroup: \"scaleGroup\",\n        onScaleGroupEnd: \"scaleGroupEnd\",\n    } as const,\n    render(\n        moveable: MoveableManagerInterface<Partial<ResizableProps & ScalableProps>>,\n        React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, isPinch, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!isPinch) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n        datas.fixedDirection = direction.map((dir: number) => -dir);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                request: e.isRequest,\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, isPinch, inputEvent,\n            dragClient,\n            parentDist,\n            isRequest,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const state = moveable.state;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n        let fixedPosition = dragClient;\n\n        if (!dragClient) {\n            if (!parentFlag && isPinch) {\n                fixedPosition = getAbsoluteFixedPosition(moveable, [0, 0]);\n            } else {\n                fixedPosition = datas.fixedPosition;\n            }\n        }\n\n        if (parentDist) {\n            scaleX = (width + parentDist[0]) / width;\n            scaleY = (height + parentDist[1]) / height;\n        } else if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (isPinch) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = sizeDirection[0] * dist[0];\n            let distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n\n        scaleX = sizeDirection[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n        scaleY = sizeDirection[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n\n        if (!isPinch && moveable.props.groupable) {\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction, request: e.isRequest, };\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!isPinch) {\n            snapDist = checkSnapScale(\n                moveable,\n                nowDist,\n                direction,\n                datas.fixedPosition,\n                isRequest,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            nowDist[0] += snapDist[0];\n            nowDist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        const inverseDelta = getScaleDist(moveable, delta, direction, fixedPosition);\n\n        if (\n            scaleX === prevDist[0] && scaleY === prevDist[1]\n            && inverseDelta.every(num => !num)\n            && !parentMoveable\n        ) {\n            return false;\n        }\n\n        const params = fillParams<OnScale>(moveable, e, {\n            offsetWidth: width,\n            offsetHeight: height,\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!isPinch,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, isPinch, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillEndParams<OnScaleEnd>(moveable, e, {}));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const fixedPosition = datas.fixedPosition;\n\n        datas.moveableScale = moveable.scale;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n\n        const moveableScale = datas.moveableScale;\n        moveable.scale = [\n            params.scale[0] * moveableScale[0],\n            params.scale[1] * moveableScale[1],\n        ];\n        const keepRatio = moveable.props.keepRatio;\n        const { dist, scale } = params;\n\n        // const fixedDirection = datas.fixedDirection;\n        const fixedPosition = datas.fixedPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * dist[0],\n                        childDatas.originalY * dist[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentDist: null,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroupInterface<any, any>, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillEndParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to scale\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10 }, true);\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n\n/**\n * Whether or not target can scaled. (default: false)\n * @name Moveable.Scalable#scalable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.scalable = true;\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.keepRatio = true;\n */\n\n/**\n * throttle of scaleX, scaleY when scale.\n * @name Moveable.Scalable#throttleScale\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.throttleScale = 0.1;\n */\n/**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Scalable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n *   renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n * When resize or scale, keeps a ratio of the width, height. (default: false)\n * @name Moveable.Scalable#keepRatio\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     scalable: true,\n * });\n *\n * moveable.keepRatio = true;\n */\n/**\n * When the scale starts, the scaleStart event is called.\n * @memberof Moveable.Scalable\n * @event scaleStart\n * @param {Moveable.Scalable.OnScaleStart} - Parameters for the scaleStart event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleStart\", ({ target }) => {\n *     console.log(target);\n * });\n */\n/**\n * When scaling, the scale event is called.\n * @memberof Moveable.Scalable\n * @event scale\n * @param {Moveable.Scalable.OnScale} - Parameters for the scale event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scale\", ({ target, transform, dist }) => {\n *     target.style.transform = transform;\n * });\n */\n/**\n * When the scale finishes, the scaleEnd event is called.\n * @memberof Moveable.Scalable\n * @event scaleEnd\n * @param {Moveable.Scalable.OnScaleEnd} - Parameters for the scaleEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { scalable: true });\n * moveable.on(\"scaleEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n\n/**\n* When the group scale starts, the `scaleGroupStart` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroupStart\n* @param {Moveable.Scalable.OnScaleGroupStart} - Parameters for the `scaleGroupStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroupStart\", ({ targets }) => {\n*     console.log(\"onScaleGroupStart\", targets);\n* });\n*/\n\n/**\n* When the group scale, the `scaleGroup` event is called.\n* @memberof Moveable.Scalable\n* @event scaleGroup\n* @param {Moveable.Scalable.OnScaleGroup} - Parameters for the `scaleGroup` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     target: [].slice.call(document.querySelectorAll(\".target\")),\n*     scalable: true\n* });\n* moveable.on(\"scaleGroup\", ({ targets, events }) => {\n*     console.log(\"onScaleGroup\", targets);\n*     events.forEach(ev => {\n*         const target = ev.target;\n*         // ev.drag is a drag event that occurs when the group scale.\n*         const left = ev.drag.beforeDist[0];\n*         const top = ev.drag.beforeDist[1];\n*         const scaleX = ev.scale[0];\n*         const scaleY = ev.scale[1];\n*     });\n* });\n*/\n\n/**\n * When the group scale finishes, the `scaleGroupEnd` event is called.\n * @memberof Moveable.Scalable\n * @event scaleGroupEnd\n * @param {Moveable.Scalable.OnScaleGroupEnd} - Parameters for the `scaleGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n *     scalable: true\n * });\n * moveable.on(\"scaleGroupEnd\", ({ targets, isDrag }) => {\n *     console.log(\"onScaleGroupEnd\", targets, isDrag);\n * });\n */\n","import {\n    prefix, getLineStyle, getDirection, getAbsolutePosesByState,\n    triggerEvent, fillParams, makeMatrixCSS, fillEndParams,\n } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"../matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { hasGuidelines, checkSnapBounds } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\n/**\n * @namespace Moveable.Warpable\n * @description Warpable indicates whether the target can be warped(distorted, bented).\n */\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    } as const,\n    events: {\n        onWarpStart: \"warpStart\",\n        onWarp: \"warp\",\n        onWarpEnd: \"warpEnd\",\n    } as const,\n    render(moveable: MoveableManagerInterface<ResizableProps & ScalableProps & WarpableProps>, React: Renderer): any[] {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return [];\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        return hasClass(e.inputEvent.target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManagerInterface<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map(p => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapRenderInfo = {\n            request: e.isRequest,\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManagerInterface<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, isRequest } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapBounds(\n                moveable,\n                isRequest,\n                selectedPoses.map(pos => [pos[0] + distX, pos[1] + distY]),\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[2],\n            poses[1],\n            poses[3],\n            nextPoses[0],\n            nextPoses[2],\n            nextPoses[1],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = multiply(targetInverseMatrix, h, 4);\n        const transform = `${datas.targetTransform} ${makeMatrixCSS(matrix, true)}`;\n        const delta = multiply(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiply(startMatrix, matrix, 4),\n            multiply,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManagerInterface<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillEndParams<OnWarpEnd>(moveable, e, {}));\n        return isDrag;\n    },\n};\n\n/**\n * Whether or not target can be warped. (default: false)\n * @name Moveable.Warpable#warpable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.warpable = true;\n */\n\n /**\n * Set directions to show the control box. (default: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"])\n * @name Moveable.Warpable#renderDirections\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     warpable: true,\n *     renderDirections: [\"n\", \"nw\", \"ne\", \"s\", \"se\", \"sw\", \"e\", \"w\"],\n * });\n *\n * moveable.renderDirections = [\"nw\", \"ne\", \"sw\", \"se\"];\n */\n/**\n* When the warp starts, the warpStart event is called.\n* @memberof Moveable.Warpable\n* @event warpStart\n* @param {Moveable.Warpable.OnWarpStart} - Parameters for the warpStart event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, { warpable: true });\n* moveable.on(\"warpStart\", ({ target }) => {\n*     console.log(target);\n* });\n*/\n/**\n * When warping, the warp event is called.\n * @memberof Moveable.Warpable\n * @event warp\n * @param {Moveable.Warpable.OnWarp} - Parameters for the warp event\n * @example\n * import Moveable from \"moveable\";\n * let matrix = [\n *  1, 0, 0, 0,\n *  0, 1, 0, 0,\n *  0, 0, 1, 0,\n *  0, 0, 0, 1,\n * ];\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warp\", ({ target, transform, delta, multiply }) => {\n *    // target.style.transform = transform;\n *    matrix = multiply(matrix, delta);\n *    target.style.transform = `matrix3d(${matrix.join(\",\")})`;\n * });\n */\n/**\n * When the warp finishes, the warpEnd event is called.\n * @memberof Moveable.Warpable\n * @event warpEnd\n * @param {Moveable.Warpable.OnWarpEnd} - Parameters for the warpEnd event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, { warpable: true });\n * moveable.on(\"warpEnd\", ({ target, isDrag }) => {\n *     console.log(target, isDrag);\n * });\n */\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import {\n    createWarpMatrix,\n} from \"../matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect, caculateInversePosition, makeMatrixCSS } from \"../utils\";\nimport {\n    Renderer, GroupableProps, DragAreaProps, OnClick,\n    OnClickGroup, MoveableManagerInterface, MoveableGroupInterface\n} from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManagerInterface) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n    } as const,\n    events: {\n        onClick: \"click\",\n        onClickGroup: \"clickGroup\",\n    } as const,\n    render(moveable: MoveableManagerInterface<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n        const { width, height, renderPoses } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            renderPoses[0],\n            renderPoses[1],\n            renderPoses[2],\n            renderPoses[3],\n        );\n        const transform = h.length ? makeMatrixCSS(h, true) : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManagerInterface, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            moveableClientRect,\n            renderPoses,\n            rootMatrix,\n            is3d,\n        } = moveable.state;\n        const { left, top } = moveableClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n            width,\n            height,\n        } = getRect(renderPoses);\n        const n = is3d ? 4 : 3;\n        let [posX, posY] = caculateInversePosition(rootMatrix, [clientX - left, clientY - top], n);\n\n        posX -= relativeLeft;\n        posY -= relativeTop;\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface, { datas, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManagerInterface<DragAreaProps>, e: any) {\n        if (!e.inputEvent) {\n            return false;\n        }\n        const { inputEvent, datas } = e;\n        const isDragArea = datas.isDragArea;\n\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent<DragAreaProps>(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            isDouble: e.isDouble,\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroupInterface<DragAreaProps>,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent<DragAreaProps>(moveable, \"onClickGroup\", fillParams<OnClickGroup>(moveable, e, {\n            isDouble: e.isDouble,\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n\n/**\n * Add an event to the moveable area instead of the target for stopPropagation. (default: false)\n * @name Moveable#dragArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  dragArea: false,\n * });\n */\n\n/**\n * When you click on the element, the `click` event is called.\n * @memberof Moveable\n * @event click\n * @param {Moveable.OnClick} - Parameters for the `click` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"click\", ({ hasTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", target, hasTarget, containsTarget, targetIndex);\n * });\n */\n\n/**\n * When you click on the element inside the group, the `clickGroup` event is called.\n * @memberof Moveable\n * @event clickGroup\n * @param {Moveable.OnClickGroup} - Parameters for the `clickGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"clickGroup\", ({ inputTarget, isTarget, containsTarget, targetIndex }) => {\n *     // If you click on an element other than the target and not included in the target, index is -1.\n *     console.log(\"onClickGroup\", inputTarget, isTarget, containsTarget, targetIndex);\n * });\n */\n","import { prefix, getControlTransform } from \"../utils\";\nimport { Renderer, OriginOptions, MoveableManagerInterface } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    props: {\n        origin: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableManagerInterface<OriginOptions>, React: Renderer): any[] {\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n\n/**\n * Whether or not the origin controlbox will be visible or not (default: true)\n * @name Moveable#origin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n *\n * moveable.origin = true;\n */\n","\nimport { ScrollableProps, OnScroll, MoveableManagerInterface, MoveableGroupInterface } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n/**\n * @namespace Moveable.Scrollable\n * @description Whether or not target can be scrolled to the scroll container (default: false)\n */\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n        getScrollPosition: Function,\n    } as const,\n    events: {\n        onScroll: \"scroll\",\n        onScrollGroup: \"scrollGroup\",\n    } as const,\n    dragStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const dragScroll = new DragScroll();\n\n        e.datas.dragScroll = dragScroll;\n\n        const draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainer as HTMLElement,\n        });\n    },\n    checkScroll(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroup(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface, e: any) {\n        return this.dragStart(moveable, { ...e, targets: moveable.props.targets, isControl: true });\n    },\n    dragGroupContro(moveable: MoveableGroupInterface, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroupInterface, e: any) {\n        return this.dragEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n\n/**\n * Whether or not target can be scrolled to the scroll container (default: false)\n * @name Moveable.Scrollable#scrollable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n * moveable.scrollable = true;\n */\n\n/**\n * The container to which scroll is applied (default: container)\n * @name Moveable.Scrollable#scrollContainer\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n/**\n * Expand the range of the scroll check area. (default: 0)\n * @name Moveable.Scrollable#scrollThreshold\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n */\n\n/**\n * Sets a function to get the scroll position. (default: Function)\n * @name Moveable.Scrollable#getScrollPosition\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   scrollable: true,\n *   scrollContainer: document.body,\n *   scrollThreshold: 0,\n *   getScrollPosition: ({ scrollContainer }) => ([scrollContainer.scrollLeft, scrollContainer.scrollTop]),\n * });\n *\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scroll` event occur to scroll.\n * @memberof Moveable.Scrollable\n * @event scroll\n * @param {Moveable.Scrollable.OnScroll} - Parameters for the `scroll` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n\n/**\n * When the drag cursor leaves the scrollContainer, the `scrollGroup` event occur to scroll in group.\n * @memberof Moveable.Scrollable\n * @event scrollGroup\n * @param {Moveable.Scrollable.OnScrollGroup} - Parameters for the `scrollGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"scroll\", ({ scrollContainer, direction }) => {\n *   scrollContainer.scrollLeft += direction[0] * 10;\n *   scrollContainer.scrollTop += direction[1] * 10;\n * });\n */\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        dragTarget: Object,\n        container: Object,\n        rootContainer: Object,\n        zoom: Number,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n        pinchOutside: Boolean,\n        triggerAblesSimultaneously: Boolean,\n        checkInput: Boolean,\n        cspNonce: String,\n    } as const,\n    events: {\n        onRenderStart: \"renderStart\",\n        onRender: \"render\",\n        onRenderEnd: \"renderEnd\",\n        onRenderGroupStart: \"renderGroupStart\",\n        onRenderGroup: \"renderGroup\",\n        onRenderGroupEnd: \"renderGroupEnd\",\n    } as const,\n};\n","import { prefix, makeMatrixCSS } from \"../utils\";\nimport { Renderer, MoveableManagerInterface } from \"../types\";\nimport { createWarpMatrix } from \"../matrix\";\n\nexport default {\n    name: \"padding\",\n    props: {\n        padding: Object,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableManagerInterface, React: Renderer): any[] {\n        const props = moveable.props;\n        if (props.dragArea) {\n            return [];\n        }\n        const padding = props.padding || {};\n        const {\n            left = 0,\n            top = 0,\n            right = 0,\n            bottom = 0,\n        } = padding;\n        const {\n            renderPoses,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        } = moveable.state;\n\n        const poses = [pos1, pos2, pos3, pos4];\n        const paddingDirections: number[][] = [];\n\n        if (left > 0) {\n            paddingDirections.push([0, 2]);\n        }\n        if (top > 0) {\n            paddingDirections.push([0, 1]);\n        }\n        if (right > 0) {\n            paddingDirections.push([1, 3]);\n        }\n        if (bottom > 0) {\n            paddingDirections.push([2, 3]);\n        }\n        return paddingDirections.map(([dir1, dir2], i) => {\n            const paddingPos1 = poses[dir1];\n            const paddingPos2 = poses[dir2];\n            const paddingPos3 = renderPoses[dir1];\n            const paddingPos4 = renderPoses[dir2];\n\n            const h = createWarpMatrix(\n                [0, 0],\n                [100, 0],\n                [0, 100],\n                [100, 100],\n                paddingPos1,\n                paddingPos2,\n                paddingPos3,\n                paddingPos4,\n            );\n            if (!h.length) {\n                return undefined;\n            }\n            return (<div key={`padding${i}`} className={prefix(\"padding\")} style={{\n                transform: makeMatrixCSS(h, true),\n            }}></div>);\n        });\n    },\n};\n\n/**\n * Add padding around the target to increase the drag area. (default: null)\n * @name Moveable#padding\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *  target: document.querySelector(\".target\"),\n *  padding: { left: 0, top: 0, right: 0, bottom: 0 },\n * });\n * moveable.padding = { left: 10, top: 10, right: 10, bottom: 10 },\n * moveable.updateRect();\n */\n","import { getUnitSize, convertCSSSize } from \"../../utils\";\nimport { ControlPose } from \"../../types\";\n\nconst RADIUS_DIRECTIONS = [\"nw\", \"ne\", \"se\", \"sw\"] as const;\n\nfunction caculateRatio(values: number[], size: number) {\n    const sumSize = values[0] + values[1];\n    const sumRatio = sumSize > size ? size / sumSize : 1;\n\n    values[0] *= sumRatio;\n    values[1] = size - values[1] * sumRatio;\n\n    return values;\n}\nexport const HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];\nexport const VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];\nexport const HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1] as const;\nexport const VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1] as const;\n\nexport function getRadiusStyles(\n    poses: number[][], controlPoses: ControlPose[],\n    isRelative: boolean,\n    width: number,\n    height: number,\n    left: number = 0,\n    top: number = 0,\n    right: number = width,\n    bottom: number = height,\n) {\n    const clipStyles: string[] = [];\n    let isVertical = false;\n\n    const raws = poses.map((pos, i) => {\n        const { horizontal, vertical } = controlPoses[i];\n        if (vertical && !isVertical) {\n            isVertical = true;\n            clipStyles.push(\"/\");\n        }\n\n        if (isVertical) {\n            const rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);\n            clipStyles.push(convertCSSSize(rawPos, height, isRelative));\n\n            return rawPos;\n        } else {\n            const rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);\n            clipStyles.push(convertCSSSize(rawPos, width, isRelative));\n\n            return rawPos;\n        }\n    });\n\n    return {\n        styles: clipStyles,\n        raws,\n    };\n}\nexport function getRadiusRange(controlPoses: ControlPose[]) {\n    // [start, length]\n    const horizontalRange = [0, 0];\n    const verticalRange = [0, 0];\n    const length =  controlPoses.length;\n\n    for (let i = 0; i < length; ++i) {\n        const clipPose = controlPoses[i];\n\n        if (!clipPose.sub) {\n            continue;\n        }\n        if (clipPose.horizontal) {\n            if (horizontalRange[1] === 0) {\n                horizontalRange[0] = i;\n            }\n            horizontalRange[1] = i - horizontalRange[0] + 1;\n            verticalRange[0] = i + 1;\n        }\n        if (clipPose.vertical) {\n            if (verticalRange[1] === 0) {\n                verticalRange[0] = i;\n            }\n            verticalRange[1] = i - verticalRange[0] + 1;\n        }\n    }\n\n    return {\n        horizontalRange,\n        verticalRange,\n    };\n}\nexport function getRadiusValues(\n    values: string[],\n    width: number,\n    height: number,\n    left: number,\n    top: number,\n): ControlPose[] {\n    const splitIndex = values.indexOf(\"/\");\n    const splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;\n    const horizontalValues = values.slice(0, splitLength);\n    const verticalValues = values.slice(splitLength + 1);\n    const [\n        nwValue = \"0\",\n        neValue = nwValue,\n        seValue = nwValue,\n        swValue = neValue,\n    ] = horizontalValues;\n    const [\n        wnValue = nwValue,\n        enValue = wnValue,\n        esValue = wnValue,\n        wsValue = enValue,\n    ] = verticalValues;\n\n    const horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(pos => getUnitSize(pos, width));\n    const verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(pos => getUnitSize(pos, height));\n    const horizontalPoses = horizontalRawPoses.slice();\n    const verticalPoses = verticalRawPoses.slice();\n\n    [horizontalPoses[0], horizontalPoses[1]] = caculateRatio([horizontalPoses[0], horizontalPoses[1]], width);\n    [horizontalPoses[3], horizontalPoses[2]] = caculateRatio([horizontalPoses[3], horizontalPoses[2]], width);\n    [verticalPoses[0], verticalPoses[3]] = caculateRatio([verticalPoses[0], verticalPoses[3]], height);\n    [verticalPoses[1], verticalPoses[2]] = caculateRatio([verticalPoses[1], verticalPoses[2]], height);\n\n    const nextHorizontalPoses = horizontalPoses.slice(0, horizontalValues.length);\n    const nextVerticalPoses = verticalPoses.slice(0, verticalValues.length);\n    return [\n        ...nextHorizontalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],\n                sub: true,\n                raw: horizontalRawPoses[i],\n                direction,\n            };\n        }),\n        ...nextVerticalPoses.map((pos, i) => {\n            const direction = RADIUS_DIRECTIONS[i];\n\n            return {\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],\n                sub: true,\n                raw: verticalRawPoses[i],\n                direction,\n            };\n        }),\n    ];\n}\nexport function removeRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    index: number,\n    startIndex: number,\n    length: number = poses.length,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    const radiuslIndex = index - startIndex;\n    let deleteCount = 0;\n\n    if (radiuslIndex === 0) {\n        deleteCount = length;\n    } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {\n        deleteCount = horizontalRange[1] - radiuslIndex;\n    } else if (radiuslIndex >= verticalRange[0]) {\n        deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;\n    } else {\n        return;\n    }\n    controlPoses.splice(index, deleteCount);\n    poses.splice(index, deleteCount);\n}\nexport function addRadiusPos(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    startIndex: number,\n    horizontalIndex: number,\n    verticalIndex: number,\n    distX: number,\n    distY: number,\n    right: number,\n    bottom: number,\n    left: number = 0,\n    top: number = 0,\n) {\n    const {\n        horizontalRange,\n        verticalRange,\n    } = getRadiusRange(controlPoses.slice(startIndex));\n    if (horizontalIndex > -1) {\n        const radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1\n            ? distX - left\n            : right - distX;\n        for (let i = horizontalRange[1]; i <= horizontalIndex; ++i) {\n            const y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;\n            let x = 0;\n            if (horizontalIndex === i) {\n                x = distX;\n            } else if (i === 0) {\n                x = left + radiusX;\n            } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {\n                x = right - (poses[startIndex][0] - left);\n            }\n            controlPoses.splice(startIndex + i, 0, {\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],\n                vertical: 0,\n                pos: [x, y],\n            });\n            poses.splice(startIndex + i, 0, [x, y]);\n\n            if (i === 0) {\n                break;\n            }\n        }\n    } else if (verticalIndex > - 1) {\n        const radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1\n            ? distY - top\n            : bottom - distY;\n        if (horizontalRange[1] === 0 && verticalRange[1] === 0) {\n            const pos = [\n                left + radiusY,\n                top,\n            ];\n            controlPoses.push({\n                horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],\n                vertical: 0,\n                pos,\n            });\n            poses.push(pos);\n        }\n\n        const startVerticalIndex = verticalRange[0];\n        for (let i = verticalRange[1]; i <= verticalIndex; ++i) {\n            const x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;\n            let y = 0;\n            if (verticalIndex === i) {\n                y = distY;\n            } else if (i === 0) {\n                y = top + radiusY;\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {\n                y = poses[startIndex + startVerticalIndex][1];\n            } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {\n                y = bottom - (poses[startIndex + startVerticalIndex][1] - top);\n            }\n            controlPoses.push({\n                horizontal: 0,\n                vertical: VERTICAL_RADIUS_DIRECTIONS[i],\n                pos: [x, y],\n            });\n            poses.push([x, y]);\n            if (i === 0) {\n                break;\n            }\n        }\n    }\n}\nexport function splitRadiusPoses(\n    controlPoses: ControlPose[],\n    raws: number[] = controlPoses.map(pos => pos.raw!),\n) {\n    const horizontals = controlPoses\n    .map((pos , i) => pos.horizontal ? raws[i] : null).filter(pos => pos != null) as number[];\n    const verticals = controlPoses\n        .map((pos , i) => pos.vertical ? raws[i] : null).filter(pos => pos != null) as number[];\n\n    return {\n        horizontals,\n        verticals,\n    };\n}\n","import {\n    Renderer, ClippableProps, OnClip,\n    ClippableState, OnClipEnd, OnClipStart,\n    ControlPose, MoveableManagerInterface\n} from \"../types\";\nimport { splitBracket, splitComma, splitUnit, splitSpace } from \"@daybrush/utils\";\nimport {\n    prefix, caculatePosition, getDiagonalSize,\n    fillParams, triggerEvent,\n    makeMatrixCSS, getRect, fillEndParams, getUnitSize, convertCSSSize, moveControlPos, caculatePointerDist\n} from \"../utils\";\nimport { getRad, plus, minus } from \"../matrix\";\nimport { setDragStart, getDragDist } from \"../DraggerUtils\";\nimport {\n    getRadiusValues,\n    HORIZONTAL_RADIUS_ORDER, VERTICAL_RADIUS_ORDER, getRadiusStyles, addRadiusPos, removeRadiusPos\n} from \"./roundable/borderRadius\";\n\nconst CLIP_DIRECTIONS = [\n    [0, -1, \"n\"],\n    [1, 0, \"e\"],\n] as const;\nconst CLIP_RECT_DIRECTIONS = [\n    [-1, -1, \"nw\"],\n    [0, -1, \"n\"],\n    [1, -1, \"ne\"],\n    [1, 0, \"e\"],\n    [1, 1, \"se\"],\n    [0, 1, \"s\"],\n    [-1, 1, \"sw\"],\n    [-1, 0, \"w\"],\n] as const;\n\n// 1 2 5 6 0 3 4 7\n// 0 1 2 3 4 5 6 7\n\nfunction getClipStyles(\n    moveable: MoveableManagerInterface<ClippableProps>,\n    clipPath: ReturnType<typeof getClipPath>,\n    poses: number[][],\n) {\n    const {\n        clipRelative,\n    } = moveable.props;\n    const {\n        width,\n        height,\n    } = moveable.state;\n    const {\n        type: clipType,\n        poses: clipPoses,\n    } = clipPath!;\n\n    const isRect = clipType === \"rect\";\n    const isCircle = clipType === \"circle\";\n    if (clipType === \"polygon\") {\n        return poses.map(pos => `${\n            convertCSSSize(pos[0], width, clipRelative)\n            } ${\n            convertCSSSize(pos[1], height, clipRelative)\n            }`);\n    } else if (isRect || clipType === \"inset\") {\n        const top = poses[1][1];\n        const right = poses[3][0];\n        const left = poses[7][0];\n        const bottom = poses[5][1];\n\n        if (isRect) {\n            return [\n                top,\n                right,\n                bottom,\n                left,\n            ].map(pos => `${pos}px`);\n        }\n        const clipStyles\n            = [top, width - right, height - bottom, left]\n                .map((pos, i) => convertCSSSize(pos, i % 2 ? width : height, clipRelative));\n\n        if (poses.length > 8) {\n            const [subWidth, subHeight] = minus(poses[4], poses[0]);\n\n            clipStyles.push(\"round\", ...getRadiusStyles(\n                poses.slice(8),\n                clipPoses.slice(8),\n                clipRelative!,\n                subWidth,\n                subHeight,\n                left, top, right, bottom,\n            ).styles);\n        }\n        return clipStyles;\n    } else if (isCircle || clipType === \"ellipse\") {\n        const center = poses[0];\n        const ry = convertCSSSize(\n            Math.abs(poses[1][1] - center[1]),\n            isCircle ? Math.sqrt((width * width + height * height) / 2) : height,\n            clipRelative,\n        );\n\n        const clipStyles = isCircle ? [ry]\n            : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];\n\n        clipStyles.push(\n            \"at\", convertCSSSize(center[0], width, clipRelative),\n            convertCSSSize(center[1], height, clipRelative));\n\n        return clipStyles;\n    }\n}\nfunction getRectPoses(top: number, right: number, bottom: number, left: number): ControlPose[] {\n    const xs = [left, (left + right) / 2, right];\n    const ys = [top, (top + bottom) / 2, bottom];\n\n    return CLIP_RECT_DIRECTIONS.map(([dirx, diry, dir]) => {\n        const x = xs[dirx + 1];\n        const y = ys[diry + 1];\n        return {\n            vertical: Math.abs(diry),\n            horizontal: Math.abs(dirx),\n            direction: dir,\n            pos: [x, y],\n        };\n    });\n}\nfunction getClipPath(\n    target: HTMLElement | SVGElement,\n    width: number,\n    height: number,\n    defaultClip?: string,\n    customClip?: string,\n) {\n    let clipText: string | undefined = customClip;\n\n    if (!clipText) {\n        const style = getComputedStyle(target!);\n        const clipPath = style.clipPath!;\n\n        clipText = clipPath !== \"none\" ? clipPath : style.clip!;\n    }\n    if (!clipText || clipText === \"none\" || clipText === \"auto\") {\n        clipText = defaultClip;\n\n        if (!clipText) {\n            return;\n        }\n    }\n    const {\n        prefix: clipPrefix = clipText,\n        value = \"\",\n    } = splitBracket(clipText);\n    const isCircle = clipPrefix === \"circle\";\n    let splitter = \" \";\n\n    if (clipPrefix === \"polygon\") {\n        const values = splitComma(value! || `0% 0%, 100% 0%, 100% 100%, 0% 100%`);\n        splitter = \",\";\n\n        const poses: ControlPose[] = values.map(pos => {\n            const [xPos, yPos] = pos.split(\" \");\n\n            return {\n                vertical: 1,\n                horizontal: 1,\n                pos: [\n                    getUnitSize(xPos, width),\n                    getUnitSize(yPos, height),\n                ],\n            };\n        });\n\n        return {\n            type: clipPrefix,\n            clipText,\n            poses,\n            splitter,\n        } as const;\n    } else if (isCircle || clipPrefix === \"ellipse\") {\n        let xPos: string = \"\";\n        let yPos: string = \"\";\n        let radiusX = 0;\n        let radiusY = 0;\n        const values = splitSpace(value!);\n\n        if (isCircle) {\n            let radius = \"\";\n            [radius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = getUnitSize(radius, Math.sqrt((width * width + height * height) / 2));\n            radiusY = radiusX;\n        } else {\n            let xRadius = \"\";\n            let yRadius = \"\";\n            [xRadius = \"50%\", yRadius = \"50%\", , xPos = \"50%\", yPos = \"50%\"] = values;\n\n            radiusX = getUnitSize(xRadius, width);\n            radiusY = getUnitSize(yRadius, height);\n        }\n        const centerPos = [\n            getUnitSize(xPos, width),\n            getUnitSize(yPos, height),\n        ];\n        const poses: ControlPose[] = [\n            {\n                vertical: 1,\n                horizontal: 1,\n                pos: centerPos,\n                direction: \"nesw\",\n            },\n            ...CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(dir => ({\n                vertical: Math.abs(dir[1]),\n                horizontal: dir[0],\n                direction: dir[2],\n                sub: true,\n                pos: [\n                    centerPos[0] + dir[0] * radiusX,\n                    centerPos[1] + dir[1] * radiusY,\n                ],\n            })),\n        ];\n        return {\n            type: clipPrefix as \"circle\" | \"ellipse\",\n            clipText,\n            radiusX,\n            radiusY,\n            left: centerPos[0] - radiusX,\n            top: centerPos[1] - radiusY,\n            poses,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"inset\") {\n        const values = splitSpace(value! || \"0 0 0 0\");\n        const roundIndex = values.indexOf(\"round\");\n\n        const rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;\n        const radiusValues = values.slice(rectLength + 1);\n        const [\n            topValue,\n            rightValue = topValue,\n            bottomValue = topValue,\n            leftValue = rightValue,\n        ] = values.slice(0, rectLength);\n        const [top, bottom] = [topValue, bottomValue].map(pos => getUnitSize(pos, height));\n        const [left, right] = [leftValue, rightValue].map(pos => getUnitSize(pos, width));\n        const nextRight = width - right;\n        const nextBottom = height - bottom;\n        const radiusPoses = getRadiusValues(\n            radiusValues,\n            nextRight - left,\n            nextBottom - top,\n            left,\n            top,\n        );\n        const poses: ControlPose[] = [\n            ...getRectPoses(top, nextRight, nextBottom, left),\n            ...radiusPoses,\n        ];\n\n        return {\n            type: \"inset\",\n            clipText,\n            poses,\n            top,\n            left,\n            right: nextRight,\n            bottom: nextBottom,\n            radius: radiusValues,\n            splitter,\n        } as const;\n    } else if (clipPrefix === \"rect\") {\n        // top right bottom left\n        const values = splitComma(value! || `0px, ${width}px, ${height}px, 0px`);\n\n        splitter = \",\";\n        const [top, right, bottom, left] = values.map((pos, i) => {\n            const { value: posValue } = splitUnit(pos);\n\n            return posValue;\n        });\n        const poses = getRectPoses(top, right, bottom, left);\n\n        return {\n            type: \"rect\",\n            clipText,\n            poses,\n            top,\n            right,\n            bottom,\n            left,\n            values,\n            splitter,\n        } as const;\n    }\n    return;\n}\nfunction addClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const [distX, distY] = caculatePointerDist(moveable, e);\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    if (clipType === \"polygon\") {\n        poses.splice(index, 0, [distX, distY]);\n    } else if (clipType === \"inset\") {\n        const horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index);\n        const verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index);\n        const length = clipPoses.length;\n\n        addRadiusPos(\n            clipPoses,\n            poses,\n            8,\n            horizontalIndex,\n            verticalIndex,\n            distX,\n            distY,\n            poses[4][0],\n            poses[4][1],\n            poses[0][0],\n            poses[0][1],\n        );\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"added\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\nfunction removeClipPath(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n    const { clipPath, index } = e.datas;\n    const {\n        type: clipType,\n        poses: clipPoses,\n        splitter,\n    } = (clipPath as ReturnType<typeof getClipPath>)!;\n    const poses = clipPoses.map(pos => pos.pos);\n    const length = poses.length;\n    if (clipType === \"polygon\") {\n        clipPoses.splice(index, 1);\n        poses.splice(index, 1);\n    } else if (clipType === \"inset\") {\n        if (index < 8) {\n            return;\n        }\n        removeRadiusPos(clipPoses, poses, index, 8, length);\n\n        if (length === clipPoses.length) {\n            return;\n        }\n    } else {\n        return;\n    }\n    const clipStyles = getClipStyles(moveable, clipPath, poses)!;\n    triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n        clipEventType: \"removed\",\n        clipType,\n        poses,\n        clipStyles,\n        clipStyle: `${clipType}(${clipStyles.join(splitter)})`,\n        distX: 0,\n        distY: 0,\n    }));\n}\n/**\n * @namespace Moveable.Clippable\n * @description Whether to clip the target.\n */\n\nexport default {\n    name: \"clippable\",\n    props: {\n        clippable: Boolean,\n        defaultClipPath: String,\n        customClipPath: String,\n        clipRelative: Boolean,\n        clipArea: Boolean,\n        dragWithClip: Boolean,\n    } as const,\n    events: {\n        onClipStart: \"clipStart\",\n        onClip: \"clip\",\n        onClipEnd: \"clipEnd\",\n    } as const,\n    css: [\n        `.control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, React: Renderer): any[] {\n        const {\n            customClipPath, defaultClipPath,\n            clipArea, zoom,\n        } = moveable.props;\n        const {\n            target, width, height, matrix, is3d, left, top,\n            pos1, pos2, pos3, pos4,\n            clipPathState,\n        } = moveable.state;\n\n        if (!target) {\n            return [];\n        }\n\n        const clipPath = getClipPath(\n            target, width, height, defaultClipPath || \"inset\", clipPathState || customClipPath);\n\n        if (!clipPath) {\n            return [];\n        }\n        const n = is3d ? 4 : 3;\n        const type = clipPath.type;\n        const clipPoses = clipPath.poses;\n        const poses = clipPoses.map(pos => {\n            // return [x, y];\n            const caculatedPos = caculatePosition(matrix, pos.pos, n);\n\n            return [\n                caculatedPos[0] - left,\n                caculatedPos[1] - top,\n            ];\n        });\n\n        let controls: any[] = [];\n        let lines: any[] = [];\n\n        const isRect = type === \"rect\";\n        const isInset = type === \"inset\";\n        const isPolygon = type === \"polygon\";\n\n        if (isRect || isInset || isPolygon) {\n            const linePoses = isInset ? poses.slice(0, 8) : poses;\n\n            lines = linePoses.map((to, i) => {\n                const from = i === 0 ? linePoses[linePoses.length - 1] : linePoses[i - 1];\n\n                const rad = getRad(from, to);\n                const dist = getDiagonalSize(from, to);\n                return <div key={`clipLine${i}`} className={prefix(\"line\", \"clip-line\")}\n                    data-clip-index={i}\n                    style={{\n                        width: `${dist}px`,\n                        transform: `translate(${from[0]}px, ${from[1]}px) rotate(${rad}rad)`,\n                    }}></div>;\n            });\n        }\n        controls = poses.map((pos, i) => {\n            return <div key={`clipControl${i}`}\n                className={prefix(\"control\", \"clip-control\")}\n                data-clip-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                }}></div>;\n        });\n\n        if (isInset) {\n            controls.push(...poses.slice(8).map((pos, i) => {\n                return <div key={`clipRadiusControl${i}`}\n                    className={prefix(\"control\", \"clip-control\", \"clip-radius\")}\n                    data-clip-index={8 + i}\n                    style={{\n                        transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                    }}></div>;\n            }));\n        }\n        if (type === \"circle\" || type === \"ellipse\") {\n            const {\n                left: clipLeft,\n                top: clipTop,\n                radiusX,\n                radiusY,\n            } = clipPath;\n\n            const [distLeft, distTop] = minus(\n                caculatePosition(matrix, [clipLeft!, clipTop!], n),\n                caculatePosition(matrix, [0, 0], n),\n            );\n            let ellipseClipPath = \"none\";\n\n            if (!clipArea) {\n                const piece = Math.max(10, radiusX! / 5, radiusY! / 5);\n                const areaPoses: number[][] = [];\n\n                for (let i = 0; i <= piece; ++i) {\n                    const rad = Math.PI * 2 / piece * i;\n                    areaPoses.push([\n                        radiusX! + (radiusX! - zoom!) * Math.cos(rad),\n                        radiusY! + (radiusY! - zoom!) * Math.sin(rad),\n                    ]);\n                }\n                areaPoses.push([radiusX!, -2]);\n                areaPoses.push([-2, -2]);\n                areaPoses.push([-2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, radiusY! * 2 + 2]);\n                areaPoses.push([radiusX! * 2 + 2, -2]);\n                areaPoses.push([radiusX!, -2]);\n\n                ellipseClipPath = `polygon(${areaPoses.map(pos => `${pos[0]}px ${pos[1]}px`).join(\", \")})`;\n            }\n            controls.push(<div key=\"clipEllipse\" className={prefix(\"clip-ellipse\")} style={{\n                width: `${radiusX! * 2}px`,\n                height: `${radiusY! * 2}px`,\n                clipPath: ellipseClipPath,\n                transform: `translate(${-left + distLeft}px, ${-top + distTop}px) ${makeMatrixCSS(matrix)}`,\n            }}></div>);\n        }\n        if (clipArea) {\n            const {\n                width: allWidth,\n                height: allHeight,\n                left: allLeft,\n                top: allTop,\n            } = getRect([pos1, pos2, pos3, pos4, ...poses]);\n            if (isPolygon || isRect || isInset) {\n                const areaPoses = isInset ? poses.slice(0, 8) : poses;\n                controls.push(<div key=\"clipArea\" className={prefix(\"clip-area\")} style={{\n                    width: `${allWidth}px`,\n                    height: `${allHeight}px`,\n                    transform: `translate(${allLeft}px, ${allTop}px)`,\n                    clipPath: `polygon(${\n                        areaPoses.map(pos => `${pos[0] - allLeft}px ${pos[1] - allTop}px`).join(\", \")\n                        })`,\n                }}></div>);\n            }\n        }\n        return [\n            ...controls,\n            ...lines,\n        ];\n    },\n    dragControlCondition(e: any) {\n        return e.inputEvent && (e.inputEvent.target.className || \"\").indexOf(\"clip\") > -1;\n    },\n    dragStart(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            dragWithClip = true,\n        } = props;\n\n        if (dragWithClip) {\n            return false;\n        }\n\n        return this.dragControlStart(moveable, e);\n    },\n    drag(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        return this.dragControl(moveable, e);\n    },\n    dragEnd(moveable: MoveableManagerInterface<ClippableProps>, e: any) {\n        return this.dragControlEnd(moveable, e);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const state = moveable.state;\n        const { defaultClipPath, customClipPath } = moveable.props;\n        const { target, width, height } = state;\n        const inputTarget = e.inputEvent ? e.inputEvent.target : null;\n        const className = inputTarget ? inputTarget.className : \"\";\n        const datas = e.datas;\n        const clipPath = getClipPath(target!, width, height, defaultClipPath || \"inset\", customClipPath);\n\n        if (!clipPath) {\n            return false;\n        }\n        const { clipText, type, poses } = clipPath;\n        const result = triggerEvent<ClippableProps>(moveable, \"onClipStart\", fillParams<OnClipStart>(moveable, e, {\n            clipType: type,\n            clipStyle: clipText,\n            poses: poses.map(pos => pos.pos),\n        }));\n\n        if (result === false) {\n            datas.isClipStart = false;\n            return false;\n        }\n        datas.isControl = className.indexOf(\"clip-control\") > -1;\n        datas.isLine = className.indexOf(\"clip-line\") > -1;\n        datas.isArea = className.indexOf(\"clip-area\") > -1 || className.indexOf(\"clip-ellipse\") > -1;\n        datas.index = inputTarget ? parseInt(inputTarget.getAttribute(\"data-clip-index\"), 10) : -1;\n        datas.clipPath = clipPath;\n        datas.isClipStart = true;\n        state.clipPathState = clipText;\n        setDragStart(moveable, e);\n\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        const { datas, originalDatas } = e;\n\n        if (!datas.isClipStart) {\n            return false;\n        }\n        const draggableData = (originalDatas && originalDatas.draggable) || {};\n        const { isControl, isLine, isArea, index, clipPath } = datas as {\n            clipPath: ReturnType<typeof getClipPath>,\n            [key: string]: any,\n        };\n        if (!clipPath) {\n            return false;\n        }\n        let [distX, distY] = draggableData.isDrag ? draggableData.prevDist : getDragDist(e);\n        const state = moveable.state;\n        const isDragWithTarget = !isArea && !isControl && !isLine;\n        const {\n            type: clipType,\n            poses: clipPoses,\n            splitter,\n        } = clipPath;\n        const poses = clipPoses.map(pos => pos.pos);\n        const nextPoses: number[][] = poses.map(pos => pos.slice());\n\n        if (isDragWithTarget) {\n            distX = -distX;\n            distY = -distY;\n        }\n        const isAll = !isControl || clipPoses[index].direction === \"nesw\";\n\n        if (isControl && !isAll) {\n            moveControlPos(clipPoses, nextPoses, index, distX, distY);\n        }\n        if (isAll) {\n            poses.forEach((pos, i) => {\n                nextPoses[i] = plus(pos, [distX, distY]);\n            });\n        }\n        // const indexes: number[] = [];\n        // const clipStyles = getClipStyles(clipPath, width, height, clipPoses.map(pos => pos.pos))!;\n        const nextClipStyles = getClipStyles(moveable, clipPath, nextPoses)!;\n        const clipStyle = `${clipType}(${nextClipStyles.join(splitter)})`;\n\n        state.clipPathState = clipStyle;\n        triggerEvent<OnClip>(moveable, \"onClip\", fillParams<OnClip>(moveable, e, {\n            clipEventType: \"changed\",\n            clipType,\n            poses: nextPoses,\n            clipStyle,\n            clipStyles: nextClipStyles,\n            distX,\n            distY,\n        }));\n\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<ClippableProps, ClippableState>, e: any) {\n        moveable.state.clipPathState = \"\";\n        const { isDrag, datas, isDouble } = e;\n        const { isLine, isClipStart, isControl } = datas;\n\n        if (!isClipStart) {\n            return false;\n        }\n        triggerEvent<ClippableProps>(moveable, \"onClipEnd\", fillEndParams<OnClipEnd>(moveable, e, {}));\n        if (isDouble) {\n            if (isControl) {\n                removeClipPath(moveable, e);\n            } else if (isLine) {\n                // add\n                addClipPath(moveable, e);\n            }\n        }\n        return isDouble || isDrag;\n    },\n    unset(moveable: MoveableManagerInterface<ClippableProps, ClippableState>) {\n        moveable.state.clipPathState = \"\";\n    },\n};\n\n/**\n * Whether to clip the target. (default: false)\n * @name Moveable.Clippable#clippable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n *  If clippath is not set, the default value can be set. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#defaultClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (`rect` not possible) (default: false)\n * @name Moveable.Clippable#clipRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can force the custom clipPath. (defaultClipPath < style < customClipPath < dragging clipPath)\n * @name Moveable.Clippable#customClipPath\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When dragging the target, the clip also moves. (default: true)\n * @name Moveable.Clippable#dragWithClip\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * You can drag the clip by setting clipArea. (default: false)\n * @name Moveable.Clippable#clipArea\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag start the clip area or controls, the `clipStart` event is called.\n * @memberof Moveable.Clippable\n * @event clipStart\n * @param {Moveable.Clippable.OnClipStart} - Parameters for the `clipStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag the clip area or controls, the `clip` event is called.\n * @memberof Moveable.Clippable\n * @event clip\n * @param {Moveable.Clippable.OnClip} - Parameters for the `clip` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the clip area or controls, the `clipEnd` event is called.\n * @memberof Moveable.Clippable\n * @event clipEnd\n * @param {Moveable.Clippable.OnClipEnd} - Parameters for the `clipEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     clippable: true,\n *     defaultClipPath: \"inset\",\n *     customClipPath: \"\",\n *     clipRelative: false,\n *     clipArea: false,\n *     dragWithClip: true,\n * });\n * moveable.on(\"clipStart\", e => {\n *     console.log(e);\n * }).on(\"clip\", e => {\n *     if (e.clipType === \"rect\") {\n *         e.target.style.clip = e.clipStyle;\n *     } else {\n *         e.target.style.clipPath = e.clipStyle;\n *     }\n * }).on(\"clipEnd\", e => {\n *     console.log(e);\n * });\n */\n","import {\n    prefix, triggerEvent,\n    fillParams, caculatePoses, getRect, fillEndParams, convertCSSSize\n} from \"../utils\";\nimport {\n    OnDragOriginStart, OnDragOrigin,\n    OnDragOriginEnd, MoveableManagerInterface, DraggableProps, OriginDraggableProps, MoveableGroupInterface\n} from \"../types\";\nimport { hasClass, IObject } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist, getNextMatrix } from \"../DraggerUtils\";\nimport { minus, plus } from \"../matrix\";\nimport Draggable from \"./Draggable\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\n\n/**\n * @namespace OriginDraggable\n * @memberof Moveable\n * @description Whether to drag origin (default: false)\n */\nexport default {\n    name: \"originDraggable\",\n    props: {\n        originDraggable: Boolean,\n        originRelative: Boolean,\n    } as const,\n    events: {\n        onDragOriginStart: \"dragOriginStart\",\n        onDragOrigin: \"dragOrigin\",\n        onDragOriginEnd: \"dragOriginEnd\",\n    } as const,\n    css: [\n        `:host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}`,\n    ],\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return e.requestAble === \"originDraggable\";\n        }\n        return hasClass(e.inputEvent.target, prefix(\"origin\"));\n    },\n    dragControlStart(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { inputEvent, datas } = e;\n\n        setDragStart(moveable, e);\n\n        const params = fillParams<OnDragOriginStart>(moveable, e, {\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent<OriginDraggableProps>(\n            moveable, \"onDragOriginStart\", params);\n\n        datas.startOrigin = moveable.state.transformOrigin;\n        datas.startTargetOrigin = moveable.state.targetOrigin;\n        datas.prevOrigin = [0, 0];\n        datas.isDragOrigin = true;\n\n        if (result === false) {\n            datas.isDragOrigin = false;\n            return false;\n        }\n\n        return params;\n    },\n    dragControl(moveable: MoveableManagerInterface<OriginDraggableProps & DraggableProps>, e: any) {\n        const { datas, inputEvent, isPinch, isRequest } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        const [distX, distY] = getDragDist(e);\n        const state = moveable.state;\n        const {\n            width,\n            height,\n            offsetMatrix,\n            targetMatrix,\n            is3d,\n        } = state;\n        const {\n            originRelative = true,\n        } = moveable.props;\n        const n = is3d ? 4 : 3;\n        let dist = [distX, distY];\n\n        if (isRequest) {\n            const distOrigin = e.distOrigin;\n            if (distOrigin[0] || distOrigin[1]) {\n                dist = distOrigin;\n            }\n        }\n        const origin = plus(datas.startOrigin, dist);\n        const targetOrigin = plus(datas.startTargetOrigin, dist);\n        const delta = minus(dist, datas.prevOrigin);\n\n        const nextMatrix = getNextMatrix(\n            offsetMatrix,\n            targetMatrix,\n            origin,\n            n,\n        );\n\n        const rect = moveable.getRect();\n        const nextRect = getRect(caculatePoses(nextMatrix, width, height, n));\n\n        const dragDelta = [\n            rect.left - nextRect.left,\n            rect.top - nextRect.top,\n        ];\n\n        datas.prevOrigin = dist;\n        const transformOrigin = [\n            convertCSSSize(targetOrigin[0], width, originRelative),\n            convertCSSSize(targetOrigin[1], height, originRelative),\n        ].join(\" \");\n        const params = fillParams<OnDragOrigin>(moveable, e, {\n            width,\n            height,\n            origin,\n            dist,\n            delta,\n            transformOrigin,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, dragDelta, inputEvent, !!isPinch, false),\n            )!,\n        });\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOrigin\", params);\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<OriginDraggableProps>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isDragOrigin) {\n            return false;\n        }\n        triggerEvent<OriginDraggableProps>(moveable, \"onDragOriginEnd\",\n            fillEndParams<OnDragOriginEnd>(moveable, e, {}));\n        return true;\n    },\n    dragGroupControlCondition(e: any) {\n        return this.dragControlCondition(e);\n    },\n    dragGroupControlStart(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        return true;\n    },\n    dragGroupControl(moveable: MoveableGroupInterface<OriginDraggableProps>, e: any) {\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        moveable.transformOrigin = params.transformOrigin;\n\n        return true;\n    },\n    /**\n    * @method Moveable.OriginDraggable#request\n    * @param {object} e - the OriginDraggable's request parameter\n    * @param {number} [e.x] - x position\n    * @param {number} [e.y] - y position\n    * @param {number} [e.deltaX] - x number to move\n    * @param {number} [e.deltaY] - y number to move\n    * @param {array} [e.deltaOrigin] - left, top number to move transform-origin\n    * @param {array} [e.origin] - transform-origin position\n    * @param {number} [e.isInstant] - Whether to execute the request instantly\n    * @return {Moveable.Requester} Moveable Requester\n    * @example\n\n    * // Instantly Request (requestStart - request - requestEnd)\n    * // Use Relative Value\n    * moveable.request(\"originDraggable\", { deltaX: 10, deltaY: 10 }, true);\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 }, true);\n    * // Use Transform Value\n    * moveable.request(\"originDraggable\", { deltaOrigin: [10, 0] }, true);\n    * moveable.request(\"originDraggable\", { origin: [100, 0] }, true);\n    * // requestStart\n    * const requester = moveable.request(\"originDraggable\");\n    *\n    * // request\n    * // Use Relative Value\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * requester.request({ deltaX: 10, deltaY: 10 });\n    * // Use Absolute Value\n    * moveable.request(\"originDraggable\", { x: 200, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 220, y: 100 });\n    * moveable.request(\"originDraggable\", { x: 240, y: 100 });\n    *\n    * // requestEnd\n    * requester.requestEnd();\n    */\n    request(moveable: MoveableManagerInterface<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        const transformOrigin = rect.transformOrigin;\n        const distOrigin = [0, 0];\n\n        return {\n            isControl: true,\n            requestStart() {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"deltaOrigin\" in e) {\n                    distOrigin[0] += e.deltaOrigin[0];\n                    distOrigin[1] += e.deltaOrigin[1];\n                } else if (\"origin\" in e) {\n                    distOrigin[0] = e.origin[0] - transformOrigin[0];\n                    distOrigin[1] = e.origin[1] - transformOrigin[1];\n                } else {\n                    if (\"x\" in e) {\n                        distX = e.x - rect.left;\n                    } else if (\"deltaX\" in e) {\n                        distX += e.deltaX;\n                    }\n                    if (\"y\" in e) {\n                        distY = e.y - rect.top;\n                    } else if (\"deltaY\" in e) {\n                        distY += e.deltaY;\n                    }\n                }\n\n                return { datas, distX, distY, distOrigin };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n/**\n * Whether to drag origin (default: false)\n * @name Moveable.OriginDraggable#originDraggable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n * });\n * let translate = [0, 0];\n * moveable.on(\"dragOriginStart\", e => {\n *     e.dragStart && e.dragStart.set(translate);\n * }).on(\"dragOrigin\", e => {\n *     translate = e.drag.beforeTranslate;\n *     e.target.style.cssText\n *         = `transform-origin: ${e.transformOrigin};`\n *         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n * }).on(\"dragOriginEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * % Can be used instead of the absolute px (default: true)\n * @name Moveable.OriginDraggable#originRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     originDraggable: true,\n *     originRelative: false,\n * });\n * moveable.originRelative = true;\n */\n\n/**\n* When drag start the origin, the `dragOriginStart` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginStart\n* @param {Moveable.OriginDraggable.OnDragOriginStart} - Parameters for the `dragOriginStart` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag the origin, the `dragOrigin` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOrigin\n* @param {Moveable.OriginDraggable.OnDragOrigin} - Parameters for the `dragOrigin` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n\n/**\n* When drag end the origin, the `dragOriginEnd` event is called.\n* @memberof Moveable.OriginDraggable\n* @event dragOriginEnd\n* @param {Moveable.OriginDraggable.OnDragOriginEnd} - Parameters for the `dragOriginEnd` event\n* @example\n* import Moveable from \"moveable\";\n*\n* const moveable = new Moveable(document.body, {\n*     originDraggable: true,\n* });\n* let translate = [0, 0];\n* moveable.on(\"dragOriginStart\", e => {\n*     e.dragStart && e.dragStart.set(translate);\n* }).on(\"dragOrigin\", e => {\n*     translate = e.drag.beforeTranslate;\n*     e.target.style.cssText\n*         = `transform-origin: ${e.transformOrigin};`\n*         + `transform: translate(${translate[0]}px, ${translate[1]}px)`;\n* }).on(\"dragOriginEnd\", e => {\n*     console.log(e);\n* });\n*/\n","import {\n    prefix, triggerEvent,\n    fillParams, fillEndParams, caculatePosition, moveControlPos, caculatePointerDist\n} from \"../utils\";\nimport {\n    Renderer, RoundableProps, OnRoundStart, RoundableState, OnRound, ControlPose, OnRoundEnd, MoveableManagerInterface,\n} from \"../types\";\nimport { splitSpace } from \"@daybrush/utils\";\nimport { setDragStart, getDragDist } from \"../DraggerUtils\";\nimport { minus } from \"../matrix\";\nimport {\n    getRadiusValues, getRadiusStyles, removeRadiusPos,\n    addRadiusPos, splitRadiusPoses\n} from \"./roundable/borderRadius\";\n\nfunction addBorderRadius(\n    controlPoses: ControlPose[],\n    poses: number[][],\n    lineIndex: number,\n    distX: number,\n    distY: number,\n    width: number,\n    height: number,\n) {\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses);\n    const horizontalsLength = horizontals.length;\n    const verticalsLength = verticals.length;\n    // lineIndex\n    // 0 top\n    // 1 right\n    // 2 left\n    // 3 bottom\n\n    // 0 top - left\n    // 1 top - right\n    // 2 bottom - right\n    // 3 bottom - left\n    // 0 left - top\n    // 1 right - top\n    // 2 right - bottom\n    // 3 left - bottom\n    let horizontalIndex = -1;\n    let verticalIndex = -1;\n\n    if (lineIndex === 0) {\n        if (horizontalsLength === 0) {\n            horizontalIndex = 0;\n        } else if (horizontalsLength === 1) {\n            horizontalIndex = 1;\n        }\n    } else if (lineIndex === 3) {\n        if (horizontalsLength <= 2) {\n            horizontalIndex = 2;\n        } else if (horizontalsLength <= 3) {\n            horizontalIndex = 3;\n        }\n    }\n    if (lineIndex === 2) {\n        if (verticalsLength === 0) {\n            verticalIndex = 0;\n        } else if (verticalsLength < 4) {\n            verticalIndex = 3;\n        }\n    } else if (lineIndex === 1) {\n        if (verticalsLength <= 1) {\n            verticalIndex = 1;\n        } else if (verticalsLength <= 2) {\n            verticalIndex = 2;\n        }\n    }\n\n    addRadiusPos(\n        controlPoses, poses, 0,\n        horizontalIndex, verticalIndex,\n        distX, distY, width, height,\n    );\n}\nfunction getBorderRadius(\n    target: HTMLElement | SVGElement, width: number, height: number, state?: string,\n) {\n    let borderRadius: string;\n\n    if (!state) {\n        const style = window.getComputedStyle(target);\n\n        if (!style) {\n            return null;\n        }\n        borderRadius = style.borderRadius || \"\";\n    } else {\n        borderRadius = state;\n    }\n    if (!borderRadius || (!state && borderRadius === \"0px\")) {\n        return null;\n    }\n    const values = splitSpace(borderRadius);\n\n    return getRadiusValues(values, width, height, 0, 0);\n}\n\nfunction triggerRoundEvent(\n    moveable: MoveableManagerInterface<RoundableProps, RoundableState>,\n    e: any,\n    dist: number[],\n    delta: number[],\n    controlPoses: ControlPose[],\n    nextPoses: number[][],\n) {\n    const state = moveable.state;\n    const {\n        width,\n        height,\n    } = state;\n    const {\n        raws,\n        styles,\n    } = getRadiusStyles(\n        nextPoses,\n        controlPoses,\n        moveable.props.roundRelative!,\n        width,\n        height,\n    );\n    const {\n        horizontals,\n        verticals,\n    } = splitRadiusPoses(controlPoses, raws);\n    const borderRadius = styles.join(\" \");\n\n    state.borderRadiusState = borderRadius;\n    triggerEvent<RoundableProps>(moveable, \"onRound\", fillParams<OnRound>(moveable, e, {\n        horizontals,\n        verticals,\n        borderRadius,\n        width,\n        height,\n        delta,\n        dist,\n    }));\n}\n\n/**\n * @namespace Moveable.Roundable\n * @description Whether to show and drag or double click border-radius\n */\n\nexport default {\n    name: \"roundable\",\n    props: {\n        roundable: Boolean,\n        roundRelative: Boolean,\n    } as const,\n    events: {\n        onRoundStart: \"roundStart\",\n        onRound: \"round\",\n        onRoundEnd: \"roundEnd\",\n    } as const,\n    css: [\n        `.control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}`,\n        `:host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}`,\n    ],\n    render(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, React: Renderer): any {\n        const {\n            target,\n            width,\n            height,\n            matrix,\n            is3d,\n            left,\n            top,\n            borderRadiusState,\n        } = moveable.state;\n\n        if (!target) {\n            return null;\n        }\n\n        const n = is3d ? 4 : 3;\n        const radiusValues = getBorderRadius(target, width, height, borderRadiusState);\n\n        if (!radiusValues) {\n            return null;\n        }\n        return radiusValues.map((v, i) => {\n            const pos = minus(caculatePosition(matrix, v.pos, n), [left, top]);\n\n            return <div key={`borderRadiusControl${i}`}\n                className={prefix(\"control\", \"border-radius\")}\n                data-radius-index={i}\n                style={{\n                    transform: `translate(${pos[0]}px, ${pos[1]}px)`,\n                }}></div>;\n        });\n    },\n    dragControlCondition(e: any) {\n        if (!e.inputEvent || e.isRequest) {\n            return false;\n        }\n        const className = (e.inputEvent.target.className || \"\");\n\n        return className.indexOf(\"border-radius\") > -1\n            || (className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1);\n    },\n    dragControlStart(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { inputEvent, datas, } = e;\n        const inputTarget = inputEvent.target;\n        const className = (inputTarget.className || \"\");\n        const isControl = className.indexOf(\"border-radius\") > -1;\n        const isLine = className.indexOf(\"moveable-line\") > -1 && className.indexOf(\"moveable-direction\") > -1;\n        const controlIndex = isControl ? parseInt(inputTarget.getAttribute(\"data-radius-index\"), 10) : -1;\n        const lineIndex = isLine ? parseInt(inputTarget.getAttribute(\"data-line-index\"), 10) : -1;\n\n        if (!isControl && !isLine) {\n            return false;\n        }\n\n        const result = triggerEvent<RoundableProps>(\n            moveable, \"onRoundStart\", fillParams<OnRoundStart>(moveable, e, {}));\n\n        if (result === false) {\n            return false;\n        }\n\n        datas.lineIndex = lineIndex;\n        datas.controlIndex = controlIndex;\n        datas.isControl = isControl;\n        datas.isLine = isLine;\n\n        setDragStart(moveable, e);\n\n        const {\n            roundRelative,\n        } = moveable.props;\n        const state = moveable.state;\n        const {\n            target,\n            width,\n            height,\n        } = state;\n\n        datas.isRound = true;\n        datas.prevDist = [0, 0];\n        const controlPoses = getBorderRadius(target!, width, height) || [];\n\n        datas.controlPoses = controlPoses;\n\n        state.borderRadiusState = getRadiusStyles(\n            controlPoses.map(pos => pos.pos), controlPoses, roundRelative!, width, height).styles.join(\" \");\n        return true;\n    },\n    dragControl(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const { datas } = e;\n\n        if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {\n            return false;\n        }\n        const index = datas.controlIndex as number;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const nextPoses = controlPoses.map(pos => pos.pos.slice());\n        const [distX, distY] = getDragDist(e);\n        const dist = [distX, distY];\n        const delta = minus(dist, datas.prevDist);\n\n        moveControlPos(controlPoses, nextPoses, index, distX, distY);\n\n        datas.prevDist = [distX, distY];\n\n        triggerRoundEvent(\n            moveable,\n            e,\n            dist,\n            delta,\n            controlPoses,\n            nextPoses,\n        );\n        return true;\n    },\n    dragControlEnd(moveable: MoveableManagerInterface<RoundableProps, RoundableState>, e: any) {\n        const state = moveable.state;\n\n        state.borderRadiusState = \"\";\n        const { datas, isDouble } = e;\n        if (!datas.isRound) {\n            return false;\n        }\n        const {\n            width,\n            height,\n        } = state;\n        const {\n            isControl,\n            controlIndex,\n            isLine,\n            lineIndex,\n        } = datas;\n        const controlPoses = datas.controlPoses as ControlPose[];\n        const poses = controlPoses.map(pos => pos.pos);\n        const length = poses.length;\n\n        if (isDouble) {\n            if (isControl) {\n                removeRadiusPos(controlPoses, poses, controlIndex, 0);\n            } else if (isLine) {\n                const [distX, distY] = caculatePointerDist(moveable, e);\n\n                addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);\n            }\n            if (length !== controlPoses.length) {\n                triggerRoundEvent(\n                    moveable,\n                    e,\n                    [0, 0],\n                    [0, 0],\n                    controlPoses,\n                    poses,\n                );\n            }\n            triggerEvent<RoundableProps>(moveable, \"onRoundEnd\",\n                fillEndParams<OnRoundEnd>(moveable, e, {}));\n        }\n        state.borderRadiusState = \"\";\n        return true;\n    },\n    unset(moveable: MoveableManagerInterface<RoundableProps, RoundableState>) {\n        moveable.state.borderRadiusState = \"\";\n    },\n};\n/**\n * Whether to show and drag or double click border-radius, (default: false)\n * @name Moveable.Roundable#roundable\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * % Can be used instead of the absolute px\n * @name Moveable.Roundable#roundRelative\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n\n/**\n * When drag start the clip area or controls, the `roundStart` event is called.\n * @memberof Moveable.Roundable\n * @event roundStart\n * @param {Moveable.Roundable.OnRoundStart} - Parameters for the `roundStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag or double click the border area or controls, the `round` event is called.\n * @memberof Moveable.Roundable\n * @event round\n * @param {Moveable.Roundable.OnRound} - Parameters for the `round` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n/**\n * When drag end the border area or controls, the `roundEnd` event is called.\n * @memberof Moveable.Roundable\n * @event roundEnd\n * @param {Moveable.Roundable.onRoundEnd} - Parameters for the `roundEnd` event\n * @example\n  * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     roundable: true,\n *     roundRelative: false,\n * });\n * moveable.on(\"roundStart\", e => {\n *     console.log(e);\n * }).on(\"round\", e => {\n *     e.target.style.borderRadius = e.borderRadius;\n * }).on(\"roundEnd\", e => {\n *     console.log(e);\n * });\n */\n","import { refs } from \"framework-utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer, MoveableGroupInterface } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        defaultGroupOrigin: String,\n        groupable: Boolean,\n    } as const,\n    events: {} as const,\n    render(moveable: MoveableGroupInterface, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\nimport Padding from \"./Padding\";\nimport Clippable from \"./Clippable\";\nimport OriginDraggable from \"./OriginDraggable\";\nimport Roundable from \"./Roundable\";\nimport { Able, UnionToIntersection } from \"../types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { invert } from \"./utils\";\nimport Groupable from \"./Groupable\";\n\nexport const MOVEABLE_ABLES = [\n    Default, Snappable, Pinchable, Draggable, Rotatable,\n    Resizable, Scalable, Warpable, Scrollable, DragArea, Padding, Origin, OriginDraggable,\n    Clippable, Roundable, Groupable,\n] as const;\n\nexport const MOVEABLE_EVENTS_PROPS_MAP = MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.events};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"events\"]>;\nexport const MOVEABLE_PROPS_MAP = MOVEABLE_ABLES.reduce((current, able) => {\n    return {...current, ...able.props};\n}, {}) as UnionToIntersection<typeof MOVEABLE_ABLES[number][\"props\"]>;\n\nexport const MOVEABLE_EVENTS_MAP = invert(MOVEABLE_EVENTS_PROPS_MAP);\nexport const MOVEABLE_EVENTS: string[] = Object.keys(MOVEABLE_EVENTS_MAP);\nexport const MOVEABLE_PROPS: string[] = Object.keys(MOVEABLE_PROPS_MAP);\n\nconst cssMap: IObject<boolean> = {};\n\nMOVEABLE_ABLES.forEach(({ css }: Able) => {\n    if (!css) {\n        return;\n    }\n    css.forEach(text => {\n        cssMap[text] = true;\n    });\n});\n\nexport const ABLE_CSS = Object.keys(cssMap).join(\"\\n\");\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    resetClientRect,\n    throttle,\n    flat,\n    groupByMap,\n    caculatePadding,\n} from \"./utils\";\nimport styled from \"react-css-styled\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref, prefixCSS } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo, Requester, PaddingBox, HitRect } from \"./types\";\nimport { triggerAble, getTargetAbleDragger, getAbleDragger } from \"./getAbleDragger\";\nimport { getRad, plus } from \"./matrix\";\nimport { IObject } from \"@daybrush/utils\";\nimport { ABLE_CSS } from \"./ables/consts\";\n\nconst ControlBoxElement = styled(\"div\", prefixCSS(PREFIX, MOVEABLE_CSS + ABLE_CSS));\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-rotation={rotation}\n        data-line-index={index}\n        data-direction={direction} style={getLineStyle(pos1, pos2, rad)}></div>;\n}\nexport default class MoveableManager<T = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        dragTarget: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n        triggerAblesSimultaneously: false,\n        padding: {},\n        pinchOutside: true,\n        checkInput: false,\n        groupable: false,\n        cspNonce: \"\",\n    };\n    public state: MoveableManagerState = {\n        container: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        offsetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],\n        targetClientRect: resetClientRect(),\n        containerClientRect: resetClientRect(),\n        moveableClientRect: resetClientRect(),\n        rotation: 0,\n    } as any;\n    public targetAbles: Able[] = [];\n    public controlAbles: Able[] = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public rotation: number = 0;\n    public scale: number[] = [1, 1];\n    public isUnmounted = false;\n\n    public render() {\n        const props = this.props;\n        const state = this.state;\n        const { edge, parentPosition, className, target: propsTarget, zoom, cspNonce } = props;\n\n        this.checkUpdate();\n        this.updateRenderPoses();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, target: stateTarget, direction, renderPoses } = state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n        const isDragging = this.isDragging();\n        const ableAttributes: IObject<boolean> = {};\n\n        this.getEnabledAbles().forEach(able => {\n            ableAttributes[`data-able-${able.name.toLowerCase()}`] = true;\n        });\n        return (\n            <ControlBoxElement\n                cspNonce={cspNonce}\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1\n                    ? \"reverse\" : \"\", isDragging ? \"dragging\" : \"\")} ${className}`}\n                {...ableAttributes}\n                style={{\n                    \"position\": \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", renderPoses[0], renderPoses[1], 0)}\n                {renderLine(edge ? \"e\" : \"\", renderPoses[1], renderPoses[3], 1)}\n                {renderLine(edge ? \"w\" : \"\", renderPoses[0], renderPoses[2], 2)}\n                {renderLine(edge ? \"s\" : \"\", renderPoses[2], renderPoses[3], 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n        this.updateCheckInput();\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps) {\n        this.updateEvent(prevProps);\n        this.updateCheckInput();\n    }\n    public componentWillUnmount() {\n        this.isUnmounted = true;\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.triggerDragStart(e);\n        }\n        return this;\n    }\n    /**\n     * Hit test an element or rect on a moveable target.\n     * @method Moveable#hitTest\n     * @param - element or rect to test\n     * @return - Get hit test rate (rate > 0 is hitted)\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.hitTest(e.target) > 0) {\n     *          console.log(\"hiited\");\n     *     }\n     * });\n     */\n    public hitTest(el: Element | HitRect): number {\n        let rect: Required<HitRect>;\n\n        if (el instanceof Element) {\n            const clientRect = el.getBoundingClientRect();\n\n            rect = {\n                left: clientRect.left,\n                top: clientRect.top,\n                width: clientRect.width,\n                height: clientRect.height,\n            };\n        } else {\n            rect = { width: 0, height: 0, ...el };\n        }\n        const {\n            left: rectLeft,\n            top: rectTop,\n            width: rectWidth,\n            height: rectHeight,\n        } = this.state.targetClientRect;\n        const {\n            left,\n            top,\n            width,\n            height,\n        } = rect;\n        const right = left + width;\n        const bottom = top + height;\n        const rectRight = rectLeft + rectWidth;\n        const rectBottom = rectTop + rectHeight;\n        const testLeft = Math.max(rectLeft, left);\n        const testRight = Math.min(rectRight, right);\n        const testTop = Math.max(rectTop, top);\n        const testBottom = Math.min(rectBottom, bottom);\n\n        if (testRight < testLeft || testBottom < testTop) {\n            return 0;\n        }\n\n        const rectSize = (Math.min(rectRight, right) - Math.max(left, rectLeft))\n            * (Math.min(rectBottom, bottom) - Math.max(rectTop, top));\n\n        return Math.min(100, (testRight - testLeft) * (testBottom - testTop) / rectSize * 100);\n    }\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = targetClientRect;\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos3, pos4);\n    }\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getTargetInfo(this.controlBox && this.controlBox.getElement(),\n                target, container, container,\n                rootContainer || container, isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const props = this.props;\n        const target = props.dragTarget || props.target;\n        const prevTarget = prevProps.dragTarget || prevProps.target;\n        const dragArea = props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            this.targetDragger = getTargetAbleDragger<any>(this, target!, \"\");\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger<any>(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    /**\n     * Check if the moveable state is being dragged.\n     * @method Moveable#isDragging\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // false\n     * console.log(moveable.isDragging());\n     *\n     * moveable.on(\"drag\", () => {\n     *   // true\n     *   console.log(moveable.isDragging());\n     * });\n     */\n    public isDragging() {\n        return (this.targetDragger ? this.targetDragger.isFlag() : false)\n            || (this.controlDragger ? this.controlDragger.isFlag() : false);\n    }\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        const transformOrigin = state.transformOrigin;\n\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n            transformOrigin,\n            rotation: this.getRotation(),\n        };\n    }\n    public getRotation() {\n        const {\n            pos1,\n            pos2,\n            direction,\n        } = this.state;\n\n        let deg = getRad(pos1, pos2) / Math.PI * 180;\n\n        deg = direction >= 0 ? deg : 180 - deg;\n        deg = deg >= 0 ? deg : 360 + deg;\n\n        return deg;\n    }\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.OriginDraggable.html#request|OriginDraggable Requester}\n     * @param - ableName\n     * @param - request to be able params.\n     * @param - If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10 }, true);\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const requestInstant = isInstant || param.isInstant;\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    requestAble: ableName,\n                    isRequest: true,\n                }, requestInstant);\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            requestAble: ableName,\n            isRequest: true,\n        }, requestInstant);\n\n        return requestInstant ? requester.request(param).requestEnd() : requester;\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.componentWillUnmount();\n    }\n    public updateRenderPoses() {\n        const state = this.state;\n        const props = this.props;\n        const {\n            beforeOrigin, transformOrigin,\n            matrix, is3d, pos1, pos2, pos3, pos4, left: stateLeft, top: stateTop } = state;\n        const {\n            left = 0,\n            top = 0,\n            bottom = 0,\n            right = 0,\n        } = (props.padding || {}) as PaddingBox;\n        const n = is3d ? 4 : 3;\n        const absoluteOrigin = (props as any).groupable ? beforeOrigin : plus(beforeOrigin, [stateLeft, stateTop]);\n\n        state.renderPoses = [\n            plus(pos1, caculatePadding(matrix, [-left, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos2, caculatePadding(matrix, [right, -top], transformOrigin, absoluteOrigin, n)),\n            plus(pos3, caculatePadding(matrix, [-left, bottom], transformOrigin, absoluteOrigin, n)),\n            plus(pos4, caculatePadding(matrix, [right, bottom], transformOrigin, absoluteOrigin, n)),\n        ];\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart], triggerAblesSimultaneously);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected getEnabledAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        return ables.filter(able => able && props[able.name]);\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const triggerAblesSimultaneously = props.triggerAblesSimultaneously;\n        const Renderer = { createElement: React.createElement };\n\n        return groupByMap(flat<any>(\n            filterAbles(this.getEnabledAbles(), [\"render\"], triggerAblesSimultaneously).map(({ render }) => {\n                return render!(this, Renderer) || [];\n            })).filter(el => el), ({ key }) => key).map(group => group[0]);\n    }\n    protected updateCheckInput() {\n        this.targetDragger && (this.targetDragger.options.checkInput = this.props.checkInput);\n    }\n}\n\n/**\n * The target to indicate Moveable Control Box.\n * @name Moveable#target\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n */\n/**\n * Zooms in the elements of a moveable. (default: 1)\n * @name Moveable#zoom\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.zoom = 2;\n */\n\n/**\n * Resize, Scale Events at edges\n * @name Moveable#edge\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.edge = true;\n */\n\n/**\n * You can specify the className of the moveable controlbox. (default: \"\")\n * @name Moveable#className\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   className: \"\",\n * });\n *\n * moveable.className = \"moveable1\";\n */\n\n/**\n * The target(s) to drag Moveable target(s) (default: target)\n * @name Moveable#dragTarget\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body);\n * moveable.target = document.querySelector(\".target\");\n * moveable.dragTarget = document.querySelector(\".dragTarget\");\n */\n\n/**\n * `renderStart` event occurs at the first start of all events.\n * @memberof Moveable\n * @event renderStart\n * @param {Moveable.OnRenderStart} - Parameters for the `renderStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderStart\", ({ target }) => {\n *     console.log(\"onRenderStart\", target);\n * });\n */\n\n/**\n * `render` event occurs before the target is drawn on the screen.\n * @memberof Moveable\n * @event render\n * @param {Moveable.OnRender} - Parameters for the `render` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"render\", ({ target }) => {\n *     console.log(\"onRender\", target);\n * });\n */\n\n/**\n * `renderEnd` event occurs at the end of all events.\n * @memberof Moveable\n * @event renderEnd\n * @param {Moveable.OnRenderEnd} - Parameters for the `renderEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: document.querySelector(\".target\"),\n * });\n * moveable.on(\"renderEnd\", ({ target }) => {\n *     console.log(\"onRenderEnd\", target);\n * });\n */\n\n/**\n * `renderGroupStart` event occurs at the first start of all events in group.\n * @memberof Moveable\n * @event renderGroupStart\n * @param {Moveable.OnRenderGroupStart} - Parameters for the `renderGroupStart` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupStart\", ({ targets }) => {\n *     console.log(\"onRenderGroupStart\", targets);\n * });\n */\n\n/**\n * `renderGroup` event occurs before the target is drawn on the screen in group.\n * @memberof Moveable\n * @event renderGroup\n * @param {Moveable.OnRenderGroup} - Parameters for the `renderGroup` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroup\", ({ targets }) => {\n *     console.log(\"onRenderGroup\", targets);\n * });\n */\n\n/**\n * `renderGroupEnd` event occurs at the end of all events in group.\n * @memberof Moveable\n * @event renderGroupEnd\n * @param {Moveable.OnRenderGroupEnd} - Parameters for the `renderGroupEnd` event\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *     target: [].slice.call(document.querySelectorAll(\".target\")),\n * });\n * moveable.on(\"renderGroupEnd\", ({ targets }) => {\n *     console.log(\"onRenderGroupEnd\", targets);\n * });\n */\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger, getTargetAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"./matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                //  = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n/**\n * @namespace Moveable.Group\n * @description You can make targets moveable.\n */\nclass MoveableGroup extends MoveableManager<GroupableProps> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n        defaultGroupOrigin: \"50% 50%\",\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public transformOrigin = \"50% 50%\";\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getTargetAbleDragger(this, state.target, \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n            this.transformOrigin = props.defaultGroupOrigin || \"50% 50%\";\n            this.scale = [1, 1];\n\n        }\n        const rotation = this.rotation;\n        const scale = this.scale;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px; transform-origin: ${this.transformOrigin}; width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`\n            + ` scale(${scale[0] >= 0 ? 1 : -1}, ${scale[1] >= 0 ? 1 : -1})`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getTargetInfo(\n            this.controlBox.getElement(),\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            state,\n        );\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.targetClientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        const direction = scale[0] * scale[1] > 0 ? 1 : -1;\n        this.updateState(\n            {\n                ...info,\n                direction,\n                beforeDirection: direction,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\n/**\n * Sets the initial rotation of the group. (default 0)\n * @name Moveable.Group#defaultGroupRotate\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupRotate: 0,\n * });\n *\n * moveable.defaultGroupRotate = 40;\n */\n\n/**\n * Sets the initial origin of the group. (default 0)\n * @name Moveable.Group#defaultGroupOrigin\n * @example\n * import Moveable from \"moveable\";\n *\n * const moveable = new Moveable(document.body, {\n *   target: [].slice.call(document.querySelectorAll(\".target\")),\n *   defaultGroupOrigin: \"50% 50%\",\n * });\n *\n * moveable.defaultGroupOrigin = \"20% 40%\";\n */\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, GroupableProps } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref, withMethods } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\nimport { MOVEABLE_METHODS } from \"./consts\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & GroupableProps & T> {\n    @withMethods(MOVEABLE_METHODS)\n    public moveable!: MoveableManager | MoveableGroup;\n\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            } as any;\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager<any> key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n}\nexport default interface Moveable<T = {}>\n    extends React.PureComponent<MoveableProps & GroupableProps & T>, MoveableInterface {\n    setState(state: any, callback?: () => any): any;\n}\n"]},"metadata":{},"sourceType":"module"}