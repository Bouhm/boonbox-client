{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: @daybrush/drag\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/drag.git\nversion: 0.19.1\n*/\nimport { removeEvent, addEvent, now } from '@daybrush/utils';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction getRad(pos1, pos2) {\n  var distX = pos2[0] - pos1[0];\n  var distY = pos2[1] - pos1[1];\n  var rad = Math.atan2(distY, distX);\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nfunction getRotatiion(touches) {\n  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;\n}\n\nfunction getPinchDragPosition(clients, prevClients, startClients, startPinchClients) {\n  var nowCenter = getAverageClient(clients);\n  var prevCenter = getAverageClient(prevClients);\n  var startCenter = getAverageClient(startPinchClients);\n  var pinchClient = plueClient(startPinchClients[0], minusClient(nowCenter, startCenter));\n  var pinchPrevClient = plueClient(startPinchClients[0], minusClient(prevCenter, startCenter));\n  return getPosition(pinchClient, pinchPrevClient, startClients[0]);\n}\n\nfunction isMultiTouch(e) {\n  return e.touches && e.touches.length >= 2;\n}\n\nfunction getPositionEvent(e) {\n  if (e.touches) {\n    return getClients(e.touches);\n  } else {\n    return [getClient(e)];\n  }\n}\n\nfunction getPosition(client, prevClient, startClient) {\n  var clientX = client.clientX,\n      clientY = client.clientY;\n  var prevX = prevClient.clientX,\n      prevY = prevClient.clientY;\n  var startX = startClient.clientX,\n      startY = startClient.clientY;\n  var deltaX = clientX - prevX;\n  var deltaY = clientY - prevY;\n  var distX = clientX - startX;\n  var distY = clientY - startY;\n  return {\n    clientX: clientX,\n    clientY: clientY,\n    deltaX: deltaX,\n    deltaY: deltaY,\n    distX: distX,\n    distY: distY\n  };\n}\n\nfunction getDist(clients) {\n  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));\n}\n\nfunction getPositions(clients, prevClients, startClients) {\n  return clients.map(function (client, i) {\n    return getPosition(client, prevClients[i], startClients[i]);\n  });\n}\n\nfunction getClients(touches) {\n  var length = Math.min(touches.length, 2);\n  var clients = [];\n\n  for (var i = 0; i < length; ++i) {\n    clients.push(getClient(touches[i]));\n  }\n\n  return clients;\n}\n\nfunction getClient(e) {\n  return {\n    clientX: e.clientX,\n    clientY: e.clientY\n  };\n}\n\nfunction getAverageClient(clients) {\n  if (clients.length === 1) {\n    return clients[0];\n  }\n\n  return {\n    clientX: (clients[0].clientX + clients[1].clientX) / 2,\n    clientY: (clients[0].clientY + clients[1].clientY) / 2\n  };\n}\n\nfunction plueClient(client1, client2) {\n  return {\n    clientX: client1.clientX + client2.clientX,\n    clientY: client1.clientY + client2.clientY\n  };\n}\n\nfunction minusClient(client1, client2) {\n  return {\n    clientX: client1.clientX - client2.clientX,\n    clientY: client1.clientY - client2.clientY\n  };\n}\n\nvar INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag events in any browser.\n */\n\nvar Dragger = /*#__PURE__*/function () {\n  /**\n   *\n   */\n  function Dragger(targets, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.options = {};\n    this.flag = false;\n    this.pinchFlag = false;\n    this.datas = {};\n    this.isDrag = false;\n    this.isPinch = false;\n    this.isMouse = false;\n    this.isTouch = false;\n    this.prevClients = [];\n    this.startClients = [];\n    this.movement = 0;\n    this.startPinchClients = [];\n    this.startDistance = 0;\n    this.customDist = [0, 0];\n    this.targets = [];\n    this.prevTime = 0;\n    this.isDouble = false;\n    this.startRotate = 0;\n    /**\n     * @method\n     */\n\n    this.onDragStart = function (e, isTrusted) {\n      if (isTrusted === void 0) {\n        isTrusted = true;\n      }\n\n      if (!_this.flag && e.cancelable === false) {\n        return;\n      }\n\n      var _a = _this.options,\n          container = _a.container,\n          pinchOutside = _a.pinchOutside,\n          dragstart = _a.dragstart,\n          preventRightClick = _a.preventRightClick,\n          preventDefault = _a.preventDefault,\n          checkInput = _a.checkInput;\n      var isTouch = _this.isTouch;\n\n      if (!_this.flag) {\n        var activeElement = document.activeElement;\n        var target = e.target;\n        var tagName = target.tagName.toLowerCase();\n        var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n        var hasContentEditable = target.isContentEditable;\n\n        if (hasInput || hasContentEditable) {\n          if (checkInput || activeElement === target) {\n            // force false or already focused.\n            return false;\n          }\n\n          if (activeElement && hasContentEditable && activeElement.isContentEditable && activeElement.contains(target)) {\n            return false;\n          }\n        } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n          var activeTagName = activeElement.tagName;\n\n          if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n            activeElement.blur();\n          }\n        }\n      }\n\n      var timer = 0;\n\n      if (!_this.flag && isTouch && pinchOutside) {\n        timer = setTimeout(function () {\n          addEvent(container, \"touchstart\", _this.onDragStart, {\n            passive: false\n          });\n        });\n      }\n\n      if (_this.flag && isTouch && pinchOutside) {\n        removeEvent(container, \"touchstart\", _this.onDragStart);\n      }\n\n      if (isMultiTouch(e)) {\n        clearTimeout(timer);\n\n        if (!_this.flag && e.touches.length !== e.changedTouches.length) {\n          return;\n        }\n\n        if (!_this.pinchFlag) {\n          _this.onPinchStart(e);\n        }\n      }\n\n      if (_this.flag) {\n        return;\n      }\n\n      var clients = _this.startClients[0] ? _this.startClients : getPositionEvent(e);\n      _this.customDist = [0, 0];\n      _this.flag = true;\n      _this.isDrag = false;\n      _this.startClients = clients;\n      _this.prevClients = clients;\n      _this.datas = {};\n      _this.movement = 0;\n      var position = getPosition(clients[0], _this.prevClients[0], _this.startClients[0]);\n\n      if (preventRightClick && (e.which === 3 || e.button === 2)) {\n        clearTimeout(timer);\n\n        _this.initDrag();\n\n        return false;\n      }\n\n      var result = dragstart && dragstart(__assign({\n        type: \"dragstart\",\n        datas: _this.datas,\n        inputEvent: e,\n        isTrusted: isTrusted\n      }, position));\n\n      if (result === false) {\n        clearTimeout(timer);\n\n        _this.initDrag();\n      }\n\n      _this.isDouble = now() - _this.prevTime < 200;\n      _this.flag && preventDefault && e.preventDefault();\n    };\n\n    this.onDrag = function (e, isScroll) {\n      if (!_this.flag) {\n        return;\n      }\n\n      var clients = getPositionEvent(e);\n\n      if (_this.pinchFlag) {\n        _this.onPinch(e, clients);\n      }\n\n      var result = _this.move([0, 0], e, clients);\n\n      if (!result || !result.deltaX && !result.deltaY) {\n        return;\n      }\n\n      var drag = _this.options.drag;\n      drag && drag(__assign({}, result, {\n        isScroll: !!isScroll,\n        inputEvent: e\n      }));\n    };\n\n    this.onDragEnd = function (e) {\n      if (!_this.flag) {\n        return;\n      }\n\n      var _a = _this.options,\n          dragend = _a.dragend,\n          pinchOutside = _a.pinchOutside,\n          container = _a.container;\n\n      if (_this.isTouch && pinchOutside) {\n        removeEvent(container, \"touchstart\", _this.onDragStart);\n      }\n\n      if (_this.pinchFlag) {\n        _this.onPinchEnd(e);\n      }\n\n      _this.flag = false;\n      var prevClients = _this.prevClients;\n      var startClients = _this.startClients;\n      var position = _this.pinchFlag ? getPinchDragPosition(prevClients, prevClients, startClients, _this.startPinchClients) : getPosition(prevClients[0], prevClients[0], startClients[0]);\n      var currentTime = now();\n      var isDouble = !_this.isDrag && _this.isDouble;\n      _this.prevTime = _this.isDrag || isDouble ? 0 : currentTime;\n      _this.startClients = [];\n      _this.prevClients = [];\n      dragend && dragend(__assign({\n        type: \"dragend\",\n        datas: _this.datas,\n        isDouble: isDouble,\n        isDrag: _this.isDrag,\n        inputEvent: e\n      }, position));\n    };\n\n    var elements = [].concat(targets);\n    this.options = __assign({\n      checkInput: false,\n      container: elements.length > 1 ? window : elements[0],\n      preventRightClick: true,\n      preventDefault: true,\n      pinchThreshold: 0,\n      events: [\"touch\", \"mouse\"]\n    }, options);\n    var _a = this.options,\n        container = _a.container,\n        events = _a.events;\n    this.isTouch = events.indexOf(\"touch\") > -1;\n    this.isMouse = events.indexOf(\"mouse\") > -1;\n    this.customDist = [0, 0];\n    this.targets = elements;\n\n    if (this.isMouse) {\n      elements.forEach(function (el) {\n        addEvent(el, \"mousedown\", _this.onDragStart);\n      });\n      addEvent(container, \"mousemove\", this.onDrag);\n      addEvent(container, \"mouseup\", this.onDragEnd);\n      addEvent(container, \"contextmenu\", this.onDragEnd);\n    }\n\n    if (this.isTouch) {\n      var passive_1 = {\n        passive: false\n      };\n      elements.forEach(function (el) {\n        addEvent(el, \"touchstart\", _this.onDragStart, passive_1);\n      });\n      addEvent(container, \"touchmove\", this.onDrag, passive_1);\n      addEvent(container, \"touchend\", this.onDragEnd, passive_1);\n      addEvent(container, \"touchcancel\", this.onDragEnd, passive_1);\n    }\n  }\n  /**\n   *\n   */\n\n\n  var __proto = Dragger.prototype;\n\n  __proto.isDragging = function () {\n    return this.isDrag;\n  };\n  /**\n   *\n   */\n\n\n  __proto.isFlag = function () {\n    return this.flag;\n  };\n  /**\n   *\n   */\n\n\n  __proto.isPinchFlag = function () {\n    return this.pinchFlag;\n  };\n  /**\n   *\n   */\n\n\n  __proto.isPinching = function () {\n    return this.isPinch;\n  };\n  /**\n   *\n   */\n\n\n  __proto.scrollBy = function (deltaX, deltaY, e, isCallDrag) {\n    if (isCallDrag === void 0) {\n      isCallDrag = true;\n    }\n\n    if (!this.flag) {\n      return;\n    }\n\n    this.startClients.forEach(function (client) {\n      client.clientX -= deltaX;\n      client.clientY -= deltaY;\n    });\n    this.prevClients.forEach(function (client) {\n      client.clientX -= deltaX;\n      client.clientY -= deltaY;\n    });\n    isCallDrag && this.onDrag(e, true);\n  };\n\n  __proto.move = function (_a, inputEvent, clients) {\n    var deltaX = _a[0],\n        deltaY = _a[1];\n\n    if (clients === void 0) {\n      clients = this.prevClients;\n    }\n\n    var customDist = this.customDist;\n    var prevClients = this.prevClients;\n    var startClients = this.startClients;\n    var position = this.pinchFlag ? getPinchDragPosition(clients, prevClients, startClients, this.startPinchClients) : getPosition(clients[0], prevClients[0], startClients[0]);\n    customDist[0] += deltaX;\n    customDist[1] += deltaY;\n    position.deltaX += deltaX;\n    position.deltaY += deltaY;\n    var positionDeltaX = position.deltaX,\n        positionDeltaY = position.deltaY;\n    position.distX += customDist[0];\n    position.distY += customDist[1];\n    this.movement += Math.sqrt(positionDeltaX * positionDeltaX + positionDeltaY * positionDeltaY);\n    this.prevClients = clients;\n    this.isDrag = true;\n    return __assign({\n      type: \"drag\",\n      datas: this.datas\n    }, position, {\n      movement: this.movement,\n      isDrag: this.isDrag,\n      isPinch: this.isPinch,\n      isScroll: false,\n      inputEvent: inputEvent\n    });\n  };\n\n  __proto.onPinchStart = function (e) {\n    var _a, _b;\n\n    var _c = this.options,\n        pinchstart = _c.pinchstart,\n        pinchThreshold = _c.pinchThreshold;\n\n    if (this.isDrag && this.movement > pinchThreshold) {\n      return;\n    }\n\n    var pinchClients = getClients(e.changedTouches);\n    this.pinchFlag = true;\n\n    (_a = this.startClients).push.apply(_a, pinchClients);\n\n    (_b = this.prevClients).push.apply(_b, pinchClients);\n\n    this.startDistance = getDist(this.prevClients);\n    this.startPinchClients = this.prevClients.slice();\n\n    if (!pinchstart) {\n      return;\n    }\n\n    var startClients = this.prevClients;\n    var startAverageClient = getAverageClient(startClients);\n    var centerPosition = getPosition(startAverageClient, startAverageClient, startAverageClient);\n    this.startRotate = getRotatiion(startClients);\n    pinchstart(__assign({\n      type: \"pinchstart\",\n      datas: this.datas,\n      angle: this.startRotate,\n      touches: getPositions(startClients, startClients, startClients)\n    }, centerPosition, {\n      inputEvent: e\n    }));\n  };\n\n  __proto.onPinch = function (e, clients) {\n    if (!this.flag || !this.pinchFlag || clients.length < 2) {\n      return;\n    }\n\n    this.isPinch = true;\n    var pinch = this.options.pinch;\n\n    if (!pinch) {\n      return;\n    }\n\n    var prevClients = this.prevClients;\n    var startClients = this.startClients;\n    var centerPosition = getPosition(getAverageClient(clients), getAverageClient(prevClients), getAverageClient(startClients));\n    var angle = getRotatiion(clients);\n    var distance = getDist(clients);\n    pinch(__assign({\n      type: \"pinch\",\n      datas: this.datas,\n      movement: this.movement,\n      angle: angle,\n      rotation: angle - this.startRotate,\n      touches: getPositions(clients, prevClients, startClients),\n      scale: distance / this.startDistance,\n      distance: distance\n    }, centerPosition, {\n      inputEvent: e\n    }));\n  };\n\n  __proto.onPinchEnd = function (e) {\n    if (!this.flag || !this.pinchFlag) {\n      return;\n    }\n\n    var isPinch = this.isPinch;\n    this.isPinch = false;\n    this.pinchFlag = false;\n    var pinchend = this.options.pinchend;\n\n    if (!pinchend) {\n      return;\n    }\n\n    var prevClients = this.prevClients;\n    var startClients = this.startClients;\n    var centerPosition = getPosition(getAverageClient(prevClients), getAverageClient(prevClients), getAverageClient(startClients));\n    pinchend(__assign({\n      type: \"pinchend\",\n      datas: this.datas,\n      isPinch: isPinch,\n      touches: getPositions(prevClients, prevClients, startClients)\n    }, centerPosition, {\n      inputEvent: e\n    }));\n    this.isPinch = false;\n    this.pinchFlag = false;\n  };\n\n  __proto.triggerDragStart = function (e) {\n    this.onDragStart(e, false);\n  };\n  /**\n   *\n   */\n\n\n  __proto.unset = function () {\n    var _this = this;\n\n    var targets = this.targets;\n    var container = this.options.container;\n\n    if (this.isMouse) {\n      targets.forEach(function (target) {\n        removeEvent(target, \"mousedown\", _this.onDragStart);\n      });\n      removeEvent(container, \"mousemove\", this.onDrag);\n      removeEvent(container, \"mouseup\", this.onDragEnd);\n      removeEvent(container, \"contextmenu\", this.onDragEnd);\n    }\n\n    if (this.isTouch) {\n      targets.forEach(function (target) {\n        removeEvent(target, \"touchstart\", _this.onDragStart);\n      });\n      removeEvent(container, \"touchstart\", this.onDragStart);\n      removeEvent(container, \"touchmove\", this.onDrag);\n      removeEvent(container, \"touchend\", this.onDragEnd);\n      removeEvent(container, \"touchcancel\", this.onDragEnd);\n    }\n  };\n\n  __proto.initDrag = function () {\n    this.startClients = [];\n    this.prevClients = [];\n    this.flag = false;\n  };\n\n  return Dragger;\n}();\n\nfunction setDrag(el, options) {\n  return new Dragger(el, options);\n}\n\nexport default Dragger;\nexport { setDrag as drag };","map":{"version":3,"sources":["../src/utils.ts","../src/Dragger.ts","../src/drag.ts"],"names":["getRad","pos1","pos2","distX","distY","rad","Math","getRotatiion","touches","getPinchDragPosition","clients","prevClients","startClients","startPinchClients","nowCenter","getAverageClient","prevCenter","startCenter","pinchClient","plueClient","minusClient","pinchPrevClient","getPosition","isMultiTouch","e","getPositionEvent","getClients","getClient","client","prevClient","startClient","clientX","clientY","prevX","prevY","startX","startY","deltaX","deltaY","getDist","getPositions","length","i","client1","client2","INPUT_TAGNAMES","options","elements","checkInput","container","preventRightClick","preventDefault","pinchThreshold","events","_a","addEvent","_this","passive_1","passive","isCallDrag","isTrusted","pinchOutside","dragstart","isTouch","activeElement","document","target","tagName","hasInput","hasContentEditable","activeTagName","timer","setTimeout","removeEvent","clearTimeout","position","result","type","datas","inputEvent","now","drag","isScroll","customDist","positionDeltaX","positionDeltaY","movement","isDrag","isPinch","dragend","currentTime","isDouble","_c","pinchstart","pinchClients","_b","startAverageClient","centerPosition","angle","startRotate","pinch","distance","rotation","scale","startDistance","pinchend","targets","setDrag","el"],"mappings":"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","sourcesContent":["import { Client, Position } from \"./types\";\nimport { IArrayFormat } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function getPinchDragPosition(\n    clients: Client[],\n    prevClients: Client[],\n    startClients: Client[],\n    startPinchClients: Client[],\n) {\n    const nowCenter = getAverageClient(clients);\n    const prevCenter = getAverageClient(prevClients);\n    const startCenter = getAverageClient(startPinchClients);\n    const pinchClient = plueClient(startPinchClients[0], minusClient(nowCenter, startCenter));\n    const pinchPrevClient = plueClient(startPinchClients[0], minusClient(prevCenter, startCenter));\n\n    return getPosition(pinchClient, pinchPrevClient, startClients[0]);\n}\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getPositionEvent(e: any): Client[] {\n    if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function getPosition(client: Client, prevClient: Client, startClient: Client): Position {\n    const { clientX, clientY } = client;\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = prevClient;\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = startClient;\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX,\n        clientY,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getPositions(clients: Client[], prevClients: Client[], startClients: Client[]): Position[] {\n    return clients.map((client, i) => getPosition(client, prevClients[i], startClients[i]));\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[]) {\n    if (clients.length === 1) {\n        return clients[0];\n    }\n    return {\n        clientX: (clients[0].clientX + clients[1].clientX) / 2,\n        clientY: (clients[0].clientY + clients[1].clientY) / 2,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n","import { DragOptions, Client, Position, OnDrag } from \"./types\";\nimport {\n    getPositionEvent, getPosition, getClients, getPositions,\n    isMultiTouch, getPinchDragPosition, getAverageClient, getDist, getRotatiion,\n} from \"./utils\";\nimport { addEvent, removeEvent, now } from \"@daybrush/utils\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag events in any browser.\n */\nclass Dragger {\n    public options: DragOptions = {};\n    private flag = false;\n    private pinchFlag = false;\n    private datas = {};\n    private isDrag = false;\n    private isPinch = false;\n    private isMouse = false;\n    private isTouch = false;\n    private prevClients: Client[] = [];\n    private startClients: Client[] = [];\n    private movement: number = 0;\n    private startPinchClients: Client[] = [];\n    private startDistance: number = 0;\n    private customDist = [0, 0];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private isDouble: boolean = false;\n    private startRotate = 0;\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: DragOptions = {}) {\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        this.options = {\n            checkInput: false,\n            container: elements.length > 1 ? window : elements[0],\n            preventRightClick: true,\n            preventDefault: true,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events } = this.options;\n\n        this.isTouch = events!.indexOf(\"touch\") > -1;\n        this.isMouse = events!.indexOf(\"mouse\") > -1;\n        this.customDist = [0, 0];\n        this.targets = elements;\n\n        if (this.isMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n            });\n            addEvent(container!, \"mousemove\", this.onDrag);\n            addEvent(container!, \"mouseup\", this.onDragEnd);\n            addEvent(container!, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n            });\n            addEvent(container!, \"touchmove\", this.onDrag, passive);\n            addEvent(container!, \"touchend\", this.onDragEnd, passive);\n            addEvent(container!, \"touchcancel\", this.onDragEnd, passive);\n        }\n    }\n    /**\n     *\n     */\n    public isDragging() {\n        return this.isDrag;\n    }\n    /**\n     *\n     */\n    public isFlag() {\n        return this.flag;\n    }\n    /**\n     *\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     *\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n    /**\n     *\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * @method\n     */\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const { container, pinchOutside, dragstart, preventRightClick, preventDefault, checkInput } = this.options;\n        const isTouch = this.isTouch;\n\n        if (!this.flag) {\n            const activeElement = document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n            const tagName = target.tagName.toLowerCase();\n            const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n            const hasContentEditable = target.isContentEditable;\n\n            if (hasInput || hasContentEditable) {\n                if (checkInput || activeElement === target) {\n                    // force false or already focused.\n                    return false;\n                }\n                if (\n                    activeElement\n                    && hasContentEditable\n                    && activeElement.isContentEditable\n                    && activeElement.contains(target)\n                ) {\n                    return false;\n                }\n            } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                const activeTagName = activeElement.tagName;\n                if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                    activeElement.blur();\n                }\n            }\n        }\n        let timer = 0;\n\n        if (!this.flag && isTouch && pinchOutside) {\n            timer = setTimeout(() => {\n                addEvent(container!, \"touchstart\", this.onDragStart, { passive: false });\n            });\n        }\n        if (this.flag && isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (!this.flag && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n        if (this.flag) {\n            return;\n        }\n        const clients = this.startClients[0] ? this.startClients : getPositionEvent(e);\n\n        this.customDist = [0, 0];\n        this.flag = true;\n        this.isDrag = false;\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.datas = {};\n        this.movement = 0;\n\n        const position = getPosition(clients[0], this.prevClients[0], this.startClients[0]);\n\n        if (preventRightClick && (e.which === 3 || e.button === 2)) {\n            clearTimeout(timer);\n            this.initDrag();\n            return false;\n        }\n        const result = dragstart && dragstart({\n            type: \"dragstart\",\n            datas: this.datas,\n            inputEvent: e,\n            isTrusted,\n            ...position,\n        });\n        if (result === false) {\n            clearTimeout(timer);\n            this.initDrag();\n        }\n        this.isDouble = now() - this.prevTime < 200;\n        this.flag && preventDefault && e.preventDefault();\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const clients = getPositionEvent(e);\n\n        if (this.pinchFlag) {\n            this.onPinch(e, clients);\n        }\n        const result = this.move([0, 0], e, clients);\n\n        if (!result || (!result.deltaX && !result.deltaY)) {\n            return;\n        }\n        const drag = this.options.drag;\n\n        drag && drag({\n            ...result,\n            isScroll: !!isScroll,\n            inputEvent: e,\n        });\n    }\n    public move([deltaX, deltaY]: number[], inputEvent: any, clients = this.prevClients): OnDrag | undefined {\n        const customDist = this.customDist;\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(clients, prevClients, startClients, this.startPinchClients)\n            : getPosition(clients[0], prevClients[0], startClients[0]);\n\n        customDist[0] += deltaX;\n        customDist[1] += deltaY;\n        position.deltaX += deltaX;\n        position.deltaY += deltaY;\n\n        const {\n            deltaX: positionDeltaX,\n            deltaY: positionDeltaY,\n        } = position;\n\n        position.distX += customDist[0];\n        position.distY += customDist[1];\n\n        this.movement += Math.sqrt(positionDeltaX * positionDeltaX + positionDeltaY * positionDeltaY);\n        this.prevClients = clients;\n        this.isDrag = true;\n\n        return {\n            type: \"drag\",\n            datas: this.datas,\n            ...position,\n            movement: this.movement,\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    public onDragEnd = (e: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const { dragend, pinchOutside, container } = this.options;\n        if (this.isTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        this.flag = false;\n\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n\n        const position: Position = this.pinchFlag\n            ? getPinchDragPosition(prevClients, prevClients, startClients, this.startPinchClients)\n            : getPosition(prevClients[0], prevClients[0], startClients[0]);\n\n        const currentTime = now();\n        const isDouble = !this.isDrag && this.isDouble;\n\n        this.prevTime = this.isDrag || isDouble ? 0 : currentTime;\n        this.startClients = [];\n        this.prevClients = [];\n\n        dragend && dragend({\n            type: \"dragend\",\n            datas: this.datas,\n            isDouble,\n            isDrag: this.isDrag,\n            inputEvent: e,\n            ...position,\n        });\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchstart, pinchThreshold } = this.options;\n\n        if (this.isDrag && this.movement > pinchThreshold!) {\n            return;\n        }\n        const pinchClients = getClients(e.changedTouches);\n\n        this.pinchFlag = true;\n        this.startClients.push(...pinchClients);\n        this.prevClients.push(...pinchClients);\n        this.startDistance = getDist(this.prevClients);\n        this.startPinchClients = [...this.prevClients];\n\n        if (!pinchstart) {\n            return;\n        }\n        const startClients = this.prevClients;\n        const startAverageClient = getAverageClient(startClients);\n        const centerPosition = getPosition(\n            startAverageClient,\n            startAverageClient,\n            startAverageClient,\n        );\n\n        this.startRotate = getRotatiion(startClients);\n        pinchstart({\n            type: \"pinchstart\",\n            datas: this.datas,\n            angle: this.startRotate,\n            touches: getPositions(startClients, startClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n        this.isPinch = true;\n\n        const pinch = this.options.pinch;\n        if (!pinch) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(clients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        const angle = getRotatiion(clients);\n        const distance = getDist(clients);\n        pinch({\n            type: \"pinch\",\n            datas: this.datas,\n            movement: this.movement,\n            angle,\n            rotation: angle - this.startRotate,\n            touches: getPositions(clients, prevClients, startClients),\n            scale: distance / this.startDistance,\n            distance,\n            ...centerPosition,\n            inputEvent: e,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.flag || !this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const pinchend = this.options.pinchend;\n\n        if (!pinchend) {\n            return;\n        }\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const centerPosition = getPosition(\n            getAverageClient(prevClients),\n            getAverageClient(prevClients),\n            getAverageClient(startClients),\n        );\n        pinchend({\n            type: \"pinchend\",\n            datas: this.datas,\n            isPinch,\n            touches: getPositions(prevClients, prevClients, startClients),\n            ...centerPosition,\n            inputEvent: e,\n        });\n        this.isPinch = false;\n        this.pinchFlag = false;\n    }\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     *\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        if (this.isMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(container, \"mouseup\", this.onDragEnd);\n            removeEvent(container, \"contextmenu\", this.onDragEnd);\n        }\n        if (this.isTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(container, \"touchend\", this.onDragEnd);\n            removeEvent(container, \"touchcancel\", this.onDragEnd);\n        }\n    }\n    private initDrag() {\n        this.startClients = [];\n        this.prevClients = [];\n        this.flag = false;\n    }\n}\n\nexport default Dragger;\n","import Dragger from \"./Dragger\";\nimport { DragOptions } from \"./types\";\n\nexport default function setDrag(el: Element, options: DragOptions) {\n    return new Dragger(el, options);\n}\n"]},"metadata":{},"sourceType":"module"}