{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: react-moveable\nlicense: MIT\nauthor: Daybrush\nrepository: https://github.com/daybrush/moveable/blob/master/packages/react-moveable\nversion: 0.18.1\n*/\nimport { createElement, PureComponent } from 'react';\nimport { prefixCSS, prefixNames, ref, refs } from 'framework-utils';\nimport getAgent from '@egjs/agent';\nimport { isUndefined, isObject, splitBracket, splitUnit, isFunction, hasClass, find, isArray, dot, addClass, findIndex, removeClass } from '@daybrush/utils';\nimport { createIdentityMatrix, plus, getRad, caculate, convertPositionMatrix, getOrigin, invert, multiplies, createOriginMatrix, convertDimension, multiply, convertMatrixtoCSS, ignoreDimension, minus, convertCSStoMatrix, createScaleMatrix, average, rotate, createRotateMatrix, createWarpMatrix, multiplyCSS } from '@moveable/matrix';\nimport styled from 'react-css-styled';\nimport Dragger from '@daybrush/drag';\nimport DragScroll from '@scena/dragscroll';\nimport ChildrenDiffer from '@egjs/children-differ';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction getSVGCursor(scale, degree) {\n  return \"data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" width=\\\"\" + 32 * scale + \"px\\\" height=\\\"\" + 32 * scale + \"px\\\" viewBox=\\\"0 0 32 32\\\" ><path d=\\\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\\\" stroke-linejoin=\\\"round\\\" stroke-width=\\\"1.2\\\" fill=\\\"black\\\" stroke=\\\"white\\\" style=\\\"transform:rotate(\" + degree + \"deg);transform-origin: 16px 16px\\\"></path></svg>\";\n}\n\nfunction getCursorCSS(degree) {\n  var x1 = getSVGCursor(1, degree);\n  var x2 = getSVGCursor(2, degree);\n  var degree45 = Math.round(degree / 45) * 45 % 180;\n  var defaultCursor = degree45 === 135 ? \"nwse-resize\" : degree45 === 45 ? \"nesw-resize\" : degree45 === 90 ? \"ew-resize\" : \"ns-resize\"; // 135\n  // tslint:disable-next-line: max-line-length\n\n  return \"cursor:\" + defaultCursor + \";cursor: url('\" + x1 + \"') 16 16, \" + defaultCursor + \";cursor: -webkit-image-set(url('\" + x1 + \"') 1x, url('\" + x2 + \"') 2x) 16 16, \" + defaultCursor + \";\";\n}\n\nvar agent = getAgent();\nvar IS_WEBKIT = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\nvar PREFIX = \"moveable-\";\nvar MOVEABLE_CSS = prefixCSS(PREFIX, \"\\n{\\n\\tposition: fixed;\\n\\twidth: 0;\\n\\theight: 0;\\n\\tleft: 0;\\n\\ttop: 0;\\n    z-index: 3000;\\n    --zoom: 1;\\n    --zoompx: 1px;\\n}\\n.control-box {\\n    z-index: 0;\\n}\\n.line, .control {\\n\\tleft: 0;\\n    top: 0;\\n    will-change: transform;\\n}\\n.control {\\n\\tposition: absolute;\\n\\twidth: 14px;\\n\\theight: 14px;\\n\\tborder-radius: 50%;\\n\\tborder: 2px solid #fff;\\n\\tbox-sizing: border-box;\\n\\tbackground: #4af;\\n\\tmargin-top: -7px;\\n    margin-left: -7px;\\n    width: calc(14 * var(--zoompx));\\n    height: calc(14 * var(--zoompx));\\n    margin-top: calc(-7 * var(--zoompx));\\n    margin-left: calc(-7 * var(--zoompx));\\n    border: calc(2 * var(--zoompx)) solid #fff;\\n    z-index: 10;\\n}\\n.line {\\n\\tposition: absolute;\\n\\twidth: 1px;\\n    height: 1px;\\n    width: var(--zoompx);\\n    height: var(--zoompx);\\n\\tbackground: #4af;\\n\\ttransform-origin: 0px 50%;\\n}\\n.line.dashed {\\n    box-sizing: border-box;\\n    background: transparent;\\n}\\n.line.dashed.horizontal {\\n    border-top: 1px dashed #4af;\\n    border-top: var(--zoompx) dashed #4af;\\n}\\n.line.dashed.vertical {\\n    border-left: 1px dashed #4af;\\n    border-left: var(--zoompx) dashed #4af;\\n}\\n.line.dashed:before {\\n    position: absolute;\\n    content: attr(data-size);\\n    color: #4af;\\n    font-size: 12px;\\n    font-weight: bold;\\n}\\n.line.dashed.horizontal:before {\\n    left: 50%;\\n    transform: translateX(-50%);\\n    bottom: 5px;\\n}\\n.line.dashed.vertical:before {\\n    top: 50%;\\n    transform: translateY(-50%);\\n    left: 5px;\\n}\\n.line.rotation-line {\\n\\theight: 40px;\\n    width: 1px;\\n    transform-origin: 50% calc(100% - 0.5px);\\n    top: -40px;\\n    width: var(--zoompx);\\n    height: calc(40 * var(--zoompx));\\n    top: calc(-40 * var(--zoompx));\\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\\n}\\n.line.rotation-line .control {\\n\\tborder-color: #4af;\\n\\tbackground:#fff;\\n    cursor: alias;\\n    left: 50%;\\n}\\n.line.vertical {\\n    transform: translateX(-50%);\\n}\\n.line.horizontal {\\n    transform: translateY(-50%);\\n}\\n.line.vertical.bold {\\n    width: 2px;\\n    width: calc(2 * var(--zoompx));\\n}\\n.line.horizontal.bold {\\n    height: 2px;\\n    height: calc(2 * var(--zoompx));\\n}\\n.control.origin {\\n\\tborder-color: #f55;\\n\\tbackground: #fff;\\n\\twidth: 12px;\\n\\theight: 12px;\\n\\tmargin-top: -6px;\\n    margin-left: -6px;\\n    width: calc(12 * var(--zoompx));\\n    height: calc(12 * var(--zoompx));\\n    margin-top: calc(-6 * var(--zoompx));\\n    margin-left: calc(-6 * var(--zoompx));\\n\\tpointer-events: none;\\n}\\n\" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function (degree) {\n  return \"\\n.direction[data-rotation=\\\"\" + degree + \"\\\"] {\\n\\t\" + getCursorCSS(degree) + \"\\n}\\n\";\n}).join(\"\\n\") + \"\\n.group {\\n    z-index: -1;\\n}\\n.area {\\n    position: absolute;\\n}\\n.area-pieces {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    display: none;\\n}\\n.area.avoid {\\n    pointer-events: none;\\n}\\n.area.avoid+.area-pieces {\\n    display: block;\\n}\\n.area-piece {\\n    position: absolute;\\n}\\n\" + (IS_WEBKIT ? \":global svg *:before {\\n\\tcontent:\\\"\\\";\\n\\ttransform-origin: inherit;\\n}\" : \"\") + \"\\n\");\nvar NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];\nvar TINY_NUM = 0.0000001;\nvar MIN_SCALE = 0.000000001;\nvar MAX_NUM = Math.pow(10, 10);\nvar MIN_NUM = -MAX_NUM;\nvar DIRECTION_INDEXES = {\n  n: [0, 1],\n  s: [2, 3],\n  w: [2, 0],\n  e: [1, 3],\n  nw: [0],\n  ne: [1],\n  sw: [2],\n  se: [3]\n};\nvar DIRECTION_ROTATIONS = {\n  n: 0,\n  s: 180,\n  w: 270,\n  e: 90,\n  nw: 315,\n  ne: 45,\n  sw: 225,\n  se: 135\n};\n\nfunction multiply2(pos1, pos2) {\n  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];\n}\n\nfunction prefix() {\n  var classNames = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    classNames[_i] = arguments[_i];\n  }\n\n  return prefixNames.apply(void 0, [PREFIX].concat(classNames));\n}\n\nfunction createIdentityMatrix3() {\n  return createIdentityMatrix(3);\n}\n\nfunction getTransformMatrix(transform) {\n  if (!transform || transform === \"none\") {\n    return [1, 0, 0, 1, 0, 0];\n  }\n\n  if (isObject(transform)) {\n    return transform;\n  }\n\n  var value = splitBracket(transform).value;\n  return value.split(/s*,\\s*/g).map(function (v) {\n    return parseFloat(v);\n  });\n}\n\nfunction getAbsoluteMatrix(matrix, n, origin) {\n  return multiplies(n, createOriginMatrix(origin, n), matrix, createOriginMatrix(origin.map(function (a) {\n    return -a;\n  }), n));\n}\n\nfunction measureSVGSize(el, unit, isHorizontal) {\n  if (unit === \"%\") {\n    var viewBox = el.ownerSVGElement.viewBox.baseVal;\n    return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n  }\n\n  return 1;\n}\n\nfunction getBeforeTransformOrigin(el) {\n  var relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n  return relativeOrigin.map(function (o, i) {\n    var _a = splitUnit(o),\n        value = _a.value,\n        unit = _a.unit;\n\n    return value * measureSVGSize(el, unit, i === 0);\n  });\n}\n\nfunction getTransformOrigin(style) {\n  var transformOrigin = style.transformOrigin;\n  return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\n\nfunction getOffsetInfo(el, lastParent, isParent) {\n  var body = document.body;\n  var target = !el || isParent ? el : el.parentElement;\n  var isEnd = false;\n  var position = \"relative\";\n\n  while (target && target !== body) {\n    if (lastParent === target) {\n      isEnd = true;\n    }\n\n    var style = getComputedStyle(target);\n    var transform = style.transform;\n    position = style.position;\n\n    if (position !== \"static\" || transform && transform !== \"none\") {\n      break;\n    }\n\n    target = target.parentElement;\n    position = \"relative\";\n  }\n\n  return {\n    isStatic: position === \"static\",\n    isEnd: isEnd || !target || target === body,\n    offsetParent: target || body\n  };\n}\n\nfunction getOffsetPosInfo(el, container, style, isFixed) {\n  var _a;\n\n  var tagName = el.tagName.toLowerCase();\n  var offsetLeft = el.offsetLeft;\n  var offsetTop = el.offsetTop;\n\n  if (isFixed) {\n    var containerClientRect = (container || document.documentElement).getBoundingClientRect();\n    offsetLeft -= containerClientRect.left;\n    offsetTop -= containerClientRect.top;\n  } // svg\n\n\n  var isSVG = isUndefined(offsetLeft);\n  var hasOffset = !isSVG;\n  var origin; // inner svg element\n\n  if (!hasOffset && tagName !== \"svg\") {\n    origin = IS_WEBKIT ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n    hasOffset = true;\n\n    if (tagName === \"g\") {\n      offsetLeft = 0;\n      offsetTop = 0;\n    } else {\n      _a = getSVGGraphicsOffset(el, origin), offsetLeft = _a[0], offsetTop = _a[1], origin[0] = _a[2], origin[1] = _a[3];\n    }\n  } else {\n    origin = getTransformOrigin(style).map(function (pos) {\n      return parseFloat(pos);\n    });\n  }\n\n  return {\n    isSVG: isSVG,\n    hasOffset: hasOffset,\n    offset: [offsetLeft, offsetTop],\n    origin: origin\n  };\n}\n\nfunction getMatrixStackInfo(target, container, prevMatrix) {\n  var el = target;\n  var matrixes = [];\n  var isEnd = false;\n  var is3d = false;\n  var n = 3;\n  var transformOrigin;\n  var targetMatrix;\n  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n  if (prevMatrix) {\n    isEnd = target === container;\n\n    if (prevMatrix.length > 10) {\n      is3d = true;\n      n = 4;\n    }\n\n    container = target.parentElement;\n  }\n\n  while (el && !isEnd) {\n    var style = getComputedStyle(el);\n    var tagName = el.tagName.toLowerCase();\n    var position = style.position;\n    var isFixed = position === \"fixed\";\n    var styleTransform = style.transform;\n    var matrix = convertCSStoMatrix(getTransformMatrix(styleTransform)); // convert 3 to 4\n\n    var length = matrix.length;\n\n    if (!is3d && length === 16) {\n      is3d = true;\n      n = 4;\n      var matrixesLength = matrixes.length;\n\n      for (var i = 0; i < matrixesLength; ++i) {\n        matrixes[i] = convertDimension(matrixes[i], 3, 4);\n      }\n    }\n\n    if (is3d && length === 9) {\n      matrix = convertDimension(matrix, 3, 4);\n    }\n\n    var _a = getOffsetPosInfo(el, container, style, isFixed),\n        hasOffset = _a.hasOffset,\n        isSVG = _a.isSVG,\n        origin = _a.origin,\n        offsetPos = _a.offset;\n\n    var offsetLeft = offsetPos[0],\n        offsetTop = offsetPos[1];\n\n    if (tagName === \"svg\" && targetMatrix) {\n      matrixes.push( // scale matrix for svg's SVGElements.\n      getSVGMatrix(el, n), createIdentityMatrix(n));\n    }\n\n    var _b = getOffsetInfo(el, container),\n        offsetParent = _b.offsetParent,\n        isOffsetEnd = _b.isEnd,\n        isStatic = _b.isStatic;\n\n    if (IS_WEBKIT && hasOffset && !isSVG && isStatic && position === \"relative\") {\n      offsetLeft -= offsetParent.offsetLeft;\n      offsetTop -= offsetParent.offsetTop;\n      isEnd = isEnd || isOffsetEnd;\n    }\n\n    var parentClientLeft = 0;\n    var parentClientTop = 0;\n\n    if (hasOffset && offsetContainer !== offsetParent) {\n      // border\n      parentClientLeft = offsetParent.clientLeft;\n      parentClientTop = offsetParent.clientTop;\n    }\n\n    matrixes.push( // absolute matrix\n    getAbsoluteMatrix(matrix, n, origin), // offset matrix (offsetPos + clientPos(border))\n    createOriginMatrix(hasOffset ? [offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop] : [el, origin], n));\n\n    if (!targetMatrix) {\n      targetMatrix = matrix;\n    }\n\n    if (!transformOrigin) {\n      transformOrigin = origin;\n    }\n\n    if (isEnd || isFixed) {\n      break;\n    } else {\n      el = offsetParent;\n      isEnd = isOffsetEnd;\n    }\n  }\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(n);\n  }\n\n  if (!transformOrigin) {\n    transformOrigin = [0, 0];\n  }\n\n  return {\n    offsetContainer: offsetContainer,\n    matrixes: matrixes,\n    targetMatrix: targetMatrix,\n    transformOrigin: transformOrigin,\n    is3d: is3d\n  };\n}\n\nfunction caculateMatrixStack(target, container, rootContainer, prevMatrix, prevRootMatrix, prevN) {\n  var _a = getMatrixStackInfo(target, container, prevMatrix),\n      matrixes = _a.matrixes,\n      is3d = _a.is3d,\n      prevTargetMatrix = _a.targetMatrix,\n      transformOrigin = _a.transformOrigin,\n      offsetContainer = _a.offsetContainer;\n\n  var _b = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix),\n      rootMatrixes = _b.matrixes,\n      isRoot3d = _b.is3d;\n\n  var n = isRoot3d || is3d ? 4 : 3;\n  var isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n  var originalContainer = container || document.body;\n  var allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN, n) : createIdentityMatrix(n);\n  var targetMatrix = prevTargetMatrix;\n  var rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN, n) : createIdentityMatrix(n);\n  var beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN, n) : createIdentityMatrix(n);\n  var offsetMatrix = createIdentityMatrix(n);\n  var length = matrixes.length;\n  var endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n  rootMatrixes.reverse();\n  matrixes.reverse();\n\n  if (!is3d && isRoot3d) {\n    targetMatrix = convertDimension(targetMatrix, 3, 4);\n    matrixes.forEach(function (matrix, i) {\n      matrixes[i] = convertDimension(matrix, 3, 4);\n    });\n  }\n\n  if (is3d && !isRoot3d) {\n    rootMatrixes.forEach(function (matrix, i) {\n      rootMatrixes[i] = convertDimension(matrix, 3, 4);\n    });\n  } // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n  // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n  // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n\n  if (!prevRootMatrix) {\n    rootMatrixes.forEach(function (matrix) {\n      rootMatrix = multiply(rootMatrix, matrix, n);\n    });\n  }\n\n  matrixes.forEach(function (matrix, i) {\n    var _a;\n\n    if (length - 2 === i) {\n      // length - 3\n      beforeMatrix = allMatrix.slice();\n    }\n\n    if (length - 1 === i) {\n      // length - 2\n      offsetMatrix = allMatrix.slice();\n    } // caculate for SVGElement\n\n\n    if (isObject(matrix[n - 1])) {\n      _a = getSVGOffset(matrix[n - 1], endContainer, n, matrix[2 * n - 1], allMatrix, matrixes[i + 1]), matrix[n - 1] = _a[0], matrix[2 * n - 1] = _a[1];\n    }\n\n    allMatrix = multiply(allMatrix, matrix, n);\n  });\n  var isMatrix3d = !isSVGGraphicElement && is3d;\n\n  if (!targetMatrix) {\n    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n  }\n\n  var transform = (isMatrix3d ? \"matrix3d\" : \"matrix\") + \"(\" + convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix) + \")\";\n  rootMatrix = ignoreDimension(rootMatrix, n, n);\n  return [rootMatrix, beforeMatrix, offsetMatrix, allMatrix, targetMatrix, transform, transformOrigin, is3d || isRoot3d];\n}\n\nfunction getSVGMatrix(el, n) {\n  var clientWidth = el.clientWidth;\n  var clientHeight = el.clientHeight;\n  var viewBox = el.viewBox.baseVal;\n  var viewBoxWidth = viewBox.width || clientWidth;\n  var viewBoxHeight = viewBox.height || clientHeight;\n  var scaleX = clientWidth / viewBoxWidth;\n  var scaleY = clientHeight / viewBoxHeight;\n  var preserveAspectRatio = el.preserveAspectRatio.baseVal; // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n\n  var align = preserveAspectRatio.align; // 1 : meet 2: slice\n\n  var meetOrSlice = preserveAspectRatio.meetOrSlice;\n  var svgOrigin = [0, 0];\n  var scale = [scaleX, scaleY];\n  var translate = [0, 0];\n\n  if (align !== 1) {\n    var xAlign = (align - 2) % 3;\n    var yAlign = Math.floor((align - 2) / 3);\n    svgOrigin[0] = viewBoxWidth * xAlign / 2;\n    svgOrigin[1] = viewBoxHeight * yAlign / 2;\n    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n    scale[0] = scaleDimension;\n    scale[1] = scaleDimension;\n    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n  }\n\n  var scaleMatrix = createScaleMatrix(scale, n);\n  scaleMatrix[n - 1] = translate[0], scaleMatrix[2 * n - 1] = translate[1];\n  return getAbsoluteMatrix(scaleMatrix, n, svgOrigin);\n}\n\nfunction getSVGGraphicsOffset(el, origin) {\n  if (!el.getBBox) {\n    return [0, 0];\n  }\n\n  var bbox = el.getBBox();\n  var svgElement = el.ownerSVGElement;\n  var viewBox = svgElement.viewBox.baseVal;\n  var left = bbox.x - viewBox.x;\n  var top = bbox.y - viewBox.y;\n  return [left, top, origin[0] - left, origin[1] - top];\n}\n\nfunction caculatePosition(matrix, pos, n) {\n  return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\n\nfunction caculatePoses(matrix, width, height, n) {\n  var pos1 = caculatePosition(matrix, [0, 0], n);\n  var pos2 = caculatePosition(matrix, [width, 0], n);\n  var pos3 = caculatePosition(matrix, [0, height], n);\n  var pos4 = caculatePosition(matrix, [width, height], n);\n  return [pos1, pos2, pos3, pos4];\n}\n\nfunction getRect(poses) {\n  var posesX = poses.map(function (pos) {\n    return pos[0];\n  });\n  var posesY = poses.map(function (pos) {\n    return pos[1];\n  });\n  var left = Math.min.apply(Math, posesX);\n  var top = Math.min.apply(Math, posesY);\n  var right = Math.max.apply(Math, posesX);\n  var bottom = Math.max.apply(Math, posesY);\n  var rectWidth = right - left;\n  var rectHeight = bottom - top;\n  return {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    width: rectWidth,\n    height: rectHeight\n  };\n}\n\nfunction caculateRect(matrix, width, height, n) {\n  var poses = caculatePoses(matrix, width, height, n);\n  return getRect(poses);\n}\n\nfunction getSVGOffset(el, container, n, origin, beforeMatrix, absoluteMatrix) {\n  var _a;\n\n  var _b = getSize(el),\n      width = _b[0],\n      height = _b[1];\n\n  var containerClientRect = container.getBoundingClientRect();\n  var rect = el.getBoundingClientRect();\n  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft;\n  var rectTop = rect.top - containerClientRect.top + container.scrollTop;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n  var mat = multiplies(n, beforeMatrix, absoluteMatrix);\n\n  var _c = caculateRect(mat, width, height, n),\n      prevLeft = _c.left,\n      prevTop = _c.top,\n      prevWidth = _c.width,\n      prevHeight = _c.height;\n\n  var posOrigin = caculatePosition(mat, origin, n);\n  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];\n  var offset = [0, 0];\n  var count = 0;\n\n  while (++count < 10) {\n    var inverseBeforeMatrix = invert(beforeMatrix, n);\n    _a = minus(caculatePosition(inverseBeforeMatrix, rectOrigin, n), caculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a[0], offset[1] = _a[1];\n    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), absoluteMatrix);\n\n    var _d = caculateRect(mat2, width, height, n),\n        nextLeft = _d.left,\n        nextTop = _d.top;\n\n    var distLeft = nextLeft - rectLeft;\n    var distTop = nextTop - rectTop;\n\n    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n      break;\n    }\n\n    rectOrigin[0] -= distLeft;\n    rectOrigin[1] -= distTop;\n  }\n\n  return offset.map(function (p) {\n    return Math.round(p);\n  });\n}\n\nfunction caculateMoveablePosition(matrix, origin, width, height) {\n  var is3d = matrix.length === 16;\n  var n = is3d ? 4 : 3;\n\n  var _a = caculatePoses(matrix, width, height, n),\n      _b = _a[0],\n      x1 = _b[0],\n      y1 = _b[1],\n      _c = _a[1],\n      x2 = _c[0],\n      y2 = _c[1],\n      _d = _a[2],\n      x3 = _d[0],\n      y3 = _d[1],\n      _e = _a[3],\n      x4 = _e[0],\n      y4 = _e[1];\n\n  var _f = caculatePosition(matrix, origin, n),\n      originX = _f[0],\n      originY = _f[1];\n\n  var left = Math.min(x1, x2, x3, x4);\n  var top = Math.min(y1, y2, y3, y4);\n  var right = Math.max(x1, x2, x3, x4);\n  var bottom = Math.max(y1, y2, y3, y4);\n  x1 = x1 - left || 0;\n  x2 = x2 - left || 0;\n  x3 = x3 - left || 0;\n  x4 = x4 - left || 0;\n  y1 = y1 - top || 0;\n  y2 = y2 - top || 0;\n  y3 = y3 - top || 0;\n  y4 = y4 - top || 0;\n  originX = originX - left || 0;\n  originY = originY - top || 0;\n  var center = [(x1 + x2 + x3 + x4) / 4, (y1 + y2 + y3 + y4) / 4];\n  var pos1Rad = getRad(center, [x1, y1]);\n  var pos2Rad = getRad(center, [x2, y2]);\n  var direction = pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;\n  return [[left, top, right, bottom], [originX, originY], [x1, y1], [x2, y2], [x3, y3], [x4, y4], direction];\n}\n\nfunction getDistSize(vec) {\n  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\n\nfunction getDiagonalSize(pos1, pos2) {\n  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);\n}\n\nfunction getLineStyle(pos1, pos2, rad) {\n  if (rad === void 0) {\n    rad = getRad(pos1, pos2);\n  }\n\n  var width = getDiagonalSize(pos1, pos2);\n  return {\n    transform: \"translateY(-50%) translate(\" + pos1[0] + \"px, \" + pos1[1] + \"px) rotate(\" + rad + \"rad)\",\n    width: width + \"px\"\n  };\n}\n\nfunction getControlTransform(rotation) {\n  var poses = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    poses[_i - 1] = arguments[_i];\n  }\n\n  var length = poses.length;\n  var x = poses.reduce(function (prev, pos) {\n    return prev + pos[0];\n  }, 0) / length;\n  var y = poses.reduce(function (prev, pos) {\n    return prev + pos[1];\n  }, 0) / length;\n  return {\n    transform: \"translate(\" + x + \"px, \" + y + \"px) rotate(\" + rotation + \"rad)\"\n  };\n}\n\nfunction getCSSSize(target) {\n  var style = window.getComputedStyle(target);\n  return [parseFloat(style.width), parseFloat(style.height)];\n}\n\nfunction getSize(target, style, isOffset, isBoxSizing) {\n  if (style === void 0) {\n    style = window.getComputedStyle(target);\n  }\n\n  if (isBoxSizing === void 0) {\n    isBoxSizing = isOffset || style.boxSizing === \"border-box\";\n  }\n\n  var width = target.offsetWidth;\n  var height = target.offsetHeight;\n  var hasOffset = !isUndefined(width);\n\n  if ((isOffset || isBoxSizing) && hasOffset) {\n    return [width, height];\n  }\n\n  width = target.clientWidth;\n  height = target.clientHeight;\n\n  if (!hasOffset && !width && !height) {\n    var bbox = target.getBBox();\n    return [bbox.width, bbox.height];\n  }\n\n  if (isOffset || isBoxSizing) {\n    var borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    var borderRight = parseFloat(style.borderRightWidth) || 0;\n    var borderTop = parseFloat(style.borderTopWidth) || 0;\n    var borderBottom = parseFloat(style.borderBottomWidth) || 0;\n    return [width + borderLeft + borderRight, height + borderTop + borderBottom];\n  } else {\n    var paddingLeft = parseFloat(style.paddingLeft) || 0;\n    var paddingRight = parseFloat(style.paddingRight) || 0;\n    var paddingTop = parseFloat(style.paddingTop) || 0;\n    var paddingBottom = parseFloat(style.paddingBottom) || 0;\n    return [width - paddingLeft - paddingRight, height - paddingTop - paddingBottom];\n  }\n}\n\nfunction getRotationRad(poses, direction) {\n  return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\n\nfunction getTargetInfo(target, container, parentContainer, rootContainer, state) {\n  var _a, _b, _c, _d, _e;\n\n  var left = 0;\n  var top = 0;\n  var right = 0;\n  var bottom = 0;\n  var origin = [0, 0];\n  var pos1 = [0, 0];\n  var pos2 = [0, 0];\n  var pos3 = [0, 0];\n  var pos4 = [0, 0];\n  var rootMatrix = createIdentityMatrix3();\n  var offsetMatrix = createIdentityMatrix3();\n  var beforeMatrix = createIdentityMatrix3();\n  var matrix = createIdentityMatrix3();\n  var targetMatrix = createIdentityMatrix3();\n  var width = 0;\n  var height = 0;\n  var transformOrigin = [0, 0];\n  var direction = 1;\n  var beforeDirection = 1;\n  var is3d = false;\n  var targetTransform = \"\";\n  var beforeOrigin = [0, 0];\n  var targetClientRect = resetClientRect();\n  var containerClientRect = resetClientRect();\n  var rotation = 0;\n  var prevMatrix = state ? state.beforeMatrix : undefined;\n  var prevRootMatrix = state ? state.rootMatrix : undefined;\n  var prevN = state ? state.is3d ? 4 : 3 : undefined;\n\n  if (target) {\n    if (state) {\n      width = state.width;\n      height = state.height;\n    } else {\n      var style = getComputedStyle(target);\n      width = target.offsetWidth;\n      height = target.offsetHeight;\n\n      if (isUndefined(width)) {\n        _a = getSize(target, style, true), width = _a[0], height = _a[1];\n      }\n    }\n\n    _b = caculateMatrixStack(target, container, rootContainer, prevMatrix, prevRootMatrix, prevN), rootMatrix = _b[0], beforeMatrix = _b[1], offsetMatrix = _b[2], matrix = _b[3], targetMatrix = _b[4], targetTransform = _b[5], transformOrigin = _b[6], is3d = _b[7];\n    _c = caculateMoveablePosition(matrix, transformOrigin, width, height), _d = _c[0], left = _d[0], top = _d[1], right = _d[2], bottom = _d[3], origin = _c[1], pos1 = _c[2], pos2 = _c[3], pos3 = _c[4], pos4 = _c[5], direction = _c[6];\n    var n = is3d ? 4 : 3;\n    var beforePos = [0, 0];\n    _e = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height), beforePos = _e[0], beforeOrigin = _e[1], beforeDirection = _e[6];\n    beforeOrigin = [beforeOrigin[0] + beforePos[0] - left, beforeOrigin[1] + beforePos[1] - top];\n    targetClientRect = getClientRect(target);\n    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);\n    rotation = getRotationRad([pos1, pos2], direction);\n  }\n\n  return {\n    rotation: rotation,\n    targetClientRect: targetClientRect,\n    containerClientRect: containerClientRect,\n    beforeDirection: beforeDirection,\n    direction: direction,\n    target: target,\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom,\n    pos1: pos1,\n    pos2: pos2,\n    pos3: pos3,\n    pos4: pos4,\n    width: width,\n    height: height,\n    rootMatrix: rootMatrix,\n    beforeMatrix: beforeMatrix,\n    offsetMatrix: offsetMatrix,\n    targetMatrix: targetMatrix,\n    matrix: matrix,\n    targetTransform: targetTransform,\n    is3d: is3d,\n    beforeOrigin: beforeOrigin,\n    origin: origin,\n    transformOrigin: transformOrigin\n  };\n}\n\nfunction resetClientRect() {\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0,\n    width: 0,\n    height: 0,\n    clientWidth: 0,\n    clientHeight: 0,\n    scrollWidth: 0,\n    scrollHeight: 0\n  };\n}\n\nfunction getClientRect(el, isExtends) {\n  var _a = el.getBoundingClientRect(),\n      left = _a.left,\n      width = _a.width,\n      top = _a.top,\n      bottom = _a.bottom,\n      right = _a.right,\n      height = _a.height;\n\n  var rect = {\n    left: left,\n    right: right,\n    top: top,\n    bottom: bottom,\n    width: width,\n    height: height\n  };\n\n  if (isExtends) {\n    rect.clientWidth = el.clientWidth;\n    rect.clientHeight = el.clientHeight;\n    rect.scrollWidth = el.scrollWidth;\n    rect.scrollHeight = el.scrollHeight;\n  }\n\n  return rect;\n}\n\nfunction getDirection(target) {\n  if (!target) {\n    return;\n  }\n\n  var direciton = target.getAttribute(\"data-direction\");\n\n  if (!direciton) {\n    return;\n  }\n\n  var dir = [0, 0];\n  direciton.indexOf(\"w\") > -1 && (dir[0] = -1);\n  direciton.indexOf(\"e\") > -1 && (dir[0] = 1);\n  direciton.indexOf(\"n\") > -1 && (dir[1] = -1);\n  direciton.indexOf(\"s\") > -1 && (dir[1] = 1);\n  return dir;\n}\n\nfunction getAbsolutePoses(poses, dist) {\n  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];\n}\n\nfunction getAbsolutePosesByState(_a) {\n  var left = _a.left,\n      top = _a.top,\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\n\nfunction roundSign(num) {\n  return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\n\nfunction throttle(num, unit) {\n  if (!unit) {\n    return num;\n  }\n\n  return Math.round(num / unit) * unit;\n}\n\nfunction throttleArray(nums, unit) {\n  nums.forEach(function (_, i) {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n\nfunction unset(self, name) {\n  if (self[name]) {\n    self[name].unset();\n    self[name] = null;\n  }\n}\n\nfunction getOrientationDirection(pos, pos1, pos2) {\n  return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\n\nfunction isInside(pos, pos1, pos2, pos3, pos4) {\n  var k1 = getOrientationDirection(pos, pos1, pos2);\n  var k2 = getOrientationDirection(pos, pos2, pos4);\n  var k3 = getOrientationDirection(pos, pos4, pos1);\n  var k4 = getOrientationDirection(pos, pos2, pos4);\n  var k5 = getOrientationDirection(pos, pos4, pos3);\n  var k6 = getOrientationDirection(pos, pos3, pos2);\n  var signs1 = [k1, k2, k3];\n  var signs2 = [k4, k5, k6];\n\n  if (signs1.every(function (sign) {\n    return sign >= 0;\n  }) || signs1.every(function (sign) {\n    return sign <= 0;\n  }) || signs2.every(function (sign) {\n    return sign >= 0;\n  }) || signs2.every(function (sign) {\n    return sign <= 0;\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction fillParams(moveable, e, params) {\n  var datas = e.datas;\n\n  if (!datas.datas) {\n    datas.datas = {};\n  }\n\n  return __assign({}, params, {\n    target: moveable.state.target,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    inputEvent: e.inputEvent,\n    currentTarget: moveable,\n    datas: datas.datas\n  });\n}\n\nfunction triggerEvent(moveable, name, params) {\n  return moveable.triggerEvent(name, params);\n}\n\nfunction getComputedStyle(el, pseudoElt) {\n  return window.getComputedStyle(el, pseudoElt);\n}\n\nfunction filterAbles(ables, methods) {\n  var enabledAbles = {};\n  var ableGroups = {};\n  return ables.filter(function (able) {\n    var name = able.name;\n\n    if (enabledAbles[name] || !methods.some(function (method) {\n      return able[method];\n    })) {\n      return false;\n    }\n\n    if (able.ableGroup) {\n      if (ableGroups[able.ableGroup]) {\n        return false;\n      }\n\n      ableGroups[able.ableGroup] = true;\n    }\n\n    enabledAbles[name] = true;\n    return true;\n  });\n}\n\nfunction getKeepRatioHeight(width, isWidth, ratio) {\n  return width * (isWidth ? ratio : 1 / ratio);\n}\n\nfunction getKeepRatioWidth(height, isWidth, ratio) {\n  return height * (isWidth ? 1 / ratio : ratio);\n}\n\nfunction equals(a1, a2) {\n  return a1 === a2 || a1 == null && a2 == null;\n}\n\nfunction selectValue() {\n  var values = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n\n  var length = values.length - 1;\n\n  for (var i = 0; i < length; ++i) {\n    var value = values[i];\n\n    if (!isUndefined(value)) {\n      return value;\n    }\n  }\n\n  return values[length];\n}\n\nfunction groupBy(arr, func) {\n  var group = [];\n  var groupMap = {};\n  arr.forEach(function (el, index) {\n    var groupKey = func(el, index, arr);\n\n    if (!groupMap[groupKey]) {\n      groupMap[groupKey] = [];\n      group.push(groupMap[groupKey]);\n    }\n\n    groupMap[groupKey].push(el);\n  });\n  return group;\n}\n\nfunction flat(arr) {\n  return arr.reduce(function (prev, cur) {\n    return prev.concat(cur);\n  }, []);\n}\n\nfunction maxOffset() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  args.sort(function (a, b) {\n    return Math.abs(b) - Math.abs(a);\n  });\n  return args[0];\n}\n\nfunction convertDragDist(state, e) {\n  var _a;\n\n  var is3d = state.is3d,\n      rootMatrix = state.rootMatrix;\n  var n = is3d ? 4 : 3;\n  _a = caculate(invert(rootMatrix, n), convertPositionMatrix([e.distX, e.distY], n), n), e.distX = _a[0], e.distY = _a[1];\n  return e;\n}\n\nfunction triggerRenderStart(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.isPinch\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix + \"Start\", params);\n}\n\nfunction triggerRender(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.isPinch\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix, params);\n}\n\nfunction triggerRenderEnd(moveable, isGroup, e) {\n  var params = fillParams(moveable, e, {\n    isPinch: !!e.sPinch,\n    isDrag: e.isDrag\n  });\n  var eventAffix = isGroup ? \"Group\" : \"\";\n\n  if (isGroup) {\n    params.targets = moveable.props.targets;\n  }\n\n  triggerEvent(moveable, \"onRender\" + eventAffix + \"End\", params);\n}\n\nfunction triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e, isReqeust) {\n  var isStart = eventType === \"Start\";\n\n  if (isStart && eventAffix.indexOf(\"Control\") > -1 && !e.isRequest && moveable.areaElement === e.inputEvent.target) {\n    return false;\n  }\n\n  var eventName = \"\" + eventOperation + eventAffix + eventType;\n  var conditionName = \"\" + eventOperation + eventAffix + \"Condition\";\n  var isEnd = eventType === \"End\";\n  var isAfter = eventType.indexOf(\"After\") > -1;\n\n  if (isStart) {\n    moveable.updateRect(eventType, true, false);\n  }\n\n  if (eventType === \"\" && !isAfter) {\n    convertDragDist(moveable.state, e);\n  }\n\n  var isGroup = eventAffix.indexOf(\"Group\") > -1;\n  var ables = moveable[ableType];\n  var events = ables.filter(function (able) {\n    return able[eventName];\n  });\n  var results = events.filter(function (able) {\n    var condition = isStart && able[conditionName];\n\n    if (!condition || condition(e, moveable)) {\n      return able[eventName](moveable, e);\n    }\n\n    return false;\n  });\n  var isUpdate = results.length;\n\n  if (isStart) {\n    if (events.length && !isUpdate) {\n      moveable.state.dragger = null;\n\n      if (moveable.moveables) {\n        moveable.moveables.forEach(function (childeMoveable) {\n          childeMoveable.state.dragger = null;\n        });\n      }\n\n      return false;\n    }\n\n    triggerRenderStart(moveable, isGroup, e);\n  } else if (isEnd) {\n    triggerRenderEnd(moveable, isGroup, e);\n  } else if (isUpdate) {\n    triggerRender(moveable, isGroup, e);\n  }\n\n  if (isEnd) {\n    moveable.state.dragger = null;\n  }\n\n  if (!isStart && isUpdate) {\n    if (results.some(function (able) {\n      return able.updateRect;\n    }) && !isGroup) {\n      moveable.updateRect(eventType, false, false);\n    } else {\n      moveable.updateRect(eventType, true, false);\n    }\n  }\n\n  if ((!isStart && isUpdate || isEnd && !isUpdate) && !isReqeust) {\n    moveable.forceUpdate();\n  }\n\n  if (!isStart && !isEnd && !isAfter && isUpdate) {\n    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n  }\n}\n\nfunction getAbleDragger(moveable, target, ableType, eventAffix) {\n  var options = {\n    container: window,\n    pinchThreshold: moveable.props.pinchThreshold\n  };\n  [\"drag\", \"pinch\"].forEach(function (eventOperation) {\n    [\"Start\", \"\", \"End\"].forEach(function (eventType) {\n      options[\"\" + eventOperation + eventType.toLowerCase()] = function (e) {\n        return triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n      };\n    });\n  });\n  return new Dragger(target, options);\n}\n\nvar ControlBoxElement = styled(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction, pos1, pos2, index) {\n  var rad = getRad(pos1, pos2);\n  var rotation = direction ? throttle(rad / Math.PI * 180, 15) % 180 : -1;\n  return createElement(\"div\", {\n    key: \"line\" + index,\n    className: prefix(\"line\", \"direction\", direction),\n    \"data-rotation\": rotation,\n    \"data-direction\": direction,\n    style: getLineStyle(pos1, pos2, rad)\n  });\n}\n\nvar MoveableManager = /*#__PURE__*/function (_super) {\n  __extends(MoveableManager, _super);\n\n  function MoveableManager() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      container: null,\n      target: null,\n      beforeMatrix: createIdentityMatrix3(),\n      matrix: createIdentityMatrix3(),\n      targetMatrix: createIdentityMatrix3(),\n      targetTransform: \"\",\n      is3d: false,\n      left: 0,\n      top: 0,\n      width: 0,\n      height: 0,\n      transformOrigin: [0, 0],\n      direction: 1,\n      beforeDirection: 1,\n      beforeOrigin: [0, 0],\n      origin: [0, 0],\n      pos1: [0, 0],\n      pos2: [0, 0],\n      pos3: [0, 0],\n      pos4: [0, 0],\n      targetClientRect: resetClientRect(),\n      containerClientRect: resetClientRect(),\n      rotation: 0\n    };\n    _this.targetAbles = [];\n    _this.controlAbles = [];\n    return _this;\n  }\n\n  var __proto = MoveableManager.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var _a = this.props,\n        edge = _a.edge,\n        parentPosition = _a.parentPosition,\n        className = _a.className,\n        propsTarget = _a.target,\n        zoom = _a.zoom;\n    this.checkUpdate();\n\n    var _b = parentPosition || {\n      left: 0,\n      top: 0\n    },\n        parentLeft = _b.left,\n        parentTop = _b.top;\n\n    var _c = this.state,\n        left = _c.left,\n        top = _c.top,\n        pos1 = _c.pos1,\n        pos2 = _c.pos2,\n        pos3 = _c.pos3,\n        pos4 = _c.pos4,\n        stateTarget = _c.target,\n        direction = _c.direction;\n    var groupTargets = props.targets;\n    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;\n    return createElement(ControlBoxElement, {\n      ref: ref(this, \"controlBox\"),\n      className: prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\") + \" \" + className,\n      style: {\n        \"position\": \"absolute\",\n        \"display\": isDisplay ? \"block\" : \"none\",\n        \"transform\": \"translate(\" + (left - parentLeft) + \"px, \" + (top - parentTop) + \"px) translateZ(50px)\",\n        \"--zoom\": zoom,\n        \"--zoompx\": zoom + \"px\"\n      }\n    }, this.renderAbles(), renderLine(edge ? \"n\" : \"\", pos1, pos2, 0), renderLine(edge ? \"e\" : \"\", pos2, pos4, 1), renderLine(edge ? \"w\" : \"\", pos1, pos3, 2), renderLine(edge ? \"s\" : \"\", pos3, pos4, 3));\n  };\n\n  __proto.componentDidMount = function () {\n    this.controlBox.getElement();\n    var props = this.props;\n    var parentMoveable = props.parentMoveable,\n        container = props.container;\n    this.updateEvent(props);\n\n    if (!container && !parentMoveable) {\n      this.updateRect(\"End\", false, true);\n    }\n  };\n\n  __proto.componentDidUpdate = function (prevProps) {\n    this.updateEvent(prevProps);\n  };\n\n  __proto.componentWillUnmount = function () {\n    unset(this, \"targetDragger\");\n    unset(this, \"controlDragger\");\n  };\n\n  __proto.getContainer = function () {\n    var _a = this.props,\n        parentMoveable = _a.parentMoveable,\n        container = _a.container;\n    return container || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;\n  };\n\n  __proto.isMoveableElement = function (target) {\n    return target && (target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1;\n  };\n\n  __proto.dragStart = function (e) {\n    if (this.targetDragger) {\n      this.targetDragger.onDragStart(e);\n    }\n  };\n\n  __proto.isInside = function (clientX, clientY) {\n    var _a = this.state,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        target = _a.target,\n        targetClientRect = _a.targetClientRect;\n\n    if (!target) {\n      return false;\n    }\n\n    var left = targetClientRect.left,\n        top = targetClientRect.top;\n    var pos = [clientX - left, clientY - top];\n    return isInside(pos, pos1, pos2, pos4, pos3);\n  };\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    var props = this.props;\n    var parentMoveable = props.parentMoveable;\n    var state = this.state;\n    var target = state.target || this.props.target;\n    var container = this.getContainer();\n    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props.rootContainer;\n    this.updateState(getTargetInfo(target, container, container, rootContainer || container, isTarget ? state : undefined), parentMoveable ? false : isSetState);\n  };\n\n  __proto.updateEvent = function (prevProps) {\n    var controlBoxElement = this.controlBox.getElement();\n    var hasTargetAble = this.targetAbles.length;\n    var hasControlAble = this.controlAbles.length;\n    var target = this.props.target;\n    var prevTarget = prevProps.target;\n    var dragArea = this.props.dragArea;\n    var prevDragArea = prevProps.dragArea;\n    var isTargetChanged = !dragArea && prevTarget !== target;\n    var isUnset = !hasTargetAble && this.targetDragger || isTargetChanged || prevDragArea !== dragArea;\n\n    if (isUnset) {\n      unset(this, \"targetDragger\");\n      this.updateState({\n        dragger: null\n      });\n    }\n\n    if (!hasControlAble) {\n      unset(this, \"controlDragger\");\n    }\n\n    if (target && hasTargetAble && !this.targetDragger) {\n      if (dragArea) {\n        this.targetDragger = getAbleDragger(this, this.areaElement, \"targetAbles\", \"\");\n      } else {\n        this.targetDragger = getAbleDragger(this, target, \"targetAbles\", \"\");\n      }\n    }\n\n    if (!this.controlDragger && hasControlAble) {\n      this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n    }\n\n    if (isUnset) {\n      this.unsetAbles();\n    }\n  };\n\n  __proto.isDragging = function () {\n    return (this.targetDragger ? this.targetDragger.isFlag() : false) || (this.controlDragger ? this.controlDragger.isFlag() : false);\n  };\n\n  __proto.updateTarget = function (type) {\n    this.updateRect(type, true);\n  };\n\n  __proto.getRect = function () {\n    var state = this.state;\n    var poses = getAbsolutePosesByState(this.state);\n    var pos1 = poses[0],\n        pos2 = poses[1],\n        pos3 = poses[2],\n        pos4 = poses[3];\n    var rect = getRect(poses);\n    var offsetWidth = state.width,\n        offsetHeight = state.height;\n    var width = rect.width,\n        height = rect.height,\n        left = rect.left,\n        top = rect.top;\n    var statePos = [state.left, state.top];\n    var origin = plus(statePos, state.origin);\n    var beforeOrigin = plus(statePos, state.beforeOrigin);\n    return {\n      width: width,\n      height: height,\n      left: left,\n      top: top,\n      pos1: pos1,\n      pos2: pos2,\n      pos3: pos3,\n      pos4: pos4,\n      offsetWidth: offsetWidth,\n      offsetHeight: offsetHeight,\n      beforeOrigin: beforeOrigin,\n      origin: origin\n    };\n  };\n\n  __proto.request = function (ableName, param, isInstant) {\n    if (param === void 0) {\n      param = {};\n    }\n\n    var _a = this.props,\n        ables = _a.ables,\n        groupable = _a.groupable;\n    var requsetAble = ables.filter(function (able) {\n      return able.name === ableName;\n    })[0];\n\n    if (this.isDragging() || !requsetAble || !requsetAble.request) {\n      return {\n        request: function () {\n          return this;\n        },\n        requestEnd: function () {\n          return this;\n        }\n      };\n    }\n\n    var self = this;\n    var ableRequester = requsetAble.request(this);\n    var ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n    var eventAffix = \"\" + (groupable ? \"Group\" : \"\") + (ableRequester.isControl ? \"Control\" : \"\");\n    var requester = {\n      request: function (ableParam) {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"\", __assign({}, ableRequester.request(ableParam), {\n          isRequest: true\n        }), isInstant);\n        return this;\n      },\n      requestEnd: function () {\n        triggerAble(self, ableType, \"drag\", eventAffix, \"End\", __assign({}, ableRequester.requestEnd(), {\n          isRequest: true\n        }));\n        return this;\n      }\n    };\n    triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", __assign({}, ableRequester.requestStart(param), {\n      isRequest: true\n    }), isInstant);\n    return param.isInstant ? requester.request(param).requestEnd() : requester;\n  };\n\n  __proto.checkUpdate = function () {\n    var _a = this.props,\n        target = _a.target,\n        container = _a.container,\n        parentMoveable = _a.parentMoveable;\n    var _b = this.state,\n        stateTarget = _b.target,\n        stateContainer = _b.container;\n\n    if (!stateTarget && !target) {\n      return;\n    }\n\n    this.updateAbles();\n    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n    if (!isChanged) {\n      return;\n    }\n\n    this.updateState({\n      target: target,\n      container: container\n    });\n\n    if (!parentMoveable && (container || this.controlBox)) {\n      this.updateRect(\"End\", false, false);\n    }\n  };\n\n  __proto.triggerEvent = function (name, e) {\n    var callback = this.props[name];\n    return callback && callback(e);\n  };\n\n  __proto.unsetAbles = function () {\n    var _this = this;\n\n    if (this.targetAbles.filter(function (able) {\n      if (able.unset) {\n        able.unset(_this);\n        return true;\n      }\n\n      return false;\n    }).length) {\n      this.forceUpdate();\n    }\n  };\n\n  __proto.updateAbles = function (ables, eventAffix) {\n    if (ables === void 0) {\n      ables = this.props.ables;\n    }\n\n    if (eventAffix === void 0) {\n      eventAffix = \"\";\n    }\n\n    var props = this.props;\n    var enabledAbles = ables.filter(function (able) {\n      return able && props[able.name];\n    });\n    var dragStart = \"drag\" + eventAffix + \"Start\";\n    var pinchStart = \"pinch\" + eventAffix + \"Start\";\n    var dragControlStart = \"drag\" + eventAffix + \"ControlStart\";\n    var targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);\n    var controlAbles = filterAbles(enabledAbles, [dragControlStart]);\n    this.targetAbles = targetAbles;\n    this.controlAbles = controlAbles;\n  };\n\n  __proto.updateState = function (nextState, isSetState) {\n    if (isSetState) {\n      this.setState(nextState);\n    } else {\n      var state = this.state;\n\n      for (var name in nextState) {\n        state[name] = nextState[name];\n      }\n    }\n  };\n\n  __proto.renderAbles = function () {\n    var _this = this;\n\n    var props = this.props;\n    var ables = props.ables;\n    var enabledAbles = ables.filter(function (able) {\n      return able && props[able.name];\n    });\n    var Renderer = {\n      createElement: createElement\n    };\n    return flat(filterAbles(enabledAbles, [\"render\"]).map(function (_a) {\n      var render = _a.render;\n      return render(_this, Renderer);\n    }));\n  };\n\n  MoveableManager.defaultProps = {\n    target: null,\n    container: null,\n    rootContainer: null,\n    origin: true,\n    edge: false,\n    parentMoveable: null,\n    parentPosition: null,\n    ables: [],\n    pinchThreshold: 20,\n    dragArea: false,\n    transformOrigin: \"\",\n    className: \"\",\n    zoom: 1\n  };\n  return MoveableManager;\n}(PureComponent);\n\nfunction getRotatiion(touches) {\n  return getRad([touches[0].clientX, touches[0].clientY], [touches[1].clientX, touches[1].clientY]) / Math.PI * 180;\n}\n\nvar Pinchable = {\n  name: \"pinchable\",\n  updateRect: true,\n  props: {\n    pinchable: Boolean,\n    pinchThreshold: Number\n  },\n  pinchStart: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        touches = e.touches,\n        inputEvent = e.inputEvent,\n        targets = e.targets;\n    var _a = moveable.props,\n        pinchable = _a.pinchable,\n        ables = _a.ables;\n\n    if (!pinchable) {\n      return false;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"Start\";\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlStart\";\n    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function (able) {\n      return pinchable.indexOf(able.name) > -1;\n    })).filter(function (able) {\n      return able.canPinch && able[controlEventName];\n    });\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var result = triggerEvent(moveable, eventName, params);\n    datas.isPinch = result !== false;\n    datas.ables = pinchAbles;\n    var isPinch = datas.isPinch;\n\n    if (!isPinch) {\n      return false;\n    }\n\n    var parentRotate = getRotatiion(touches);\n    pinchAbles.forEach(function (able) {\n      datas[able.name + \"Datas\"] = {};\n      var ableEvent = {\n        datas: datas[able.name + \"Datas\"],\n        clientX: clientX,\n        clientY: clientY,\n        inputEvent: inputEvent,\n        parentRotate: parentRotate,\n        pinchFlag: true\n      };\n      able[controlEventName](moveable, ableEvent);\n    });\n    moveable.state.snapRenderInfo = {\n      direction: [0, 0]\n    };\n    return isPinch;\n  },\n  pinch: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        pinchScale = e.scale,\n        distance = e.distance,\n        touches = e.touches,\n        inputEvent = e.inputEvent,\n        targets = e.targets;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var parentRotate = getRotatiion(touches);\n    var parentDistance = distance * (1 - 1 / pinchScale);\n    var params = fillParams(moveable, e, {});\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\");\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"Control\";\n    ables.forEach(function (able) {\n      able[controlEventName](moveable, {\n        clientX: clientX,\n        clientY: clientY,\n        datas: datas[able.name + \"Datas\"],\n        inputEvent: inputEvent,\n        parentDistance: parentDistance,\n        parentRotate: parentRotate,\n        pinchFlag: true\n      });\n    });\n    return params;\n  },\n  pinchEnd: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        isPinch = e.isPinch,\n        inputEvent = e.inputEvent,\n        targets = e.targets;\n\n    if (!datas.isPinch) {\n      return;\n    }\n\n    var eventName = \"onPinch\" + (targets ? \"Group\" : \"\") + \"End\";\n    var params = fillParams(moveable, e, {\n      isDrag: isPinch\n    });\n\n    if (targets) {\n      params.targets = targets;\n    }\n\n    triggerEvent(moveable, eventName, params);\n    var ables = datas.ables;\n    var controlEventName = \"drag\" + (targets ? \"Group\" : \"\") + \"ControlEnd\";\n    ables.forEach(function (able) {\n      able[controlEventName](moveable, {\n        clientX: clientX,\n        clientY: clientY,\n        isDrag: isPinch,\n        datas: datas[able.name + \"Datas\"],\n        inputEvent: inputEvent,\n        pinchFlag: true\n      });\n    });\n    return isPinch;\n  },\n  pinchGroupStart: function (moveable, e) {\n    return this.pinchStart(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroup: function (moveable, e) {\n    return this.pinch(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  pinchGroupEnd: function (moveable, e) {\n    return this.pinchEnd(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  }\n};\n\nfunction triggerChildAble(moveable, able, type, datas, eachEvent, callback) {\n  var name = able.name;\n  var ableDatas = datas[name] || (datas[name] = []);\n  var isEnd = !!type.match(/End$/g);\n  var childs = moveable.moveables.map(function (child, i) {\n    var childDatas = ableDatas[i] || (ableDatas[i] = {});\n    var childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n    var result = able[type](child, __assign({}, childEvent, {\n      datas: childDatas,\n      parentFlag: true\n    }));\n    result && callback && callback(child, childDatas, result, i);\n\n    if (isEnd) {\n      child.state.dragger = null;\n    }\n\n    return result;\n  });\n  return childs;\n}\n\nfunction setDragStart(moveable, _a) {\n  var datas = _a.datas;\n  var _b = moveable.state,\n      matrix = _b.matrix,\n      beforeMatrix = _b.beforeMatrix,\n      is3d = _b.is3d,\n      left = _b.left,\n      top = _b.top,\n      origin = _b.origin,\n      offsetMatrix = _b.offsetMatrix,\n      targetMatrix = _b.targetMatrix,\n      transformOrigin = _b.transformOrigin;\n  var n = is3d ? 4 : 3;\n  datas.is3d = is3d;\n  datas.matrix = matrix;\n  datas.targetMatrix = targetMatrix;\n  datas.beforeMatrix = beforeMatrix;\n  datas.offsetMatrix = offsetMatrix;\n  datas.transformOrigin = transformOrigin;\n  datas.inverseMatrix = invert(matrix, n);\n  datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n  datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n  datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\n\nfunction getDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var inverseBeforeMatrix = datas.inverseBeforeMatrix,\n      inverseMatrix = datas.inverseMatrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(caculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);\n}\n\nfunction getInverseDragDist(_a, isBefore) {\n  var datas = _a.datas,\n      distX = _a.distX,\n      distY = _a.distY;\n  var beforeMatrix = datas.beforeMatrix,\n      matrix = datas.matrix,\n      is3d = datas.is3d,\n      startDragBeforeDist = datas.startDragBeforeDist,\n      startDragDist = datas.startDragDist,\n      absoluteOrigin = datas.absoluteOrigin;\n  var n = is3d ? 4 : 3;\n  return minus(caculate(isBefore ? beforeMatrix : matrix, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);\n}\n\nfunction caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin) {\n  if (prevWidth === void 0) {\n    prevWidth = width;\n  }\n\n  if (prevHeight === void 0) {\n    prevHeight = height;\n  }\n\n  if (prevOrigin === void 0) {\n    prevOrigin = [0, 0];\n  }\n\n  if (!transformOrigin) {\n    return prevOrigin;\n  }\n\n  return transformOrigin.map(function (pos, i) {\n    var _a = splitUnit(pos),\n        value = _a.value,\n        unit = _a.unit;\n\n    var prevSize = i ? prevHeight : prevWidth;\n    var size = i ? height : width;\n\n    if (pos === \"%\" || isNaN(value)) {\n      // no value but %\n      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n      return size * measureRatio;\n    } else if (unit !== \"%\") {\n      return value;\n    }\n\n    return size * value / 100;\n  });\n}\n\nfunction getPosIndexesByDirection(direction) {\n  var indexes = [];\n\n  if (direction[1] >= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(3);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(2);\n    }\n  }\n\n  if (direction[1] <= 0) {\n    if (direction[0] >= 0) {\n      indexes.push(1);\n    }\n\n    if (direction[0] <= 0) {\n      indexes.push(0);\n    }\n  }\n\n  return indexes;\n}\n\nfunction getPosesByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  return getPosIndexesByDirection(direction).map(function (index) {\n    return poses[index];\n  });\n}\n\nfunction getPosByDirection(poses, direction) {\n  /*\n  [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n  [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n  [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n  */\n  var nextPoses = getPosesByDirection(poses, direction);\n  return [average.apply(void 0, nextPoses.map(function (pos) {\n    return pos[0];\n  })), average.apply(void 0, nextPoses.map(function (pos) {\n    return pos[1];\n  }))];\n}\n\nfunction getPosByReverseDirection(_a, direction) {\n  /*\n  [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n  [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n  [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n  */\n  var pos1 = _a[0],\n      pos2 = _a[1],\n      pos3 = _a[2],\n      pos4 = _a[3];\n  return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\n\nfunction getStartPos(poses, direction) {\n  var startPos1 = poses[0],\n      startPos2 = poses[1],\n      startPos3 = poses[2],\n      startPos4 = poses[3];\n  return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\n\nfunction getDist(startPos, matrix, width, height, n, direction) {\n  var poses = caculatePoses(matrix, width, height, n);\n  var pos = getPosByReverseDirection(poses, direction);\n  var distX = startPos[0] - pos[0];\n  var distY = startPos[1] - pos[1];\n  return [distX, distY];\n}\n\nfunction getNextMatrix(offsetMatrix, targetMatrix, origin, n) {\n  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);\n}\n\nfunction scaleMatrix(state, scale) {\n  var transformOrigin = state.transformOrigin,\n      offsetMatrix = state.offsetMatrix,\n      is3d = state.is3d,\n      targetMatrix = state.targetMatrix;\n  var n = is3d ? 4 : 3;\n  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin, n);\n}\n\nfunction getScaleDist(moveable, scale, direction, dragClient) {\n  var state = moveable.state;\n  var is3d = state.is3d,\n      left = state.left,\n      top = state.top,\n      width = state.width,\n      height = state.height;\n  var n = is3d ? 4 : 3;\n  var groupable = moveable.props.groupable;\n  var nextMatrix = scaleMatrix(moveable.state, scale);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n  var dist = getDist(startPos, nextMatrix, width, height, n, direction);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getResizeDist(moveable, width, height, // prevWidth: number,\n// prevHeight: number,\ndirection, fixedPosition, transformOrigin) {\n  var groupable = moveable.props.groupable;\n  var _a = moveable.state,\n      prevOrigin = _a.transformOrigin,\n      targetMatrix = _a.targetMatrix,\n      offsetMatrix = _a.offsetMatrix,\n      is3d = _a.is3d,\n      prevWidth = _a.width,\n      prevHeight = _a.height,\n      left = _a.left,\n      top = _a.top;\n  var n = is3d ? 4 : 3;\n  var nextOrigin = caculateTransformOrigin(transformOrigin, width, height, prevWidth, prevHeight, prevOrigin);\n  var groupLeft = groupable ? left : 0;\n  var groupTop = groupable ? top : 0;\n  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n  var dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n  return minus(dist, [groupLeft, groupTop]);\n}\n\nfunction getStartDirection(moveable, direction) {\n  if (!direction[0] && !direction[1]) {\n    return [0, 0];\n  }\n\n  var _a = moveable.props.baseDirection,\n      baseDirection = _a === void 0 ? [-1, -1] : _a;\n  return [direction[0] ? direction[0] : baseDirection[0] * -1, direction[1] ? direction[1] : baseDirection[1] * -1];\n}\n\nfunction getAbsoluteFixedPosition(moveable, direction) {\n  return getStartPos(getAbsolutePosesByState(moveable.state), direction);\n}\n\nfunction directionCondition(e) {\n  if (e.isRequest) {\n    return e.parentDirection;\n  }\n\n  return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n\nfunction getTotalGuidelines(moveable) {\n  var _a = moveable.state,\n      guidelines = _a.guidelines,\n      _b = _a.containerClientRect,\n      containerHeight = _b.scrollHeight,\n      containerWidth = _b.scrollWidth;\n  var props = moveable.props;\n  var _c = props.snapHorizontal,\n      snapHorizontal = _c === void 0 ? true : _c,\n      _d = props.snapVertical,\n      snapVertical = _d === void 0 ? true : _d,\n      verticalGuidelines = props.verticalGuidelines,\n      horizontalGuidelines = props.horizontalGuidelines;\n  var totalGuidelines = guidelines.slice();\n\n  if (snapHorizontal && horizontalGuidelines) {\n    horizontalGuidelines.forEach(function (pos) {\n      totalGuidelines.push({\n        type: \"horizontal\",\n        pos: [0, throttle(pos, 0.1)],\n        size: containerWidth\n      });\n    });\n  }\n\n  if (snapVertical && verticalGuidelines) {\n    verticalGuidelines.forEach(function (pos) {\n      totalGuidelines.push({\n        type: \"vertical\",\n        pos: [throttle(pos, 0.1), 0],\n        size: containerHeight\n      });\n    });\n  }\n\n  return totalGuidelines;\n}\n\nfunction checkSnapPoses(moveable, posesX, posesY, snapCenter, customSnapThreshold) {\n  var totalGuidelines = getTotalGuidelines(moveable);\n  var props = moveable.props;\n  var _a = props.snapElement,\n      snapElement = _a === void 0 ? true : _a;\n  var snapThreshold = selectValue(customSnapThreshold, props.snapThreshold, 5);\n  return {\n    vertical: checkSnap(totalGuidelines, \"vertical\", posesX, snapThreshold, snapCenter, snapElement),\n    horizontal: checkSnap(totalGuidelines, \"horizontal\", posesY, snapThreshold, snapCenter, snapElement)\n  };\n}\n\nfunction checkSnapKeepRatio(moveable, startPos, endPos) {\n  var endX = endPos[0],\n      endY = endPos[1];\n  var startX = startPos[0],\n      startY = startPos[1];\n\n  var _a = minus(endPos, startPos),\n      dx = _a[0],\n      dy = _a[1];\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  var verticalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isSnap: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  }\n\n  var _b = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []),\n      verticalSnapInfo = _b.vertical,\n      horizontalSnapInfo = _b.horizontal;\n\n  verticalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isRight ? pos >= startX : pos <= startX;\n  });\n  horizontalSnapInfo.posInfos.filter(function (_a) {\n    var pos = _a.pos;\n    return isBottom ? pos >= startY : pos <= startY;\n  });\n  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo),\n      isVerticalSnap = _c.isSnap,\n      verticalGuideline = _c.guideline;\n\n  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo),\n      isHorizontalSnap = _d.isSnap,\n      horizontalGuideline = _d.guideline;\n\n  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;\n  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;\n\n  if (dx === 0) {\n    if (isHorizontalSnap) {\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = horizontalGuideline.pos[1];\n      horizontalInfo.offset = endY - horizontalInfo.pos;\n    }\n  } else if (dy === 0) {\n    if (isVerticalSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = verticalPos;\n      verticalInfo.offset = endX - verticalPos;\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isSnap = false;\n\n    if (isVerticalSnap) {\n      x = verticalPos;\n      y = a * x + b;\n      isSnap = true;\n    } else if (isHorizontalSnap) {\n      y = horizontalPos;\n      x = (y - b) / a;\n      isSnap = true;\n    }\n\n    if (isSnap) {\n      verticalInfo.isSnap = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isSnap = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkSnaps(moveable, rect, isCenter, customSnapThreshold) {\n  var snapCenter = moveable.props.snapCenter;\n  var isSnapCenter = snapCenter && isCenter;\n  var verticalNames = [\"left\", \"right\"];\n  var horizontalNames = [\"top\", \"bottom\"];\n\n  if (isSnapCenter) {\n    verticalNames.push(\"center\");\n    horizontalNames.push(\"middle\");\n  }\n\n  verticalNames = verticalNames.filter(function (name) {\n    return name in rect;\n  });\n  horizontalNames = horizontalNames.filter(function (name) {\n    return name in rect;\n  });\n  return checkSnapPoses(moveable, verticalNames.map(function (name) {\n    return rect[name];\n  }), horizontalNames.map(function (name) {\n    return rect[name];\n  }), isSnapCenter, customSnapThreshold);\n}\n\nfunction getNearestSnapGuidelineInfo(snapInfo) {\n  var isSnap = snapInfo.isSnap;\n\n  if (!isSnap) {\n    return {\n      isSnap: false,\n      offset: 0,\n      dist: -1,\n      pos: 0,\n      guideline: null\n    };\n  }\n\n  var posInfo = snapInfo.posInfos[0];\n  var guidelineInfo = posInfo.guidelineInfos[0];\n  var offset = guidelineInfo.offset;\n  var dist = guidelineInfo.dist;\n  var guideline = guidelineInfo.guideline;\n  return {\n    isSnap: isSnap,\n    offset: offset,\n    dist: dist,\n    pos: posInfo.pos,\n    guideline: guideline\n  };\n}\n\nfunction checkSnap(guidelines, targetType, targetPoses, snapThreshold, snapCenter, snapElement) {\n  if (!guidelines || !guidelines.length) {\n    return {\n      isSnap: false,\n      posInfos: []\n    };\n  }\n\n  var isVertical = targetType === \"vertical\";\n  var posType = isVertical ? 0 : 1;\n  var snapPosInfos = targetPoses.map(function (targetPos) {\n    var guidelineInfos = guidelines.map(function (guideline) {\n      var pos = guideline.pos;\n      var offset = targetPos - pos[posType];\n      return {\n        offset: offset,\n        dist: Math.abs(offset),\n        guideline: guideline\n      };\n    }).filter(function (_a) {\n      var guideline = _a.guideline,\n          dist = _a.dist;\n      var type = guideline.type,\n          center = guideline.center,\n          element = guideline.element;\n\n      if (!snapElement && element || !snapCenter && center || type !== targetType || dist > snapThreshold) {\n        return false;\n      }\n\n      return true;\n    }).sort(function (a, b) {\n      return a.dist - b.dist;\n    });\n    return {\n      pos: targetPos,\n      guidelineInfos: guidelineInfos\n    };\n  }).filter(function (snapPosInfo) {\n    return snapPosInfo.guidelineInfos.length > 0;\n  }).sort(function (a, b) {\n    return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n  });\n  return {\n    isSnap: snapPosInfos.length > 0,\n    posInfos: snapPosInfos\n  };\n}\n\nfunction getSnapInfosByDirection(moveable, poses, snapDirection) {\n  var nextPoses = [];\n\n  if (snapDirection[0] && snapDirection[1]) {\n    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function (direction) {\n      return getPosByDirection(poses, direction);\n    });\n  } else if (!snapDirection[0] && !snapDirection[1]) {\n    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n    for (var i = 0; i < 4; ++i) {\n      nextPoses.push(alignPoses[i]);\n      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);\n    }\n  } else {\n    if (moveable.props.keepRatio) {\n      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function (dir) {\n        return getPosByDirection(poses, dir);\n      });\n    } else {\n      nextPoses = getPosesByDirection(poses, snapDirection);\n\n      if (nextPoses.length > 1) {\n        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);\n      }\n    }\n  }\n\n  return checkSnapPoses(moveable, nextPoses.map(function (pos) {\n    return pos[0];\n  }), nextPoses.map(function (pos) {\n    return pos[1];\n  }), true, 1);\n}\n\nfunction getNearOffsetInfo(offsets, index) {\n  return offsets.slice().sort(function (a, b) {\n    var aSign = a.sign[index];\n    var bSign = b.sign[index];\n    var aOffset = a.offset[index];\n    var bOffset = b.offset[index];\n    var aDist = Math.abs(aOffset);\n    var bDist = Math.abs(bOffset); // -1 The positions of a and b do not change.\n    // 1 The positions of a and b are reversed.\n\n    if (!aSign) {\n      return 1;\n    } else if (!bSign) {\n      return -1;\n    } else if (a.isBound && b.isBound) {\n      return bDist - aDist;\n    } else if (a.isBound) {\n      return -1;\n    } else if (b.isBound) {\n      return 1;\n    } else if (a.isSnap && b.isSnap) {\n      return aDist - bDist;\n    } else if (a.isSnap) {\n      return -1;\n    } else if (b.isSnap) {\n      return 1;\n    } else if (aDist < TINY_NUM) {\n      return 1;\n    } else if (bDist < TINY_NUM) {\n      return -1;\n    }\n\n    return aDist - bDist;\n  })[0];\n}\n\nfunction isStartLine(dot, line) {\n  // l    o     => true\n  // o    l    => false\n  var cx = average(line[0][0], line[1][0]);\n  var cy = average(line[0][1], line[1][1]);\n  return {\n    vertical: cx <= dot[0],\n    horizontal: cy <= dot[1]\n  };\n}\n\nfunction hitTestLine(dot, _a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n  var test1;\n  var test2;\n\n  if (!dx) {\n    test1 = pos1[0];\n    test2 = dot[0];\n  } else if (!dy) {\n    test1 = pos1[1];\n    test2 = dot[1];\n  } else {\n    var a = dy / dx; // y = a * (x - pos1) + pos1\n\n    test1 = a * (dot[0] - pos1[0]) + pos1[1];\n    test2 = dot[1];\n  }\n\n  return test1 - test2;\n}\n\nfunction isSameStartLine(dots, line, error) {\n  if (error === void 0) {\n    error = TINY_NUM;\n  }\n\n  var centerSign = hitTestLine(dots[0], line) <= 0;\n  return dots.slice(1).every(function (dot) {\n    var value = hitTestLine(dot, line);\n    var sign = value <= 0;\n    return sign === centerSign || Math.abs(value) <= error;\n  });\n}\n\nfunction checkInnerBoundDot(pos, start, end, isStart, threshold) {\n  if (threshold === void 0) {\n    threshold = 0;\n  }\n\n  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {\n    // false 402 565 602 => 37 ([0, 37])\n    // true 400 524.9712603540036 600 => 124 ([124, 0])\n    // true 400 410 600 => 10 ([10, 0])\n    return {\n      isBound: true,\n      offset: isStart ? start - pos : end - pos\n    };\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction checkInnerBound(moveable, line, center) {\n  var bounds = moveable.props.innerBounds;\n\n  if (!bounds) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n\n  var _a = isStartLine(center, line),\n      isHorizontalStart = _a.horizontal,\n      isVerticalStart = _a.vertical;\n\n  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {\n    return {\n      isAllBound: false,\n      isBound: false,\n      isVerticalBound: false,\n      isHorizontalBound: false,\n      offset: [0, 0]\n    };\n  } // test vertical\n\n\n  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart); // test horizontal\n\n  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n  var offset = [0, 0];\n  var isBound = false;\n  var isAllBound = false;\n\n  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n    offset = [verticalOffset, 0];\n    isBound = isVerticalBound;\n    isAllBound = isAllVerticalBound;\n  } else {\n    offset = [0, horizontalOffset];\n    isBound = isHorizontalBound;\n    isAllBound = isAllHorizontalBound;\n  }\n\n  return {\n    isAllBound: isAllBound,\n    isVerticalBound: isVerticalBound,\n    isHorizontalBound: isHorizontalBound,\n    isBound: isBound,\n    offset: offset\n  };\n}\n\nfunction checkLineBoundCollision(line, boundLine, isStart, threshold) {\n  var dot1 = line[0];\n  var dot2 = line[1];\n  var boundDot1 = boundLine[0];\n  var boundDot2 = boundLine[1];\n  var dy1 = dot2[1] - dot1[1];\n  var dx1 = dot2[0] - dot1[0];\n  var dy2 = boundDot2[1] - boundDot1[1];\n  var dx2 = boundDot2[0] - boundDot1[0]; // dx2 or dy2 is zero\n\n  if (!dx2) {\n    // vertical\n    if (dx1) {\n      var y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1]; // boundDot1[1] <= y  <= boundDot2[1]\n\n      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n    }\n  } else if (!dy2) {\n    // horizontal\n    if (dy1) {\n      // y = a * (x - x1) + y1\n      // x = (y - y1) / a + x1\n      var a = dy1 / dx1;\n      var x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0]; // boundDot1[0] <= x && x <= boundDot2[0]\n\n      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n    }\n  }\n\n  return {\n    isBound: false,\n    offset: 0\n  };\n}\n\nfunction getInnerBoundInfo(moveable, lines, center, datas) {\n  return lines.map(function (_a) {\n    var multiple = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n\n    var _b = checkInnerBound(moveable, [pos1, pos2], center),\n        isBound = _b.isBound,\n        offset = _b.offset,\n        isVerticalBound = _b.isVerticalBound,\n        isHorizontalBound = _b.isHorizontalBound;\n\n    var sizeOffset = getDragDist({\n      datas: datas,\n      distX: offset[0],\n      distY: offset[1]\n    }).map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isBound,\n      isVerticalBound: isVerticalBound,\n      isHorizontalBound: isHorizontalBound,\n      isSnap: false,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getInnerBoundDragInfo(moveable, poses, datas) {\n  var _a;\n\n  var lines = getCheckSnapLines(poses, [0, 0], false).map(function (_a) {\n    var sign = _a[0],\n        pos1 = _a[1],\n        pos2 = _a[2];\n    return [sign.map(function (dir) {\n      return Math.abs(dir) * 2;\n    }), pos1, pos2];\n  });\n  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n  var verticalOffset = 0;\n  var horizontalOffset = 0;\n  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n  if (isVerticalBound || isHorizontalBound) {\n    _a = getInverseDragDist({\n      datas: datas,\n      distX: -widthOffsetInfo.offset[0],\n      distY: -heightOffsetInfo.offset[1]\n    }), verticalOffset = _a[0], horizontalOffset = _a[1];\n  }\n\n  return {\n    vertical: {\n      isBound: isVerticalBound,\n      offset: verticalOffset\n    },\n    horizontal: {\n      isBound: isHorizontalBound,\n      offset: horizontalOffset\n    }\n  };\n}\n\nfunction getCheckSnapLineDirections(direction, keepRatio) {\n  var lineDirections = [];\n  var x = direction[0];\n  var y = direction[1];\n\n  if (x && y) {\n    lineDirections.push([[0, y * 2], direction, [-x, y]], [[x * 2, 0], direction, [x, -y]]);\n  } else if (x) {\n    // vertcal\n    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);\n\n    if (keepRatio) {\n      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);\n    }\n  } else if (y) {\n    // horizontal\n    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);\n\n    if (keepRatio) {\n      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);\n  }\n\n  return lineDirections;\n}\n\nfunction getCheckSnapLines(poses, direction, keepRatio) {\n  return getCheckSnapLineDirections(direction, keepRatio).map(function (_a) {\n    var sign = _a[0],\n        dir1 = _a[1],\n        dir2 = _a[2];\n    return [sign, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];\n  });\n}\n\nfunction isBoundRotate(relativePoses, boundDots, center, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  var dots = [center].concat(boundDots);\n  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function (line, i) {\n    return !isSameStartLine(dots, line);\n  });\n}\n\nfunction getDistPointLine(_a) {\n  // x = 0, y = 0\n  // d = (ax + by + c) / root(a2 + b2)\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return Math.abs(pos1[0]);\n  }\n\n  if (!dy) {\n    return Math.abs(pos1[1]);\n  } // y - y1 = a(x - x1)\n  // 0 = ax -y + -a * x1 + y1\n\n\n  var a = dy / dx;\n  return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\n\nfunction solveReverseLine(_a) {\n  var pos1 = _a[0],\n      pos2 = _a[1];\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (!dx) {\n    return [pos1[0], 0];\n  }\n\n  if (!dy) {\n    return [0, pos1[1]];\n  }\n\n  var a = dy / dx; // y - y1 = a (x  - x1)\n  // y = ax - a * x1 + y1\n\n  var b = -a * pos1[0] + pos1[1]; // y = ax + b = -1/a x\n  // x = -b / (a + 1 / a)\n  // y = b / (1 + 1 / a^2)\n\n  return [-b / (a + 1 / a), b / (a * a + 1)];\n}\n\nfunction checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.innerBounds;\n  var rad = rotation * Math.PI / 180;\n\n  if (!bounds) {\n    return [];\n  }\n\n  var left = bounds.left,\n      top = bounds.top,\n      width = bounds.width,\n      height = bounds.height;\n  var relativeLeft = left - origin[0];\n  var relativeRight = left + width - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = top + height - origin[1];\n  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];\n  var center = getPosByDirection(nextPoses, [0, 0]);\n\n  if (!isBoundRotate(nextPoses, dots, center, 0)) {\n    return [];\n  }\n\n  var result = [];\n  var dotInfos = dots.map(function (dot) {\n    return [getDistSize(dot), getRad([0, 0], dot)];\n  });\n  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function (line) {\n    var lineRad = getRad([0, 0], solveReverseLine(line));\n    var lineDist = getDistPointLine(line);\n    result.push.apply(result, dotInfos.filter(function (_a) {\n      var dotDist = _a[0];\n      return dotDist && lineDist <= dotDist;\n    }).map(function (_a) {\n      var dotDist = _a[0],\n          dotRad = _a[1];\n      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n      var nextRad1 = dotRad + distRad;\n      var nextRad2 = dotRad - distRad;\n      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];\n    }).reduce(function (prev, cur) {\n      prev.push.apply(prev, cur);\n      return prev;\n    }, []).filter(function (nextRad) {\n      return !isBoundRotate(prevPoses, dots, center, nextRad);\n    }).map(function (nextRad) {\n      return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n    }));\n  });\n  return result;\n}\n\nfunction checkInnerBoundPoses(moveable) {\n  var innerBounds = moveable.props.innerBounds;\n\n  if (!innerBounds) {\n    return {\n      vertical: [],\n      horizontal: []\n    };\n  }\n\n  var _a = moveable.getRect(),\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4;\n\n  var poses = [pos1, pos2, pos3, pos4];\n  var center = getPosByDirection(poses, [0, 0]);\n  var left = innerBounds.left,\n      top = innerBounds.top,\n      width = innerBounds.width,\n      height = innerBounds.height;\n  var leftLine = [[left, top], [left, top + height]];\n  var topLine = [[left, top], [left + width, top]];\n  var rightLine = [[left + width, top], [left + width, top + height]];\n  var bottomLine = [[left, top + height], [left + width, top + height]];\n  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];\n  var horizontalPoses = [];\n  var verticalPoses = [];\n  var boundMap = {\n    top: false,\n    bottom: false,\n    left: false,\n    right: false\n  };\n  lines.forEach(function (line) {\n    var _a = isStartLine(center, line),\n        isHorizontalStart = _a.horizontal,\n        isVerticalStart = _a.vertical; // test vertical\n\n\n    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1);\n    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1); // test horizontal\n\n    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1);\n    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1);\n\n    if (topBoundInfo.isBound && !boundMap.top) {\n      horizontalPoses.push(top);\n      boundMap.top = true;\n    }\n\n    if (bottomBoundInfo.isBound && !boundMap.bottom) {\n      horizontalPoses.push(top + height);\n      boundMap.bottom = true;\n    }\n\n    if (leftBoundInfo.isBound && !boundMap.left) {\n      verticalPoses.push(left);\n      boundMap.left = true;\n    }\n\n    if (rightBoundInfo.isBound && !boundMap.right) {\n      verticalPoses.push(left + width);\n      boundMap.right = true;\n    }\n  });\n  return {\n    horizontal: horizontalPoses,\n    vertical: verticalPoses\n  };\n}\n\nfunction checkBoundPoses(moveable, verticalPoses, horizontalPoses) {\n  var _a = moveable.props.bounds || {},\n      _b = _a.left,\n      left = _b === void 0 ? -Infinity : _b,\n      _c = _a.top,\n      top = _c === void 0 ? -Infinity : _c,\n      _d = _a.right,\n      right = _d === void 0 ? Infinity : _d,\n      _e = _a.bottom,\n      bottom = _e === void 0 ? Infinity : _e;\n\n  var bounds = {\n    left: left,\n    top: top,\n    right: right,\n    bottom: bottom\n  };\n  return {\n    vertical: checkBound(bounds, verticalPoses, true),\n    horizontal: checkBound(bounds, horizontalPoses, false)\n  };\n}\n\nfunction checkBoundKeepRatio(moveable, startPos, endPos) {\n  var _a = moveable.props.bounds || {},\n      _b = _a.left,\n      left = _b === void 0 ? -Infinity : _b,\n      _c = _a.top,\n      top = _c === void 0 ? -Infinity : _c,\n      _d = _a.right,\n      right = _d === void 0 ? Infinity : _d,\n      _e = _a.bottom,\n      bottom = _e === void 0 ? Infinity : _e;\n\n  var endX = endPos[0],\n      endY = endPos[1];\n\n  var _f = minus(endPos, startPos),\n      dx = _f[0],\n      dy = _f[1];\n\n  var isBottom = dy > 0;\n  var isRight = dx > 0;\n  var verticalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n  var horizontalInfo = {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n\n  if (dx === 0 && dy === 0) {\n    return {\n      vertical: verticalInfo,\n      horizontal: horizontalInfo\n    };\n  } else if (dx === 0) {\n    if (isBottom) {\n      if (bottom < endY) {\n        horizontalInfo.pos = bottom;\n        horizontalInfo.offset = endY - bottom;\n      }\n    } else {\n      if (top > endY) {\n        horizontalInfo.pos = top;\n        horizontalInfo.offset = endY - top;\n      }\n    }\n  } else if (dy === 0) {\n    if (isRight) {\n      if (right < endX) {\n        verticalInfo.pos = right;\n        verticalInfo.offset = endX - right;\n      }\n    } else {\n      if (left > endX) {\n        verticalInfo.pos = left;\n        verticalInfo.offset = endX - left;\n      }\n    }\n  } else {\n    // y - y1 = a * (x - x1)\n    var a = dy / dx;\n    var b = endPos[1] - a * endX;\n    var y = 0;\n    var x = 0;\n    var isBound = false;\n\n    if (isRight && right <= endX) {\n      y = a * right + b;\n      x = right;\n      isBound = true;\n    } else if (!isRight && endX <= left) {\n      y = a * left + b;\n      x = left;\n      isBound = true;\n    } else if (isBottom && bottom <= endY) {\n      y = bottom;\n      x = (y - b) / a;\n      isBound = true;\n    } else if (!isBottom && endY <= top) {\n      y = top;\n      x = (y - b) / a;\n      isBound = true;\n    }\n\n    if (isBound) {\n      verticalInfo.isBound = true;\n      verticalInfo.pos = x;\n      verticalInfo.offset = endX - x;\n      horizontalInfo.isBound = true;\n      horizontalInfo.pos = y;\n      horizontalInfo.offset = endY - y;\n    }\n  }\n\n  return {\n    vertical: verticalInfo,\n    horizontal: horizontalInfo\n  };\n}\n\nfunction checkBound(bounds, poses, isVertical) {\n  // 0   [100 - 200]  300\n  var startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n  var endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"]; // 450\n\n  var minPos = Math.min.apply(Math, poses);\n  var maxPos = Math.max.apply(Math, poses);\n\n  if (startBoundPos + 1 > minPos) {\n    return {\n      isBound: true,\n      offset: minPos - startBoundPos,\n      pos: startBoundPos\n    };\n  }\n\n  if (endBoundPos - 1 < maxPos) {\n    return {\n      isBound: true,\n      offset: maxPos - endBoundPos,\n      pos: endBoundPos\n    };\n  }\n\n  return {\n    isBound: false,\n    offset: 0,\n    pos: 0\n  };\n}\n\nfunction isBoundRotate$1(relativePoses, boundRect, rad) {\n  var nextPoses = rad ? relativePoses.map(function (pos) {\n    return rotate(pos, rad);\n  }) : relativePoses;\n  return nextPoses.some(function (pos) {\n    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;\n  });\n}\n\nfunction boundRotate(vec, boundPos, index) {\n  var r = getDistSize(vec);\n  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n  return [nextPos, -nextPos].sort(function (a, b) {\n    return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n  }).map(function (pos) {\n    return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n  });\n}\n\nfunction checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {\n  var bounds = moveable.props.bounds;\n  var rad = rotation * Math.PI / 180;\n\n  if (!bounds) {\n    return [];\n  }\n\n  var _a = bounds.left,\n      left = _a === void 0 ? -Infinity : _a,\n      _b = bounds.top,\n      top = _b === void 0 ? -Infinity : _b,\n      _c = bounds.right,\n      right = _c === void 0 ? Infinity : _c,\n      _d = bounds.bottom,\n      bottom = _d === void 0 ? Infinity : _d;\n  var relativeLeft = left - origin[0];\n  var relativeRight = right - origin[0];\n  var relativeTop = top - origin[1];\n  var relativeBottom = bottom - origin[1];\n  var boundRect = {\n    left: relativeLeft,\n    top: relativeTop,\n    right: relativeRight,\n    bottom: relativeBottom\n  };\n\n  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {\n    return [];\n  }\n\n  var result = [];\n  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function (_a, i) {\n    var boundPos = _a[0],\n        index = _a[1];\n    nextPoses.forEach(function (nextPos) {\n      var relativeRad1 = getRad([0, 0], nextPos);\n      result.push.apply(result, boundRotate(nextPos, boundPos, index).map(function (relativeRad2) {\n        return rad + relativeRad2 - relativeRad1;\n      }).filter(function (nextRad) {\n        return !isBoundRotate$1(prevPoses, boundRect, nextRad);\n      }).map(function (nextRad) {\n        return throttle(nextRad * 180 / Math.PI, TINY_NUM);\n      }));\n    });\n  });\n  return result;\n}\n\nfunction snapStart(moveable) {\n  var state = moveable.state;\n\n  if (state.guidelines && state.guidelines.length) {\n    return;\n  }\n\n  var _a = moveable.props,\n      _b = _a.horizontalGuidelines,\n      horizontalGuidelines = _b === void 0 ? [] : _b,\n      _c = _a.verticalGuidelines,\n      verticalGuidelines = _c === void 0 ? [] : _c,\n      _d = _a.elementGuidelines,\n      elementGuidelines = _d === void 0 ? [] : _d,\n      bounds = _a.bounds,\n      snapCenter = _a.snapCenter;\n\n  if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n    return;\n  }\n\n  var _e = state.containerClientRect,\n      containerTop = _e.top,\n      containerLeft = _e.left,\n      _f = state.targetClientRect,\n      clientTop = _f.top,\n      clientLeft = _f.left;\n  var poses = getAbsolutePosesByState(state);\n  var targetLeft = Math.min.apply(Math, poses.map(function (pos) {\n    return pos[0];\n  }));\n  var targetTop = Math.min.apply(Math, poses.map(function (pos) {\n    return pos[1];\n  }));\n  var distLeft = roundSign(targetLeft - (clientLeft - containerLeft));\n  var distTop = roundSign(targetTop - (clientTop - containerTop));\n  var guidelines = [];\n  elementGuidelines.forEach(function (el) {\n    var rect = el.getBoundingClientRect();\n    var top = rect.top,\n        left = rect.left,\n        width = rect.width,\n        height = rect.height;\n    var elementTop = top - containerTop;\n    var elementBottom = elementTop + height;\n    var elementLeft = left - containerLeft;\n    var elementRight = elementLeft + width;\n    guidelines.push({\n      type: \"vertical\",\n      element: el,\n      pos: [throttle(elementLeft + distLeft, 0.1), elementTop],\n      size: height\n    });\n    guidelines.push({\n      type: \"vertical\",\n      element: el,\n      pos: [throttle(elementRight + distLeft, 0.1), elementTop],\n      size: height\n    });\n    guidelines.push({\n      type: \"horizontal\",\n      element: el,\n      pos: [elementLeft, throttle(elementTop + distTop, 0.1)],\n      size: width\n    });\n    guidelines.push({\n      type: \"horizontal\",\n      element: el,\n      pos: [elementLeft, throttle(elementBottom + distTop, 0.1)],\n      size: width\n    });\n\n    if (snapCenter) {\n      guidelines.push({\n        type: \"vertical\",\n        element: el,\n        pos: [throttle((elementLeft + elementRight) / 2 + distLeft, 0.1), elementTop],\n        size: height,\n        center: true\n      });\n      guidelines.push({\n        type: \"horizontal\",\n        element: el,\n        pos: [elementLeft, throttle((elementTop + elementBottom) / 2 + distTop, 0.1)],\n        size: width,\n        center: true\n      });\n    }\n  });\n  state.guidelines = guidelines;\n  state.enableSnap = true;\n}\n\nfunction hasGuidelines(moveable, ableName) {\n  var _a = moveable.props,\n      snappable = _a.snappable,\n      bounds = _a.bounds,\n      verticalGuidelines = _a.verticalGuidelines,\n      horizontalGuidelines = _a.horizontalGuidelines,\n      _b = moveable.state,\n      guidelines = _b.guidelines,\n      enableSnap = _b.enableSnap;\n\n  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {\n    return false;\n  }\n\n  if (bounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction solveNextOffset(pos1, pos2, offset, isVertical, datas) {\n  var sizeOffset = solveEquation(pos1, pos2, -offset, isVertical);\n\n  if (!sizeOffset) {\n    return [0, 0];\n  }\n\n  var _a = getDragDist({\n    datas: datas,\n    distX: sizeOffset[0],\n    distY: sizeOffset[1]\n  }),\n      widthOffset = _a[0],\n      heightOffset = _a[1];\n\n  return [widthOffset, heightOffset];\n}\n\nfunction getNextFixedPoses(matrix, width, height, fixedPos, direction, is3d) {\n  var nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n  var nextPos = getPosByReverseDirection(nextPoses, direction);\n  return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\n\nfunction getSnapBoundOffset(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return snapInfo.offset;\n  }\n\n  return 0;\n}\n\nfunction getSnapBound(boundInfo, snapInfo) {\n  if (boundInfo.isBound) {\n    return boundInfo.offset;\n  } else if (snapInfo.isSnap) {\n    return getNearestSnapGuidelineInfo(snapInfo).offset;\n  }\n\n  return 0;\n}\n\nfunction checkSnapBoundsKeepRatio(moveable, startPos, endPos) {\n  var _a = checkBoundKeepRatio(moveable, startPos, endPos),\n      horizontalBoundInfo = _a.horizontal,\n      verticalBoundInfo = _a.vertical;\n\n  var _b = checkSnapKeepRatio(moveable, startPos, endPos),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\n\nfunction checkSnapBounds(moveable, poses, boundPoses) {\n  if (boundPoses === void 0) {\n    boundPoses = poses;\n  }\n\n  var _a = checkBoundPoses(moveable, boundPoses.map(function (pos) {\n    return pos[0];\n  }), boundPoses.map(function (pos) {\n    return pos[1];\n  })),\n      horizontalBoundInfo = _a.horizontal,\n      verticalBoundInfo = _a.vertical;\n\n  var _b = checkSnapPoses(moveable, poses.map(function (pos) {\n    return pos[0];\n  }), poses.map(function (pos) {\n    return pos[1];\n  })),\n      horizontalSnapInfo = _b.horizontal,\n      verticalSnapInfo = _b.vertical;\n\n  var horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n  var verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n  var horizontalDist = Math.abs(horizontalOffset);\n  var verticalDist = Math.abs(verticalOffset);\n  return {\n    horizontal: {\n      isBound: horizontalBoundInfo.isBound,\n      isSnap: horizontalSnapInfo.isSnap,\n      offset: horizontalOffset,\n      dist: horizontalDist\n    },\n    vertical: {\n      isBound: verticalBoundInfo.isBound,\n      isSnap: verticalSnapInfo.isSnap,\n      offset: verticalOffset,\n      dist: verticalDist\n    }\n  };\n}\n\nfunction checkMaxBounds(moveable, width, height, poses, direction, fixedPos, datas) {\n  var fixedDirection = [-direction[0], -direction[1]];\n  var bounds = moveable.props.bounds;\n  var maxWidth = Infinity;\n  var maxHeight = Infinity;\n\n  if (bounds) {\n    var directions = [[direction[0], -direction[1]], [-direction[0], direction[1]]];\n    var _a = bounds.left,\n        left_1 = _a === void 0 ? -Infinity : _a,\n        _b = bounds.top,\n        top_1 = _b === void 0 ? -Infinity : _b,\n        _c = bounds.right,\n        right_1 = _c === void 0 ? Infinity : _c,\n        _d = bounds.bottom,\n        bottom_1 = _d === void 0 ? Infinity : _d;\n    directions.forEach(function (otherDirection) {\n      var isCheckVertical = otherDirection[0] !== fixedDirection[0];\n      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n      var otherPos = getPosByDirection(poses, otherDirection);\n\n      if (isCheckHorizontal) {\n        var _a = solveNextOffset(fixedPos, otherPos, (fixedPos[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas),\n            heightOffset = _a[1];\n\n        if (!isNaN(heightOffset)) {\n          maxHeight = height + heightOffset;\n        }\n      }\n\n      if (isCheckVertical) {\n        var widthOffset = solveNextOffset(fixedPos, otherPos, (fixedPos[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas)[0];\n\n        if (!isNaN(widthOffset)) {\n          maxWidth = width + widthOffset;\n        }\n      }\n    });\n  }\n\n  return {\n    maxWidth: maxWidth,\n    maxHeight: maxHeight\n  };\n}\n\nfunction getSnapBoundInfo(moveable, poses, directions, keepRatio, datas) {\n  return directions.map(function (_a) {\n    var startDirection = _a[0],\n        endDirection = _a[1];\n    var otherStartPos = getPosByDirection(poses, startDirection);\n    var otherEndPos = getPosByDirection(poses, endDirection);\n    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos) : checkSnapBounds(moveable, [otherEndPos]);\n    var _b = snapBoundInfo.horizontal,\n        otherHorizontalDist = _b.dist,\n        otherHorizontalOffset = _b.offset,\n        isOtherHorizontalBound = _b.isBound,\n        isOtherHorizontalSnap = _b.isSnap,\n        _c = snapBoundInfo.vertical,\n        otherVerticalDist = _c.dist,\n        otherVerticalOffset = _c.offset,\n        isOtherVerticalBound = _c.isBound,\n        isOtherVerticalSnap = _c.isSnap;\n    var multiple = minus(endDirection, startDirection);\n\n    if (!otherVerticalOffset && !otherHorizontalOffset) {\n      return {\n        isBound: isOtherVerticalBound || isOtherHorizontalBound,\n        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n        sign: multiple,\n        offset: [0, 0]\n      };\n    }\n\n    var isVertical = otherHorizontalDist < otherVerticalDist;\n    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, isVertical ? otherVerticalOffset : otherHorizontalOffset, isVertical, datas).map(function (size, i) {\n      return size * (multiple[i] ? 2 / multiple[i] : 0);\n    });\n    return {\n      sign: multiple,\n      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n      offset: sizeOffset\n    };\n  });\n}\n\nfunction getCheckSnapDirections(direction, keepRatio) {\n  var directions = [];\n  var fixedDirection = [-direction[0], -direction[1]];\n\n  if (direction[0] && direction[1]) {\n    directions.push([fixedDirection, [direction[0], -direction[1]]], [fixedDirection, [-direction[0], direction[1]]]);\n\n    if (keepRatio) {\n      // pass two direction condition\n      directions.push([fixedDirection, direction]);\n    }\n  } else if (direction[0]) {\n    // vertcal\n    if (keepRatio) {\n      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction[0], -1]], [fixedDirection, direction], [fixedDirection, [direction[0], 1]]);\n    } else {\n      directions.push([[fixedDirection[0], -1], [direction[0], -1]], [[fixedDirection[0], 0], [direction[0], 0]], [[fixedDirection[0], 1], [direction[0], 1]]);\n    }\n  } else if (direction[1]) {\n    // horizontal\n    if (keepRatio) {\n      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction[1]]], [fixedDirection, [1, direction[1]]], [fixedDirection, direction]);\n    } else {\n      directions.push([[-1, fixedDirection[1]], [-1, direction[1]]], [[0, fixedDirection[1]], [0, direction[1]]], [[1, fixedDirection[1]], [1, direction[1]]]);\n    }\n  } else {\n    // [0, 0] to all direction\n    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);\n  }\n\n  return directions;\n}\n\nfunction getSizeOffsetInfo(moveable, poses, direction, keepRatio, datas) {\n  var directions = getCheckSnapDirections(direction, keepRatio);\n  var lines = getCheckSnapLines(poses, direction, keepRatio);\n  var offsets = getSnapBoundInfo(moveable, poses, directions, keepRatio, datas).concat(getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));\n  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n  return {\n    width: {\n      isBound: widthOffsetInfo.isBound,\n      offset: widthOffsetInfo.offset[0]\n    },\n    height: {\n      isBound: heightOffsetInfo.isBound,\n      offset: heightOffsetInfo.offset[1]\n    }\n  };\n}\n\nfunction recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction, datas) {\n  var snapPos = getPosByDirection(poses, direction);\n\n  var _a = checkSnapBounds(moveable, [snapPos]),\n      horizontalOffset = _a.horizontal.offset,\n      verticalOffset = _a.vertical.offset;\n\n  if (verticalOffset || horizontalOffset) {\n    var _b = getDragDist({\n      datas: datas,\n      distX: -verticalOffset,\n      distY: -horizontalOffset\n    }),\n        nextWidthOffset = _b[0],\n        nextHeightOffset = _b[1];\n\n    var nextWidth = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n    var nextHeight = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n    return [nextWidth - width, nextHeight - height];\n  }\n\n  return [0, 0];\n}\n\nfunction checkSizeDist(moveable, getNextPoses, matrix, width, height, direction, snapDirection, fixedPos, isRequest, is3d, datas) {\n  var poses = getAbsolutePosesByState(moveable.state);\n  var keepRatio = moveable.props.keepRatio;\n  var widthOffset = 0;\n  var heightOffset = 0;\n\n  for (var i = 0; i < 2; ++i) {\n    var nextPoses = getNextPoses(widthOffset, heightOffset);\n\n    var _a = getSizeOffsetInfo(moveable, nextPoses, direction, keepRatio, datas),\n        widthOffsetInfo = _a.width,\n        heightOffsetInfo = _a.height;\n\n    var isWidthBound = widthOffsetInfo.isBound;\n    var isHeightBound = heightOffsetInfo.isBound;\n    var nextWidthOffset = widthOffsetInfo.offset;\n    var nextHeightOffset = heightOffsetInfo.offset;\n\n    if (i === 1) {\n      if (!isWidthBound) {\n        nextWidthOffset = 0;\n      }\n\n      if (!isHeightBound) {\n        nextHeightOffset = 0;\n      }\n    }\n\n    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n      return [0, 0];\n    }\n\n    if (keepRatio) {\n      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist; // height * widthOffset = width * heighOffset\n\n      if (isGetWidthOffset) {\n        // width : height = ? : heightOffset\n        nextWidthOffset = width * nextHeightOffset / height;\n      } else {\n        // width : height = widthOffset : ?\n        nextHeightOffset = height * nextWidthOffset / width;\n      }\n    }\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n    return [widthOffset, heightOffset];\n  }\n\n  if (direction[0] && direction[1]) {\n    var _b = checkMaxBounds(moveable, width, height, poses, direction, fixedPos, datas),\n        maxWidth = _b.maxWidth,\n        maxHeight = _b.maxHeight;\n\n    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction, datas),\n        nextWidthOffset = _c[0],\n        nextHeightOffset = _c[1];\n\n    widthOffset += nextWidthOffset;\n    heightOffset += nextHeightOffset;\n  }\n\n  return [widthOffset, heightOffset];\n}\n\nfunction checkSnapRotate(moveable, rect, origin, rotation) {\n  if (!hasGuidelines(moveable, \"rotatable\")) {\n    return rotation;\n  }\n\n  var pos1 = rect.pos1,\n      pos2 = rect.pos2,\n      pos3 = rect.pos3,\n      pos4 = rect.pos4;\n  var rad = rotation * Math.PI / 180;\n  var prevPoses = [pos1, pos2, pos3, pos4].map(function (pos) {\n    return minus(pos, origin);\n  });\n  var nextPoses = prevPoses.map(function (pos) {\n    return rotate(pos, rad);\n  });\n  var result = checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation).concat(checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));\n  result.sort(function (a, b) {\n    return Math.abs(a - rotation) - Math.abs(b - rotation);\n  });\n\n  if (result.length) {\n    return result[0];\n  } else {\n    return rotation;\n  }\n}\n\nfunction checkSnapSize(moveable, width, height, direction, fixedPos, isRequest, datas) {\n  if (!hasGuidelines(moveable, \"resizable\")) {\n    return [0, 0];\n  }\n\n  var _a = moveable.state,\n      matrix = _a.matrix,\n      is3d = _a.is3d;\n  return checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(matrix, width + widthOffset, height + heightOffset, fixedPos, direction, is3d);\n  }, matrix, width, height, direction, direction, fixedPos, isRequest, is3d, datas);\n}\n\nfunction checkSnapScale(moveable, scale, direction, snapDirection, fixedPos, isRequest, datas) {\n  var width = datas.width,\n      height = datas.height;\n\n  if (!hasGuidelines(moveable, \"scalable\")) {\n    return [0, 0];\n  }\n\n  var is3d = datas.is3d;\n  var sizeDist = checkSizeDist(moveable, function (widthOffset, heightOffset) {\n    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPos, direction, is3d);\n  }, scaleMatrix(datas, scale), width, height, direction, snapDirection, fixedPos, isRequest, is3d, datas);\n  return [sizeDist[0] / width, sizeDist[1] / height];\n}\n\nfunction solveEquation(pos1, pos2, snapOffset, isVertical) {\n  var dx = pos2[0] - pos1[0];\n  var dy = pos2[1] - pos1[1];\n\n  if (Math.abs(dx) < TINY_NUM) {\n    dx = 0;\n  }\n\n  if (Math.abs(dy) < TINY_NUM) {\n    dy = 0;\n  }\n\n  if (!dx) {\n    // y = 0 * x + b\n    // only horizontal\n    if (!isVertical) {\n      return [0, snapOffset];\n    }\n\n    return [0, 0];\n  }\n\n  if (!dy) {\n    // only vertical\n    if (isVertical) {\n      return [snapOffset, 0];\n    }\n\n    return [0, 0];\n  } // y = ax + b\n\n\n  var a = dy / dx;\n  var b = pos1[1] - a * pos1[0];\n\n  if (isVertical) {\n    // y = a * x + b\n    var y = a * (pos2[0] + snapOffset) + b;\n    return [snapOffset, y - pos2[1]];\n  } else {\n    // x = (y - b) / a\n    var x = (pos2[1] + snapOffset - b) / a;\n    return [x - pos2[0], snapOffset];\n  }\n}\n\nfunction startCheckSnapDrag(moveable, datas) {\n  datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nfunction checkThrottleDragRotate(throttleDragRotate, _a, _b, _c, _d) {\n  var distX = _a[0],\n      distY = _a[1];\n  var isVerticalBound = _b[0],\n      isHorizontalBound = _b[1];\n  var isVerticalSnap = _c[0],\n      isHorizontalSnap = _c[1];\n  var verticalOffset = _d[0],\n      horizontalOffset = _d[1];\n  var offsetX = -verticalOffset;\n  var offsetY = -horizontalOffset;\n\n  if (throttleDragRotate && distX && distY) {\n    offsetX = 0;\n    offsetY = 0;\n    var adjustPoses = [];\n\n    if (isVerticalBound && isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalBound) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalBound) {\n      adjustPoses.push([0, horizontalOffset]);\n    } else if (isVerticalSnap && isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);\n    } else if (isVerticalSnap) {\n      adjustPoses.push([verticalOffset, 0]);\n    } else if (isHorizontalSnap) {\n      adjustPoses.push([0, horizontalOffset]);\n    }\n\n    if (adjustPoses.length) {\n      adjustPoses.sort(function (a, b) {\n        return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n      });\n      var adjustPos = adjustPoses[0];\n\n      if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n        offsetX = -adjustPos[0];\n        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n        var prevDistY = distY;\n        offsetY = -adjustPos[1];\n        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n      }\n\n      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n        if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n          offsetX *= scale;\n          offsetY *= scale;\n        } else {\n          offsetX = maxOffset(-verticalOffset, offsetX);\n          offsetY = maxOffset(-horizontalOffset, offsetY);\n        }\n      }\n    }\n  } else {\n    offsetX = distX || isVerticalBound ? -verticalOffset : 0;\n    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;\n  }\n\n  return [offsetX, offsetY];\n}\n\nfunction checkSnapDrag(moveable, distX, distY, throttleDragRotate, datas) {\n  if (!hasGuidelines(moveable, \"draggable\")) {\n    return [{\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }, {\n      isSnap: false,\n      isBound: false,\n      offset: 0\n    }];\n  }\n\n  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);\n\n  var _a = getRect(poses),\n      left = _a.left,\n      right = _a.right,\n      top = _a.top,\n      bottom = _a.bottom;\n\n  var snapCenter = moveable.props.snapCenter;\n  var snapPoses = [[left, top], [right, top], [left, bottom], [right, bottom]];\n\n  if (snapCenter) {\n    snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n  }\n\n  var _b = checkSnapBounds(moveable, snapPoses, poses),\n      verticalSnapBoundInfo = _b.vertical,\n      horizontalSnapBoundInfo = _b.horizontal;\n\n  var _c = getInnerBoundDragInfo(moveable, poses, datas),\n      verticalInnerBoundInfo = _c.vertical,\n      horizontalInnerBoundInfo = _c.horizontal;\n\n  var isVerticalSnap = verticalSnapBoundInfo.isSnap;\n  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;\n  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;\n  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n\n  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]),\n      offsetX = _d[0],\n      offsetY = _d[1];\n\n  return [{\n    isBound: isVerticalBound,\n    isSnap: isVerticalSnap,\n    offset: offsetX\n  }, {\n    isBound: isHorizontalBound,\n    isSnap: isHorizontalSnap,\n    offset: offsetY\n  }];\n}\n\nfunction getSnapGuidelines(posInfos) {\n  var guidelines = [];\n  posInfos.forEach(function (posInfo) {\n    posInfo.guidelineInfos.forEach(function (_a) {\n      var guideline = _a.guideline;\n\n      if (guidelines.indexOf(guideline) > -1) {\n        return;\n      }\n\n      guidelines.push(guideline);\n    });\n  });\n  return guidelines;\n}\n\nfunction getElementGuidelineDist(elementPos, elementSize, targetPos, targetSize) {\n  // relativePos < 0  => element(l)  ---  (r)target\n  // relativePos > 0  => target(l)   ---  (r)element\n  var relativePos = elementPos - targetPos;\n  var startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n  var endPos = relativePos < 0 ? 0 : relativePos;\n  var size = endPos - startPos;\n  return {\n    size: size,\n    pos: startPos\n  };\n}\n\nfunction groupByElementGuidelines(guidelines, clientPos, size, index) {\n  var groupInfos = [];\n  var group = groupBy(guidelines.filter(function (_a) {\n    var element = _a.element;\n    return element;\n  }), function (_a) {\n    var element = _a.element,\n        pos = _a.pos,\n        size2 = _a.size;\n    var elementPos = pos[index];\n    var sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n    var groupKey = sign + \"_\" + pos[index ? 0 : 1];\n    var groupInfo = find(groupInfos, function (_a) {\n      var groupElement = _a[0],\n          groupPos = _a[1];\n      return element === groupElement && elementPos === groupPos;\n    });\n\n    if (groupInfo) {\n      return groupInfo[2];\n    }\n\n    groupInfos.push([element, elementPos, groupKey]);\n    return groupKey;\n  });\n  group.forEach(function (elementGuidelines) {\n    elementGuidelines.sort(function (a, b) {\n      var result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n      return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n    });\n  });\n  return group;\n}\n\nfunction renderElementGroup(group, _a, minPos, clientPos, clientSize, targetPos, snapThreshold, isDisplaySnapDigit, snapDigit, index, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return flat(group.map(function (elementGuidelines, i) {\n    var isFirstRenderSize = true;\n    return elementGuidelines.map(function (_a, j) {\n      var _b;\n\n      var pos = _a.pos,\n          size = _a.size;\n\n      var _c = getElementGuidelineDist(pos[index], size, clientPos, clientSize),\n          linePos = _c.pos,\n          lineSize = _c.size;\n\n      if (lineSize < snapThreshold) {\n        return null;\n      }\n\n      var isRenderSize = isFirstRenderSize;\n      isFirstRenderSize = false;\n      var snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n      return React.createElement(\"div\", {\n        className: prefix(\"line\", directionName, \"guideline\", \"dashed\"),\n        \"data-size\": snapSize > 0 ? snapSize : \"\",\n        key: directionName + \"LinkGuidline\" + i + \"-\" + j,\n        style: (_b = {}, _b[posName1] = minPos + linePos + \"px\", _b[posName2] = -targetPos + pos[index ? 0 : 1] + \"px\", _b[sizeName] = lineSize + \"px\", _b)\n      });\n    });\n  }));\n}\n\nfunction renderSnapPoses(snapPoses, _a, minPos, targetPos, size, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return snapPoses.map(function (pos, i) {\n    var _a;\n\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", directionName, \"guideline\", \"target\", \"bold\"),\n      key: directionName + \"TargetGuidline\" + i,\n      style: (_a = {}, _a[posName1] = minPos + \"px\", _a[posName2] = -targetPos + pos + \"px\", _a[sizeName] = size + \"px\", _a)\n    });\n  });\n}\n\nfunction renderGuidelines(guidelines, _a, targetPos1, targetPos2, index, React) {\n  var directionName = _a[0],\n      posName1 = _a[1],\n      posName2 = _a[2],\n      sizeName = _a[3];\n  return guidelines.map(function (guideline, i) {\n    var _a;\n\n    var pos = guideline.pos,\n        size = guideline.size,\n        element = guideline.element;\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", directionName, \"guideline\", element ? \"bold\" : \"\"),\n      key: directionName + \"Guidline\" + i,\n      style: (_a = {}, _a[posName1] = -targetPos1 + pos[index] + \"px\", _a[posName2] = -targetPos2 + pos[index ? 0 : 1] + \"px\", _a[sizeName] = size + \"px\", _a)\n    });\n  });\n}\n\nfunction addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses) {\n  var _a = checkBoundPoses(moveable, verticalPoses, horizontalPoses),\n      _b = _a.vertical,\n      isVerticalBound = _b.isBound,\n      verticalBoundPos = _b.pos,\n      _c = _a.horizontal,\n      isHorizontalBound = _c.isBound,\n      horizontalBoundPos = _c.pos;\n\n  if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n    verticalSnapPoses.push(verticalBoundPos);\n  }\n\n  if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n    horizontalSnapPoses.push(horizontalBoundPos);\n  }\n\n  var _d = checkInnerBoundPoses(moveable),\n      verticalInnerBoundPoses = _d.vertical,\n      horizontalInnerBoundPoses = _d.horizontal;\n\n  verticalSnapPoses.push.apply(verticalSnapPoses, verticalInnerBoundPoses.filter(function (pos) {\n    return verticalSnapPoses.indexOf(pos) < 0;\n  }));\n  horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalInnerBoundPoses.filter(function (pos) {\n    return horizontalSnapPoses.indexOf(pos) < 0;\n  }));\n}\n\nvar Snappable = {\n  name: \"snappable\",\n  props: {\n    snappable: [Boolean, Array],\n    snapCenter: Boolean,\n    snapHorizontal: Boolean,\n    snapVertical: Boolean,\n    snapElement: Boolean,\n    isDisplaySnapDigit: Boolean,\n    snapDigit: Number,\n    snapThreshold: Number,\n    horizontalGuidelines: Array,\n    verticalGuidelines: Array,\n    elementGuidelines: Array,\n    bounds: Object,\n    innerBounds: Object\n  },\n  render: function (moveable, React) {\n    var _a = moveable.state,\n        targetTop = _a.top,\n        targetLeft = _a.left,\n        pos1 = _a.pos1,\n        pos2 = _a.pos2,\n        pos3 = _a.pos3,\n        pos4 = _a.pos4,\n        snapRenderInfo = _a.snapRenderInfo,\n        targetClientRect = _a.targetClientRect,\n        containerClientRect = _a.containerClientRect;\n    var clientLeft = targetClientRect.left - containerClientRect.left;\n    var clientTop = targetClientRect.top - containerClientRect.top;\n    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n\n    if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n      return [];\n    }\n\n    var _b = moveable.props,\n        _c = _b.snapThreshold,\n        snapThreshold = _c === void 0 ? 5 : _c,\n        _d = _b.snapDigit,\n        snapDigit = _d === void 0 ? 0 : _d,\n        _e = _b.isDisplaySnapDigit,\n        isDisplaySnapDigit = _e === void 0 ? true : _e;\n    var poses = getAbsolutePosesByState(moveable.state);\n\n    var _f = getRect(poses),\n        width = _f.width,\n        height = _f.height,\n        top = _f.top,\n        left = _f.left,\n        bottom = _f.bottom,\n        right = _f.right;\n\n    var verticalSnapPoses = [];\n    var horizontalSnapPoses = [];\n    var verticalGuildelines = [];\n    var horizontalGuidelines = [];\n    var snapInfos = [];\n\n    if (snapRenderInfo.direction) {\n      snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n    }\n\n    if (snapRenderInfo.snap) {\n      var rect = getRect(poses);\n\n      if (snapRenderInfo.center) {\n        rect.middle = (rect.top + rect.bottom) / 2;\n        rect.center = (rect.left + rect.right) / 2;\n      }\n\n      snapInfos.push(checkSnaps(moveable, rect, true, 1));\n    }\n\n    snapInfos.forEach(function (snapInfo) {\n      var verticalPosInfos = snapInfo.vertical.posInfos,\n          horizontalPosInfos = snapInfo.horizontal.posInfos;\n      verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.map(function (posInfo) {\n        return posInfo.pos;\n      }));\n      horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.map(function (posInfo) {\n        return posInfo.pos;\n      }));\n      verticalGuildelines.push.apply(verticalGuildelines, getSnapGuidelines(verticalPosInfos));\n      horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));\n    });\n    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);\n    var elementHorizontalGroup = groupByElementGuidelines(horizontalGuidelines, clientLeft, width, 0);\n    var elementVerticalGroup = groupByElementGuidelines(verticalGuildelines, clientTop, height, 1);\n    var horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"];\n    var verticalNames = [\"vertical\", \"top\", \"left\", \"height\"];\n    return renderElementGroup(elementHorizontalGroup, horizontalNames, minLeft, clientLeft, width, targetTop, snapThreshold, isDisplaySnapDigit, snapDigit, 0, React).concat(renderElementGroup(elementVerticalGroup, verticalNames, minTop, clientTop, height, targetLeft, snapThreshold, isDisplaySnapDigit, snapDigit, 1, React), renderSnapPoses(horizontalSnapPoses, horizontalNames, minLeft, targetTop, width, React), renderSnapPoses(verticalSnapPoses, verticalNames, minTop, targetLeft, height, React), renderGuidelines(horizontalGuidelines, horizontalNames, targetLeft, targetTop, 0, React), renderGuidelines(verticalGuildelines, verticalNames, targetTop, targetLeft, 1, React));\n  },\n  dragStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = {\n      snap: true,\n      center: true\n    };\n    snapStart(moveable);\n  },\n  pinchStart: function (moveable) {\n    this.unset(moveable);\n  },\n  dragEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragControlCondition: function (e) {\n    return directionCondition(e) || dragControlCondition(e);\n  },\n  dragControlStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragControlEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragGroupStart: function (moveable, e) {\n    this.dragStart(moveable, e);\n  },\n  dragGroupEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  dragGroupControlStart: function (moveable, e) {\n    moveable.state.snapRenderInfo = null;\n    snapStart(moveable);\n  },\n  dragGroupControlEnd: function (moveable) {\n    this.unset(moveable);\n  },\n  unset: function (moveable) {\n    var state = moveable.state;\n    state.enableSnap = false;\n    state.guidelines = [];\n    state.snapRenderInfo = null;\n  }\n};\n/**\n * @namespace Draggable\n * @memberof Moveable\n */\n\nvar Draggable = {\n  name: \"draggable\",\n  props: {\n    draggable: Boolean,\n    throttleDrag: Number,\n    throttleDragRotate: Number\n  },\n  render: function (moveable, React) {\n    var throttleDragRotate = moveable.props.throttleDragRotate;\n    var _a = moveable.state,\n        dragInfo = _a.dragInfo,\n        beforeOrigin = _a.beforeOrigin;\n\n    if (!throttleDragRotate || !dragInfo) {\n      return;\n    }\n\n    var dist = dragInfo.dist;\n\n    if (!dist[0] && !dist[1]) {\n      return;\n    }\n\n    var width = getDistSize(dist);\n    var rad = getRad(dist, [0, 0]);\n    return React.createElement(\"div\", {\n      className: prefix(\"line\", \"horizontal\", \"dragline\", \"dashed\"),\n      key: \"dragRotateGuideline\",\n      style: {\n        width: width + \"px\",\n        transform: \"translate(\" + beforeOrigin[0] + \"px, \" + beforeOrigin[1] + \"px) rotate(\" + rad + \"rad)\"\n      }\n    });\n  },\n  dragStart: function (moveable, e) {\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentDragger = e.parentDragger;\n    var state = moveable.state;\n    var targetTransform = state.targetTransform,\n        target = state.target,\n        dragger = state.dragger;\n\n    if (dragger) {\n      return false;\n    }\n\n    state.dragger = parentDragger || moveable.targetDragger;\n    var style = window.getComputedStyle(target);\n    datas.datas = {};\n    datas.left = parseFloat(style.left || \"\") || 0;\n    datas.top = parseFloat(style.top || \"\") || 0;\n    datas.bottom = parseFloat(style.bottom || \"\") || 0;\n    datas.right = parseFloat(style.right || \"\") || 0;\n    datas.transform = targetTransform;\n    datas.startTranslate = [0, 0];\n    setDragStart(moveable, {\n      datas: datas\n    });\n    datas.prevDist = [0, 0];\n    datas.prevBeforeDist = [0, 0];\n    datas.isDrag = false;\n    startCheckSnapDrag(moveable, datas);\n    var params = fillParams(moveable, e, {\n      set: function (translate) {\n        datas.startTranslate = translate;\n      }\n    });\n    var result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n    if (result !== false) {\n      datas.isDrag = true;\n      moveable.state.dragInfo = {\n        startRect: moveable.getRect(),\n        dist: [0, 0]\n      };\n    } else {\n      state.dragger = null;\n      datas.isPinch = false;\n    }\n\n    return datas.isDrag ? params : false;\n  },\n  drag: function (moveable, e) {\n    var datas = e.datas,\n        parentEvent = e.parentEvent,\n        parentFlag = e.parentFlag;\n    var distX = e.distX,\n        distY = e.distY;\n    var isPinch = datas.isPinch,\n        isDrag = datas.isDrag,\n        prevDist = datas.prevDist,\n        prevBeforeDist = datas.prevBeforeDist,\n        transform = datas.transform,\n        startTranslate = datas.startTranslate;\n\n    if (!isDrag) {\n      return;\n    }\n\n    var props = moveable.props;\n    var parentMoveable = props.parentMoveable;\n    var throttleDrag = parentEvent ? 0 : props.throttleDrag || 0;\n    var throttleDragRotate = parentEvent ? 0 : props.throttleDragRotate || 0;\n    var isSnap = false;\n    var dragRotateRad = 0;\n\n    if (throttleDragRotate > 0 && (distX || distY)) {\n      var deg = throttle(getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate);\n      var r = getDistSize([distX, distY]);\n      dragRotateRad = deg * Math.PI / 180;\n      distX = r * Math.cos(dragRotateRad);\n      distY = r * Math.sin(dragRotateRad);\n    }\n\n    if (!isPinch && !parentEvent && !parentFlag && (distX || distY)) {\n      var _a = checkSnapDrag(moveable, distX, distY, throttleDragRotate, datas),\n          verticalInfo = _a[0],\n          horizontalInfo = _a[1];\n\n      var isVerticalSnap = verticalInfo.isSnap,\n          isVerticalBound = verticalInfo.isBound,\n          verticalOffset = verticalInfo.offset;\n      var isHorizontalSnap = horizontalInfo.isSnap,\n          isHorizontalBound = horizontalInfo.isBound,\n          horizontalOffset = horizontalInfo.offset;\n      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n      distX += verticalOffset;\n      distY += horizontalOffset;\n    }\n\n    datas.passDistX = distX;\n    datas.passDistY = distY;\n    var beforeTranslate = plus(getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, true), startTranslate);\n    var translate = plus(getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, false), startTranslate);\n\n    if (!throttleDragRotate && !isSnap) {\n      throttleArray(translate, throttleDrag);\n      throttleArray(beforeTranslate, throttleDrag);\n    }\n\n    var beforeDist = minus(beforeTranslate, startTranslate);\n    var dist = minus(translate, startTranslate);\n    var delta = minus(dist, prevDist);\n    var beforeDelta = minus(beforeDist, prevBeforeDist);\n    datas.prevDist = dist;\n    datas.prevBeforeDist = beforeDist;\n    var left = datas.left + beforeDist[0];\n    var top = datas.top + beforeDist[1];\n    var right = datas.right - beforeDist[0];\n    var bottom = datas.bottom - beforeDist[1];\n    var nextTransform = transform + \" translate(\" + dist[0] + \"px, \" + dist[1] + \"px)\";\n    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n\n    if (!parentEvent && !parentMoveable && delta.every(function (num) {\n      return !num;\n    }) && beforeDelta.some(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      transform: nextTransform,\n      dist: dist,\n      delta: delta,\n      translate: translate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeTranslate: beforeTranslate,\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      isPinch: isPinch\n    });\n    !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n    return params;\n  },\n  dragEnd: function (moveable, e) {\n    var parentEvent = e.parentEvent,\n        datas = e.datas,\n        isDrag = e.isDrag;\n    moveable.state.dragger = null;\n    moveable.state.dragInfo = null;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    datas.isDrag = false;\n    !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams(moveable, e, {\n      isDrag: isDrag\n    }));\n    return isDrag;\n  },\n  dragGroupStart: function (moveable, e) {\n    var datas = e.datas;\n    var params = this.dragStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var events = triggerChildAble(moveable, this, \"dragStart\", datas, e);\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n    datas.isDrag = result !== false;\n    return datas.isDrag ? params : false;\n  },\n  dragGroup: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    var params = this.drag(moveable, e);\n    var _a = e.datas,\n        passDistX = _a.passDistX,\n        passDistY = _a.passDistY;\n    var events = triggerChildAble(moveable, this, \"drag\", datas, __assign({}, e, {\n      distX: passDistX,\n      distY: passDistY\n    }));\n\n    if (!params) {\n      return;\n    }\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onDragGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isDrag) {\n      return;\n    }\n\n    this.dragEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragEnd\", datas, e);\n    triggerEvent(moveable, \"onDragGroupEnd\", fillParams(moveable, e, {\n      targets: moveable.props.targets,\n      isDrag: isDrag\n    }));\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Draggable#request\n   * @param {object} [e] - the draggable's request parameter\n   * @param {number} [e.x] - x position\n   * @param {number} [e.y] - y position\n   * @param {number} [e.deltaX] - X number to move\n   * @param {number} [e.deltaY] - Y number to move\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n   *\n   * // requestStart\n   * const requester = moveable.request(\"draggable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * // Use Absolute Value\n   * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n   * moveable.request(\"draggable\", { x: 220, y: 100, isInstant: true });\n   * moveable.request(\"draggable\", { x: 240, y: 100, isInstant: true });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function (moveable) {\n    var datas = {};\n    var rect = moveable.getRect();\n    var distX = 0;\n    var distY = 0;\n    return {\n      isControl: false,\n      requestStart: function (e) {\n        return {\n          datas: datas\n        };\n      },\n      request: function (e) {\n        if (\"x\" in e) {\n          distX = e.x - rect.left;\n        } else if (\"deltaX\" in e) {\n          distX += e.deltaX;\n        }\n\n        if (\"y\" in e) {\n          distY = e.y - rect.top;\n        } else if (\"deltaY\" in e) {\n          distY += e.deltaY;\n        }\n\n        return {\n          datas: datas,\n          distX: distX,\n          distY: distY\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  },\n  unset: function (moveable) {\n    moveable.state.dragInfo = null;\n  }\n};\n\nfunction setCustomDrag(state, delta, inputEvent, isConvert) {\n  if (isConvert === void 0) {\n    isConvert = true;\n  }\n\n  var result = state.dragger.move(delta, inputEvent);\n  return __assign({}, isConvert ? convertDragDist(state, result) : result, {\n    parentEvent: true\n  });\n}\n\nvar CustomDragger = /*#__PURE__*/function () {\n  function CustomDragger() {\n    this.prevX = 0;\n    this.prevY = 0;\n    this.startX = 0;\n    this.startY = 0;\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {};\n  }\n\n  var __proto = CustomDragger.prototype;\n\n  __proto.dragStart = function (client, inputEvent) {\n    this.isDrag = false;\n    this.isFlag = false;\n    this.datas = {};\n    return this.move(client, inputEvent);\n  };\n\n  __proto.drag = function (client, inputEvent) {\n    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);\n  };\n\n  __proto.move = function (delta, inputEvent) {\n    var clientX;\n    var clientY;\n\n    if (!this.isFlag) {\n      this.prevX = delta[0];\n      this.prevY = delta[1];\n      this.startX = delta[0];\n      this.startY = delta[1];\n      clientX = delta[0];\n      clientY = delta[1];\n      this.isFlag = true;\n    } else {\n      clientX = this.prevX + delta[0];\n      clientY = this.prevY + delta[1];\n      this.isDrag = true;\n    }\n\n    this.prevX = clientX;\n    this.prevY = clientY;\n    return {\n      clientX: clientX,\n      clientY: clientY,\n      inputEvent: inputEvent,\n      isDrag: this.isDrag,\n      distX: clientX - this.startX,\n      distY: clientY - this.startY,\n      deltaX: delta[0],\n      deltaY: delta[1],\n      datas: this.datas,\n      parentEvent: true,\n      parentDragger: this\n    };\n  };\n\n  return CustomDragger;\n}();\n/**\n * @namespace Rotatable\n * @memberof Moveable\n */\n\n\nfunction setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {\n  var n = moveable.state.is3d ? 4 : 3;\n  var nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n  datas.startAbsoluteOrigin = startAbsoluteOrigin;\n  datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n  datas.prevSnapDeg = datas.prevDeg;\n  datas.startDeg = datas.prevDeg;\n  datas.loop = 0;\n}\n\nfunction getParentDeg(moveable, moveableRect, datas, parentDist, direction, startRotate) {\n  var prevDeg = datas.prevDeg;\n  var absoluteDeg = startRotate + parentDist;\n  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);\n  datas.prevDeg = dist;\n  var delta = direction * (dist - prevDeg);\n  return [delta, dist, absoluteDeg];\n}\n\nfunction getDeg(moveable, moveableRect, datas, deg, direction, startRotate, throttleRotate, isSnap) {\n  var prevDeg = datas.prevDeg,\n      prevSnapDeg = datas.prevSnapDeg,\n      startDeg = datas.startDeg,\n      prevLoop = datas.loop;\n\n  if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n    // 360 => 0\n    ++datas.loop;\n  } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n    // 0 => 360\n    --datas.loop;\n  }\n\n  var loop = datas.loop;\n  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n  var absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n  absoluteDeg = throttle(absoluteDeg, throttleRotate);\n  var dist = direction * (absoluteDeg - startRotate);\n\n  if (isSnap) {\n    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n    absoluteDeg = dist / direction + startRotate;\n  }\n\n  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n  var delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n  return [delta, dist, absoluteDeg];\n}\n\nfunction getRotateInfo(moveable, moveableRect, datas, direction, clientX, clientY, startRotate, throttleRotate) {\n  return getDeg(moveable, moveableRect, datas, getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction, startRotate, throttleRotate, true);\n}\n\nfunction getPositions(rotationPosition, pos1, pos2, pos3, pos4) {\n  if (rotationPosition === \"left\") {\n    return [pos3, pos1];\n  } else if (rotationPosition === \"right\") {\n    return [pos2, pos4];\n  } else if (rotationPosition === \"bottom\") {\n    return [pos4, pos3];\n  }\n\n  return [pos1, pos2];\n}\n\nfunction dragControlCondition(e) {\n  if (e.isRequest) {\n    return true;\n  }\n\n  return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nvar Rotatable = {\n  name: \"rotatable\",\n  canPinch: true,\n  props: {\n    rotatable: Boolean,\n    rotationPosition: String,\n    throttleRotate: Number\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        rotatable = _a.rotatable,\n        rotationPosition = _a.rotationPosition;\n\n    if (!rotatable) {\n      return null;\n    }\n\n    var _b = moveable.state,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4,\n        direction = _b.direction;\n    var poses = getPositions(rotationPosition, pos1, pos2, pos3, pos4);\n    var rotationRad = getRotationRad(poses, direction);\n    return React.createElement(\"div\", {\n      key: \"rotation\",\n      className: prefix(\"line rotation-line\"),\n      style: {\n        // tslint:disable-next-line: max-line-length\n        transform: \"translate(-50%) translate(\" + (poses[0][0] + poses[1][0]) / 2 + \"px, \" + (poses[0][1] + poses[1][1]) / 2 + \"px) rotate(\" + rotationRad + \"rad)\"\n      }\n    }, React.createElement(\"div\", {\n      className: prefix(\"control\", \"rotation\")\n    }));\n  },\n  dragControlCondition: dragControlCondition,\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        pinchFlag = e.pinchFlag,\n        isRequest = e.isRequest;\n    var _a = moveable.state,\n        target = _a.target,\n        left = _a.left,\n        top = _a.top,\n        origin = _a.origin,\n        beforeOrigin = _a.beforeOrigin,\n        direction = _a.direction,\n        beforeDirection = _a.beforeDirection,\n        targetTransform = _a.targetTransform;\n\n    if (!isRequest && !target) {\n      return false;\n    }\n\n    var rect = moveable.getRect();\n    datas.rect = rect;\n    datas.transform = targetTransform;\n    datas.left = left;\n    datas.top = top;\n\n    if (isRequest || pinchFlag || parentFlag) {\n      var externalRotate = parentRotate || 0;\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n      datas.afterInfo = {\n        origin: rect.origin,\n        prevDeg: externalRotate,\n        startDeg: externalRotate,\n        prevSnapDeg: externalRotate,\n        loop: 0\n      };\n    } else {\n      datas.beforeInfo = {\n        origin: rect.beforeOrigin\n      };\n      datas.afterInfo = {\n        origin: rect.origin\n      };\n      var controlRect = getClientRect(moveable.controlBox.getElement());\n      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n    }\n\n    datas.direction = direction;\n    datas.beforeDirection = beforeDirection;\n    datas.startRotate = 0;\n    datas.datas = {};\n    var params = fillParams(moveable, e, {\n      set: function (rotatation) {\n        datas.startRotate = rotatation;\n      }\n    });\n    var result = triggerEvent(moveable, \"onRotateStart\", params);\n    datas.isRotate = result !== false;\n    moveable.state.snapRenderInfo = {};\n    return datas.isRotate ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var _a, _b, _c, _d, _e, _f;\n\n    var datas = e.datas,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        parentRotate = e.parentRotate,\n        parentFlag = e.parentFlag,\n        pinchFlag = e.pinchFlag;\n    var direction = datas.direction,\n        beforeDirection = datas.beforeDirection,\n        beforeInfo = datas.beforeInfo,\n        afterInfo = datas.afterInfo,\n        isRotate = datas.isRotate,\n        startRotate = datas.startRotate,\n        rect = datas.rect;\n\n    if (!isRotate) {\n      return;\n    }\n\n    var _g = moveable.props,\n        _h = _g.throttleRotate,\n        throttleRotate = _h === void 0 ? 0 : _h,\n        parentMoveable = _g.parentMoveable;\n    var delta;\n    var dist;\n    var rotate;\n    var beforeDelta;\n    var beforeDist;\n    var beforeRotate;\n\n    if (\"parentDist\" in e) {\n      var parentDist = e.parentDist;\n      _a = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate), delta = _a[0], dist = _a[1], rotate = _a[2];\n      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];\n    } else if (pinchFlag || parentFlag) {\n      _c = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate), delta = _c[0], dist = _c[1], rotate = _c[2];\n      _d = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate), beforeDelta = _d[0], beforeDist = _d[1], beforeRotate = _d[2];\n    } else {\n      _e = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate), delta = _e[0], dist = _e[1], rotate = _e[2];\n      _f = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate), beforeDelta = _f[0], beforeDist = _f[1], beforeRotate = _f[2];\n    }\n\n    if (!delta && !beforeDelta && !parentMoveable) {\n      return;\n    }\n\n    var params = fillParams(moveable, e, {\n      delta: delta,\n      dist: dist,\n      rotate: rotate,\n      beforeDist: beforeDist,\n      beforeDelta: beforeDelta,\n      beforeRotate: beforeRotate,\n      transform: datas.transform + \" rotate(\" + dist + \"deg)\",\n      isPinch: !!pinchFlag\n    });\n    triggerEvent(moveable, \"onRotate\", params);\n    return params;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isRotate) {\n      return false;\n    }\n\n    datas.isRotate = false;\n    triggerEvent(moveable, \"onRotateEnd\", fillParams(moveable, e, {\n      isDrag: isDrag\n    }));\n    return isDrag;\n  },\n  dragGroupControlCondition: dragControlCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent;\n    var _a = moveable.state,\n        parentLeft = _a.left,\n        parentTop = _a.top,\n        parentBeforeOrigin = _a.beforeOrigin;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    params.set(moveable.rotation);\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, __assign({}, e, {\n      parentRotate: 0\n    }), function (child, childDatas, eventParams) {\n      var _a = child.state,\n          left = _a.left,\n          top = _a.top,\n          beforeOrigin = _a.beforeOrigin;\n      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));\n      childDatas.prevClient = childClient;\n      eventParams.dragStart = Draggable.dragStart(child, new CustomDragger().dragStart(childClient, inputEvent));\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n    datas.isRotate = result !== false;\n    return datas.isRotate ? params : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var parentRotate = params.beforeDist;\n    var deg = params.beforeDelta;\n    var rad = deg / 180 * Math.PI;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, __assign({}, e, {\n      parentRotate: parentRotate\n    }), function (child, childDatas, result, i) {\n      var _a = childDatas.prevClient,\n          prevX = _a[0],\n          prevY = _a[1];\n\n      var _b = rotate([prevX, prevY], rad),\n          clientX = _b[0],\n          clientY = _b[1];\n\n      var delta = [clientX - prevX, clientY - prevY];\n      childDatas.prevClient = [clientX, clientY];\n      var dragResult = Draggable.drag(child, setCustomDrag(child.state, delta, inputEvent, false));\n      result.drag = dragResult;\n    });\n    moveable.rotation = params.beforeRotate;\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events,\n      set: function (rotation) {\n        moveable.rotation = rotation;\n      }\n    }, params);\n\n    triggerEvent(moveable, \"onRotateGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isRotate) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillParams(moveable, e, {\n      targets: moveable.props.targets,\n      isDrag: isDrag\n    });\n    triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Rotatable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.deltaRotate=0] -  delta number of rotation\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"rotatable\", { deltaRotate: 10, isInstant: true });\n   *\n   * // requestStart\n   * const requester = moveable.request(\"rotatable\");\n   *\n   * // request\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   * requester.request({ deltaRotate: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function () {\n    var datas = {};\n    var distRotate = 0;\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas\n        };\n      },\n      request: function (e) {\n        distRotate += e.deltaRotate;\n        return {\n          datas: datas,\n          parentDist: distRotate\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n\nfunction renderControls(moveable, defaultDirections, React) {\n  var _a = moveable.state,\n      pos1 = _a.pos1,\n      pos2 = _a.pos2,\n      pos3 = _a.pos3,\n      pos4 = _a.pos4,\n      rotation = _a.rotation;\n  var _b = moveable.props.renderDirections,\n      directions = _b === void 0 ? defaultDirections : _b;\n  var poses = [pos1, pos2, pos3, pos4];\n  var directionMap = {};\n  directions.forEach(function (direction) {\n    directionMap[direction] = true;\n  });\n  return directions.map(function (direction) {\n    var indexes = DIRECTION_INDEXES[direction];\n\n    if (!indexes || !directionMap[direction]) {\n      return null;\n    }\n\n    var directionRotation = (throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[direction]) % 180;\n    return React.createElement(\"div\", {\n      className: prefix(\"control\", \"direction\", direction),\n      \"data-rotation\": directionRotation,\n      \"data-direction\": direction,\n      key: \"direction-\" + direction,\n      style: getControlTransform.apply(void 0, [rotation].concat(indexes.map(function (index) {\n        return poses[index];\n      })))\n    });\n  });\n}\n\nfunction renderAllDirections(moveable, React) {\n  return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"], React);\n}\n\nfunction renderDiagonalDirections(moveable, React) {\n  return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n/**\n * @namespace Resizable\n * @memberof Moveable\n */\n\n\nvar Resizable = {\n  name: \"resizable\",\n  ableGroup: \"size\",\n  updateRect: true,\n  canPinch: true,\n  props: {\n    resizable: Boolean,\n    throttleResize: Number,\n    renderDirections: Array,\n    baseDirection: Array,\n    keepRatio: Boolean\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        edge = _a.edge;\n\n    if (resizable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function (moveable, e) {\n    var _a;\n\n    var inputEvent = e.inputEvent,\n        pinchFlag = e.pinchFlag,\n        parentDirection = e.parentDirection,\n        datas = e.datas;\n    var direction = parentDirection || (pinchFlag ? [1, 1] : getDirection(inputEvent.target));\n    var _b = moveable.state,\n        target = _b.target,\n        width = _b.width,\n        height = _b.height;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    !pinchFlag && setDragStart(moveable, {\n      datas: datas\n    });\n    datas.datas = {};\n    datas.direction = direction;\n    datas.startOffsetWidth = width;\n    datas.startOffsetHeight = height;\n    datas.prevWidth = 0;\n    datas.prevHeight = 0;\n    _a = getCSSSize(target), datas.startWidth = _a[0], datas.startHeight = _a[1];\n    datas.transformOrigin = moveable.props.transformOrigin;\n    datas.startDirection = getStartDirection(moveable, direction);\n    datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n    datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n    var params = fillParams(moveable, e, {\n      direction: direction,\n      set: function (_a) {\n        var startWidth = _a[0],\n            startHeight = _a[1];\n        datas.startWidth = startWidth;\n        datas.startHeight = startHeight;\n      },\n      setOrigin: function (origin) {\n        datas.transformOrigin = origin;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))\n    });\n    var result = triggerEvent(moveable, \"onResizeStart\", params);\n\n    if (result !== false) {\n      datas.isResize = true;\n      moveable.state.snapRenderInfo = {\n        direction: direction\n      };\n    }\n\n    return datas.isResize ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentFlag = e.parentFlag,\n        pinchFlag = e.pinchFlag,\n        parentDistance = e.parentDistance,\n        parentScale = e.parentScale,\n        inputEvent = e.inputEvent,\n        parentKeepRatio = e.parentKeepRatio,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist;\n    var direction = datas.direction,\n        isResize = datas.isResize,\n        transformOrigin = datas.transformOrigin;\n\n    if (!isResize) {\n      return;\n    }\n\n    var startWidth = datas.startWidth,\n        startHeight = datas.startHeight,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight;\n    var _a = moveable.props,\n        _b = _a.throttleResize,\n        throttleResize = _b === void 0 ? 0 : _b,\n        parentMoveable = _a.parentMoveable;\n    var sizeDirection = direction;\n\n    if (!direction[0] && !direction[1]) {\n      sizeDirection = [1, 1];\n    }\n\n    var keepRatio = moveable.props.keepRatio || parentKeepRatio;\n    var isWidth = sizeDirection[0] || !sizeDirection[1];\n    var ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n    var startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n    var fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n    var distWidth = 0;\n    var distHeight = 0;\n\n    if (parentDist) {\n      distWidth = parentDist[0];\n      distHeight = parentDist[1];\n    } else if (parentScale) {\n      distWidth = (parentScale[0] - 1) * startOffsetWidth;\n      distHeight = (parentScale[1] - 1) * startOffsetHeight;\n    } else if (pinchFlag) {\n      if (parentDistance) {\n        distWidth = parentDistance;\n        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n      }\n    } else {\n      var dist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      distWidth = sizeDirection[0] * dist[0];\n      distHeight = sizeDirection[1] * dist[1];\n\n      if (keepRatio && startOffsetWidth && startOffsetHeight) {\n        var rad = getRad([0, 0], dist);\n        var standardRad = getRad([0, 0], sizeDirection);\n        var ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n        var size = getDistSize([distWidth, distHeight]);\n        var signSize = Math.cos(rad - standardRad) * size;\n\n        if (!sizeDirection[0]) {\n          // top, bottom\n          distHeight = signSize;\n          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n        } else if (!sizeDirection[1]) {\n          // left, right\n          distWidth = signSize;\n          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n        } else {\n          // two-way\n          distWidth = Math.cos(ratioRad) * signSize;\n          distHeight = Math.sin(ratioRad) * signSize;\n        }\n      }\n    }\n\n    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n    if (keepRatio && startOffsetWidth && startOffsetHeight) {\n      // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n      nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n    }\n\n    var snapDist = [0, 0];\n\n    if (!pinchFlag) {\n      snapDist = checkSnapSize(moveable, nextWidth, nextHeight, direction, datas.fixedOriginalPosition, parentDist, datas);\n    }\n\n    if (parentDist) {\n      !parentDist[0] && (snapDist[0] = 0);\n      !parentDist[1] && (snapDist[1] = 0);\n    }\n\n    if (keepRatio) {\n      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          nextWidth = throttle(nextWidth, throttleResize);\n        } else {\n          nextHeight = throttle(nextHeight, throttleResize);\n        }\n      }\n\n      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        nextWidth += snapDist[0];\n        nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        nextHeight += snapDist[1];\n        nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n      }\n    } else {\n      nextWidth += snapDist[0];\n      nextHeight += snapDist[1];\n\n      if (!snapDist[0]) {\n        nextWidth = throttle(nextWidth, throttleResize);\n      }\n\n      if (!snapDist[1]) {\n        nextHeight = throttle(nextHeight, throttleResize);\n      }\n    }\n\n    nextWidth = Math.round(nextWidth);\n    nextHeight = Math.round(nextHeight);\n    distWidth = nextWidth - startOffsetWidth;\n    distHeight = nextHeight - startOffsetHeight;\n    var delta = [distWidth - prevWidth, distHeight - prevHeight];\n    datas.prevWidth = distWidth;\n    datas.prevHeight = distHeight;\n\n    if (!parentMoveable && delta.every(function (num) {\n      return !num;\n    })) {\n      return;\n    }\n\n    var inverseDelta = !parentFlag && pinchFlag ? [0, 0] : getResizeDist(moveable, nextWidth, nextHeight, startDirection, fixedPosition, transformOrigin);\n    var params = fillParams(moveable, e, {\n      width: startWidth + distWidth,\n      height: startHeight + distHeight,\n      offsetWidth: nextWidth,\n      offsetHeight: nextHeight,\n      direction: direction,\n      dist: [distWidth, distHeight],\n      delta: delta,\n      isPinch: !!pinchFlag,\n      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent, false))\n    });\n    triggerEvent(moveable, \"onResize\", params);\n    return params;\n  },\n  dragControlAfter: function (moveable, e) {\n    var datas = e.datas;\n    var isResize = datas.isResize,\n        startOffsetWidth = datas.startOffsetWidth,\n        startOffsetHeight = datas.startOffsetHeight,\n        prevWidth = datas.prevWidth,\n        prevHeight = datas.prevHeight;\n\n    if (!isResize) {\n      return;\n    }\n\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height;\n    var errorWidth = width - (startOffsetWidth + prevWidth);\n    var errorHeight = height - (startOffsetHeight + prevHeight);\n    var isErrorWidth = Math.abs(errorWidth) > 3;\n    var isErrorHeight = Math.abs(errorHeight) > 3;\n\n    if (isErrorWidth) {\n      datas.startWidth += errorWidth;\n      datas.startOffsetWidth += errorWidth;\n      datas.prevWidth += errorWidth;\n    }\n\n    if (isErrorHeight) {\n      datas.startHeight += errorHeight;\n      datas.startOffsetHeight += errorHeight;\n      datas.prevHeight += errorHeight;\n    }\n\n    if (isErrorWidth || isErrorHeight) {\n      this.dragControl(moveable, e);\n      return true;\n    }\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isResize) {\n      return false;\n    }\n\n    datas.isResize = false;\n    var params = fillParams(moveable, e, {\n      isDrag: isDrag\n    });\n    triggerEvent(moveable, \"onResizeEnd\", params);\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var direction = params.direction;\n    var startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, function (child, childDatas) {\n      var pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n\n      var _a = caculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - startPos[0], pos[1] - startPos[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      childDatas.originalX = originalX;\n      childDatas.originalY = originalY;\n      return e;\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n    datas.isResize = result !== false;\n    return datas.isResize ? params : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var offsetWidth = params.offsetWidth,\n        offsetHeight = params.offsetHeight,\n        dist = params.dist;\n    var keepRatio = moveable.props.keepRatio;\n    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];\n    var fixedPosition = datas.fixedOriginalPosition;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, function (_, childDatas) {\n      var _a = caculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * parentScale[0], childDatas.originalY * parentScale[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return __assign({}, e, {\n        parentScale: parentScale,\n        dragClient: plus(fixedPosition, [clientX, clientY]),\n        parentKeepRatio: keepRatio\n      });\n    });\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onResizeGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isResize) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillParams(moveable, e, {\n      targets: moveable.props.targets,\n      isDrag: isDrag\n    });\n    triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Resizable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to resize\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * // Use Relative Value\n   * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n   *\n   * // requestStart\n   * const requester = moveable.request(\"resizable\");\n   *\n   * // request\n   * // Use Relative Value\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // Use Absolute Value\n   * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n   * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100, isInstant: true });\n   * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100, isInstant: true });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function (moveable) {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    var rect = moveable.getRect();\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function (e) {\n        if (\"offsetWidth\" in e) {\n          distWidth = e.offsetWidth - rect.offsetWidth;\n        } else if (\"deltaWidth\" in e) {\n          distWidth += e.deltaWidth;\n        }\n\n        if (\"offsetHeight\" in e) {\n          distHeight = e.offsetHeight - rect.offsetHeight;\n        } else if (\"deltaHeight\" in e) {\n          distHeight += e.deltaHeight;\n        }\n\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n/**\n * @namespace Scalable\n * @memberof Moveable\n */\n\nvar Scalable = {\n  name: \"scalable\",\n  ableGroup: \"size\",\n  canPinch: true,\n  props: {\n    scalable: Boolean,\n    throttleScale: Number,\n    renderDirections: String,\n    keepRatio: Boolean\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        edge = _a.edge;\n\n    if (!resizable && scalable) {\n      if (edge) {\n        return renderDiagonalDirections(moveable, React);\n      }\n\n      return renderAllDirections(moveable, React);\n    }\n  },\n  dragControlCondition: directionCondition,\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        pinchFlag = e.pinchFlag,\n        inputEvent = e.inputEvent,\n        parentDirection = e.parentDirection;\n    var direction = parentDirection || (pinchFlag ? [1, 1] : getDirection(inputEvent.target));\n    var _a = moveable.state,\n        width = _a.width,\n        height = _a.height,\n        targetTransform = _a.targetTransform,\n        target = _a.target;\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    if (!pinchFlag) {\n      setDragStart(moveable, {\n        datas: datas\n      });\n    }\n\n    datas.datas = {};\n    datas.transform = targetTransform;\n    datas.prevDist = [1, 1];\n    datas.direction = direction;\n    datas.width = width;\n    datas.height = height;\n    datas.startScale = [1, 1];\n    datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n    var params = fillParams(moveable, e, {\n      direction: direction,\n      set: function (scale) {\n        datas.startScale = scale;\n      },\n      dragStart: Draggable.dragStart(moveable, new CustomDragger().dragStart([0, 0], inputEvent))\n    });\n    var result = triggerEvent(moveable, \"onScaleStart\", params);\n\n    if (result !== false) {\n      datas.isScale = true;\n      moveable.state.snapRenderInfo = {\n        direction: direction\n      };\n    }\n\n    return datas.isScale ? params : false;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas,\n        distX = e.distX,\n        distY = e.distY,\n        parentScale = e.parentScale,\n        parentDistance = e.parentDistance,\n        parentKeepRatio = e.parentKeepRatio,\n        parentFlag = e.parentFlag,\n        pinchFlag = e.pinchFlag,\n        inputEvent = e.inputEvent,\n        dragClient = e.dragClient,\n        parentDist = e.parentDist;\n    var prevDist = datas.prevDist,\n        direction = datas.direction,\n        width = datas.width,\n        height = datas.height,\n        transform = datas.transform,\n        isScale = datas.isScale,\n        startScale = datas.startScale;\n\n    if (!isScale) {\n      return false;\n    }\n\n    var _a = moveable.props,\n        throttleScale = _a.throttleScale,\n        parentMoveable = _a.parentMoveable;\n    var keepRatio = moveable.props.keepRatio || parentKeepRatio;\n    var state = moveable.state;\n    var isWidth = direction[0] || !direction[1];\n    var startWidth = width * startScale[0];\n    var startHeight = height * startScale[1];\n    var ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (parentScale) {\n      scaleX = parentScale[0];\n      scaleY = parentScale[1];\n    } else if (pinchFlag) {\n      if (parentDistance) {\n        scaleX = (width + parentDistance) / width;\n        scaleY = (height + parentDistance * height / width) / height;\n      }\n    } else {\n      var dist = getDragDist({\n        datas: datas,\n        distX: distX,\n        distY: distY\n      });\n      var distWidth = direction[0] * dist[0];\n      var distHeight = direction[1] * dist[1];\n\n      if (keepRatio && width && height) {\n        var rad = getRad([0, 0], dist);\n        var standardRad = getRad([0, 0], direction);\n        var ratioRad = getRad([0, 0], [startWidth, startHeight]);\n        var size = getDistSize([distWidth, distHeight]);\n        var signSize = Math.cos(rad - standardRad) * size;\n\n        if (!direction[0]) {\n          // top, bottom\n          distHeight = signSize;\n          distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n        } else if (!direction[1]) {\n          // left, right\n          distWidth = signSize;\n          distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n        } else {\n          // two-way\n          distWidth = Math.cos(ratioRad) * signSize;\n          distHeight = Math.sin(ratioRad) * signSize;\n        }\n      }\n\n      scaleX = (width + distWidth) / width;\n      scaleY = (height + distHeight) / height;\n    }\n\n    scaleX = direction[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n    scaleY = direction[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n    if (scaleX === 0) {\n      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (scaleY === 0) {\n      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n    var scale = [scaleX, scaleY];\n    var snapDirection = direction;\n\n    if (moveable.props.groupable) {\n      snapDirection = [(nowDist[0] >= 0 ? 1 : -1) * direction[0], (nowDist[1] >= 0 ? 1 : -1) * direction[1]];\n      var snapRenderInfo = state.snapRenderInfo || {};\n      var stateDirection = snapRenderInfo.direction;\n\n      if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n        state.snapRenderInfo = {\n          direction: direction\n        };\n      }\n    }\n\n    var snapDist = [0, 0];\n\n    if (!pinchFlag) {\n      snapDist = checkSnapScale(moveable, nowDist, direction, snapDirection, datas.fixedPosition, parentDist, datas);\n    }\n\n    if (keepRatio) {\n      if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n          snapDist[1] = 0;\n        } else {\n          snapDist[0] = 0;\n        }\n      }\n\n      var isNoSnap = !snapDist[0] && !snapDist[1];\n\n      if (isNoSnap) {\n        if (isWidth) {\n          nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];\n        } else {\n          nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];\n        }\n      }\n\n      if (direction[0] && !direction[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {\n        nowDist[0] += snapDist[0];\n        var snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n        nowDist[1] = snapHeight / height / startScale[1];\n      } else if (!direction[0] && direction[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {\n        nowDist[1] += snapDist[1];\n        var snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n        nowDist[0] = snapWidth / width / startScale[0];\n      }\n    } else {\n      nowDist[0] += snapDist[0];\n      nowDist[1] += snapDist[1];\n\n      if (!snapDist[0]) {\n        nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale) / startScale[0];\n      }\n\n      if (!snapDist[1]) {\n        nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale) / startScale[1];\n      }\n    }\n\n    if (nowDist[0] === 0) {\n      nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    if (nowDist[1] === 0) {\n      nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n    }\n\n    var delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n    scale = multiply2(nowDist, startScale);\n    datas.prevDist = nowDist;\n\n    if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {\n      return false;\n    }\n\n    var inverseDelta = !parentFlag && pinchFlag ? [0, 0] : getScaleDist(moveable, delta, direction, dragClient);\n    var params = fillParams(moveable, e, {\n      scale: scale,\n      direction: direction,\n      dist: nowDist,\n      delta: delta,\n      transform: transform + \" scale(\" + scaleX + \", \" + scaleY + \")\",\n      isPinch: !!pinchFlag,\n      drag: Draggable.drag(moveable, setCustomDrag(moveable.state, inverseDelta, inputEvent, false))\n    });\n    triggerEvent(moveable, \"onScale\", params);\n    return params;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isScale) {\n      return false;\n    }\n\n    datas.isScale = false;\n    triggerEvent(moveable, \"onScaleEnd\", fillParams(moveable, e, {\n      isDrag: isDrag\n    }));\n    return isDrag;\n  },\n  dragGroupControlCondition: directionCondition,\n  dragGroupControlStart: function (moveable, e) {\n    var datas = e.datas;\n    var params = this.dragControlStart(moveable, e);\n\n    if (!params) {\n      return false;\n    }\n\n    var direction = params.direction;\n    var startPos = getAbsoluteFixedPosition(moveable, direction);\n    datas.startPos = startPos;\n    var events = triggerChildAble(moveable, this, \"dragControlStart\", datas, function (child, childDatas) {\n      var pos = getAbsoluteFixedPosition(child, direction);\n\n      var _a = caculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - startPos[0], pos[1] - startPos[1], 1], 3),\n          originalX = _a[0],\n          originalY = _a[1];\n\n      childDatas.originalX = originalX;\n      childDatas.originalY = originalY;\n      return e;\n    });\n\n    var nextParams = __assign({}, params, {\n      targets: moveable.props.targets,\n      events: events\n    });\n\n    var result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n    datas.isScale = result !== false;\n    return datas.isScale ? nextParams : false;\n  },\n  dragGroupControl: function (moveable, e) {\n    var datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    var params = this.dragControl(moveable, e);\n\n    if (!params) {\n      return;\n    }\n\n    var keepRatio = moveable.props.keepRatio;\n    var scale = params.scale;\n    var startPos = datas.startPos;\n    var events = triggerChildAble(moveable, this, \"dragControl\", datas, function (_, childDatas) {\n      var _a = caculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [childDatas.originalX * scale[0], childDatas.originalY * scale[1], 1], 3),\n          clientX = _a[0],\n          clientY = _a[1];\n\n      return __assign({}, e, {\n        parentScale: scale,\n        parentKeepRatio: keepRatio,\n        dragClient: plus(startPos, [clientX, clientY])\n      });\n    });\n\n    var nextParams = __assign({\n      targets: moveable.props.targets,\n      events: events\n    }, params);\n\n    triggerEvent(moveable, \"onScaleGroup\", nextParams);\n    return nextParams;\n  },\n  dragGroupControlEnd: function (moveable, e) {\n    var isDrag = e.isDrag,\n        datas = e.datas;\n\n    if (!datas.isScale) {\n      return;\n    }\n\n    this.dragControlEnd(moveable, e);\n    triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n    var nextParams = fillParams(moveable, e, {\n      targets: moveable.props.targets,\n      isDrag: isDrag\n    });\n    triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n    return isDrag;\n  },\n\n  /**\n   * @method Moveable.Scalable#request\n   * @param {object} [e] - the Resizable's request parameter\n   * @param {number} [e.direction=[1, 1]] - Direction to scale\n   * @param {number} [e.deltaWidth] - delta number of width\n   * @param {number} [e.deltaHeight] - delta number of height\n   * @param {number} [e.isInstant] - Whether to execute the request instantly\n   * @return {Moveable.Requester} Moveable Requester\n   * @example\n    * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n   *\n   * // requestStart\n   * const requester = moveable.request(\"scalable\");\n   *\n   * // request\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n   *\n   * // requestEnd\n   * requester.requestEnd();\n   */\n  request: function () {\n    var datas = {};\n    var distWidth = 0;\n    var distHeight = 0;\n    return {\n      isControl: true,\n      requestStart: function (e) {\n        return {\n          datas: datas,\n          parentDirection: e.direction || [1, 1]\n        };\n      },\n      request: function (e) {\n        distWidth += e.deltaWidth;\n        distHeight += e.deltaHeight;\n        return {\n          datas: datas,\n          parentDist: [distWidth, distHeight]\n        };\n      },\n      requestEnd: function () {\n        return {\n          datas: datas,\n          isDrag: true\n        };\n      }\n    };\n  }\n};\n\nfunction getMiddleLinePos(pos1, pos2) {\n  return pos1.map(function (pos, i) {\n    return dot(pos, pos2[i], 1, 2);\n  });\n}\n\nfunction getTriangleRad(pos1, pos2, pos3) {\n  // pos1 Rad\n  var rad1 = getRad(pos1, pos2);\n  var rad2 = getRad(pos1, pos3);\n  var rad = rad2 - rad1;\n  return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1, poses2) {\n  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n  var pi = Math.PI;\n\n  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {\n    return false;\n  }\n\n  return true;\n}\n\nvar Warpable = {\n  name: \"warpable\",\n  ableGroup: \"size\",\n  props: {\n    warpable: Boolean,\n    renderDirections: Array\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        resizable = _a.resizable,\n        scalable = _a.scalable,\n        warpable = _a.warpable;\n\n    if (resizable || scalable || !warpable) {\n      return;\n    }\n\n    var _b = moveable.state,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4;\n    var linePosFrom1 = getMiddleLinePos(pos1, pos2);\n    var linePosFrom2 = getMiddleLinePos(pos2, pos1);\n    var linePosFrom3 = getMiddleLinePos(pos1, pos3);\n    var linePosFrom4 = getMiddleLinePos(pos3, pos1);\n    var linePosTo1 = getMiddleLinePos(pos3, pos4);\n    var linePosTo2 = getMiddleLinePos(pos4, pos3);\n    var linePosTo3 = getMiddleLinePos(pos2, pos4);\n    var linePosTo4 = getMiddleLinePos(pos4, pos2);\n    return [React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine1\",\n      style: getLineStyle(linePosFrom1, linePosTo1)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine2\",\n      style: getLineStyle(linePosFrom2, linePosTo2)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine3\",\n      style: getLineStyle(linePosFrom3, linePosTo3)\n    }), React.createElement(\"div\", {\n      className: prefix(\"line\"),\n      key: \"middeLine4\",\n      style: getLineStyle(linePosFrom4, linePosTo4)\n    })].concat(renderAllDirections(moveable, React));\n  },\n  dragControlCondition: function (e) {\n    if (e.isRequest) {\n      return false;\n    }\n\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n  },\n  dragControlStart: function (moveable, e) {\n    var datas = e.datas,\n        inputEvent = e.inputEvent;\n    var target = moveable.props.target;\n    var inputTarget = inputEvent.target;\n    var direction = getDirection(inputTarget);\n\n    if (!direction || !target) {\n      return false;\n    }\n\n    var state = moveable.state;\n    var transformOrigin = state.transformOrigin,\n        is3d = state.is3d,\n        targetTransform = state.targetTransform,\n        targetMatrix = state.targetMatrix,\n        width = state.width,\n        height = state.height,\n        left = state.left,\n        top = state.top;\n    datas.datas = {};\n    datas.targetTransform = targetTransform;\n    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n    datas.direction = direction;\n    datas.left = left;\n    datas.top = top;\n    setDragStart(moveable, {\n      datas: datas\n    });\n    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function (p, i) {\n      return minus(p, transformOrigin);\n    });\n    datas.nextPoses = datas.poses.map(function (_a) {\n      var x = _a[0],\n          y = _a[1];\n      return caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);\n    });\n    datas.startMatrix = createIdentityMatrix(4);\n    datas.prevMatrix = createIdentityMatrix(4);\n    datas.absolutePoses = getAbsolutePosesByState(state);\n    datas.posIndexes = getPosIndexesByDirection(direction);\n    state.snapRenderInfo = {\n      direction: direction\n    };\n    var params = fillParams(moveable, e, {\n      set: function (matrix) {\n        datas.startMatrix = matrix;\n      }\n    });\n    var result = triggerEvent(moveable, \"onWarpStart\", params);\n\n    if (result !== false) {\n      datas.isWarp = true;\n    }\n\n    return datas.isWarp;\n  },\n  dragControl: function (moveable, e) {\n    var datas = e.datas;\n    var distX = e.distX,\n        distY = e.distY;\n    var targetInverseMatrix = datas.targetInverseMatrix,\n        prevMatrix = datas.prevMatrix,\n        isWarp = datas.isWarp,\n        startMatrix = datas.startMatrix,\n        poses = datas.poses,\n        posIndexes = datas.posIndexes,\n        absolutePoses = datas.absolutePoses;\n\n    if (!isWarp) {\n      return false;\n    }\n\n    if (hasGuidelines(moveable, \"warpable\")) {\n      var selectedPoses = posIndexes.map(function (index) {\n        return absolutePoses[index];\n      });\n\n      if (selectedPoses.length > 1) {\n        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);\n      }\n\n      var _a = checkSnapBounds(moveable, selectedPoses.map(function (pos) {\n        return [pos[0] + distX, pos[1] + distY];\n      })),\n          horizontalSnapInfo = _a.horizontal,\n          verticalSnapInfo = _a.vertical;\n\n      distY -= horizontalSnapInfo.offset;\n      distX -= verticalSnapInfo.offset;\n    }\n\n    var dist = getDragDist({\n      datas: datas,\n      distX: distX,\n      distY: distY\n    }, true);\n    var nextPoses = datas.nextPoses.slice();\n    posIndexes.forEach(function (index) {\n      nextPoses[index] = plus(nextPoses[index], dist);\n    });\n\n    if (!NEARBY_POS.every(function (nearByPoses) {\n      return isValidPos(nearByPoses.map(function (i) {\n        return poses[i];\n      }), nearByPoses.map(function (i) {\n        return nextPoses[i];\n      }));\n    })) {\n      return false;\n    }\n\n    var h = createWarpMatrix(poses[0], poses[1], poses[2], poses[3], nextPoses[0], nextPoses[1], nextPoses[2], nextPoses[3]);\n\n    if (!h.length) {\n      return false;\n    }\n\n    var matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n    var transform = datas.targetTransform + \" matrix3d(\" + matrix.join(\",\") + \")\";\n    var delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n    datas.prevMatrix = matrix;\n    triggerEvent(moveable, \"onWarp\", fillParams(moveable, e, {\n      delta: delta,\n      matrix: multiplyCSS(startMatrix, matrix, 4),\n      multiply: multiplyCSS,\n      dist: matrix,\n      transform: transform\n    }));\n    return true;\n  },\n  dragControlEnd: function (moveable, e) {\n    var datas = e.datas,\n        isDrag = e.isDrag;\n\n    if (!datas.isWarp) {\n      return false;\n    }\n\n    datas.isWarp = false;\n    triggerEvent(moveable, \"onWarpEnd\", fillParams(moveable, e, {\n      isDrag: isDrag\n    }));\n    return isDrag;\n  }\n};\nvar AREA = prefix(\"area\");\nvar AREA_PIECES = prefix(\"area-pieces\");\nvar AREA_PIECE = prefix(\"area-piece\");\nvar AVOID = prefix(\"avoid\");\n\nfunction restoreStyle(moveable) {\n  var el = moveable.areaElement;\n  var _a = moveable.state,\n      width = _a.width,\n      height = _a.height;\n  removeClass(el, AVOID);\n  el.style.cssText += \"left: 0px; top: 0px; width: \" + width + \"px; height: \" + height + \"px\";\n}\n\nfunction renderPieces(React) {\n  return React.createElement(\"div\", {\n    key: \"area_pieces\",\n    className: AREA_PIECES\n  }, React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }), React.createElement(\"div\", {\n    className: AREA_PIECE\n  }));\n}\n\nvar DragArea = {\n  name: \"dragArea\",\n  props: {\n    dragArea: Boolean\n  },\n  render: function (moveable, React) {\n    var _a = moveable.props,\n        target = _a.target,\n        dragArea = _a.dragArea,\n        groupable = _a.groupable;\n    var _b = moveable.state,\n        width = _b.width,\n        height = _b.height,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4;\n\n    if (groupable) {\n      return [React.createElement(\"div\", {\n        key: \"area\",\n        ref: ref(moveable, \"areaElement\"),\n        className: AREA\n      }), renderPieces(React)];\n    }\n\n    if (!target || !dragArea) {\n      return [];\n    }\n\n    var h = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], pos1, pos2, pos3, pos4);\n    var transform = h.length ? \"matrix3d(\" + convertMatrixtoCSS(h).join(\",\") + \")\" : \"none\";\n    return [React.createElement(\"div\", {\n      key: \"area\",\n      ref: ref(moveable, \"areaElement\"),\n      className: AREA,\n      style: {\n        top: \"0px\",\n        left: \"0px\",\n        width: width + \"px\",\n        height: height + \"px\",\n        transformOrigin: \"0 0\",\n        transform: transform\n      }\n    }), renderPieces(React)];\n  },\n  dragStart: function (moveable, _a) {\n    var datas = _a.datas,\n        clientX = _a.clientX,\n        clientY = _a.clientY,\n        inputEvent = _a.inputEvent;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    datas.isDragArea = false;\n    datas.inputTarget = inputEvent.target;\n    var areaElement = moveable.areaElement;\n    var _b = moveable.state,\n        targetClientRect = _b.targetClientRect,\n        pos1 = _b.pos1,\n        pos2 = _b.pos2,\n        pos3 = _b.pos3,\n        pos4 = _b.pos4,\n        width = _b.width,\n        height = _b.height,\n        rootMatrix = _b.rootMatrix,\n        is3d = _b.is3d;\n    var left = targetClientRect.left,\n        top = targetClientRect.top;\n\n    var _c = getRect([pos1, pos2, pos3, pos4]),\n        relativeLeft = _c.left,\n        relativeTop = _c.top;\n\n    var n = is3d ? 4 : 3;\n    var poses = caculatePoses(rootMatrix, width, height, n);\n\n    var _d = getRect(poses),\n        rootLeft = _d.left,\n        rootTop = _d.top;\n\n    var rootRelativePos = minus([clientX, clientY], plus([left - rootLeft, top - rootTop], poses[0]));\n\n    var _e = caculate(invert(rootMatrix, n), convertPositionMatrix(rootRelativePos, n), n),\n        posX = _e[0],\n        posY = _e[1];\n\n    var rects = [{\n      left: relativeLeft,\n      top: relativeTop,\n      width: width,\n      height: posY - 10\n    }, {\n      left: relativeLeft,\n      top: relativeTop,\n      width: posX - 10,\n      height: height\n    }, {\n      left: relativeLeft,\n      top: relativeTop + posY + 10,\n      width: width,\n      height: height - posY - 10\n    }, {\n      left: relativeLeft + posX + 10,\n      top: relativeTop,\n      width: width - posX - 10,\n      height: height\n    }];\n    var children = [].slice.call(areaElement.nextElementSibling.children);\n    rects.forEach(function (rect, i) {\n      children[i].style.cssText = \"left: \" + rect.left + \"px;top: \" + rect.top + \"px; width: \" + rect.width + \"px; height: \" + rect.height + \"px;\";\n    });\n    addClass(areaElement, AVOID);\n  },\n  drag: function (moveable, _a) {\n    var datas = _a.datas,\n        inputEvent = _a.inputEvent;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!datas.isDragArea) {\n      datas.isDragArea = true;\n      restoreStyle(moveable);\n    }\n  },\n  dragEnd: function (moveable, e) {\n    if (!e.inputEvent) {\n      return false;\n    }\n\n    var inputEvent = e.inputEvent,\n        isDragArea = e.isDragArea,\n        datas = e.datas;\n\n    if (!datas.isDragArea) {\n      restoreStyle(moveable);\n    }\n\n    var target = moveable.state.target;\n    var inputTarget = inputEvent.target;\n\n    if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n      return;\n    }\n\n    var containsTarget = target.contains(inputTarget);\n    triggerEvent(moveable, \"onClick\", fillParams(moveable, e, {\n      inputTarget: inputTarget,\n      isTarget: target === inputTarget,\n      containsTarget: containsTarget\n    }));\n  },\n  dragGroupStart: function (moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup: function (moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragGroupEnd: function (moveable, e) {\n    var inputEvent = e.inputEvent,\n        isDragArea = e.isDragArea,\n        datas = e.datas;\n\n    if (!inputEvent) {\n      return false;\n    }\n\n    if (!isDragArea) {\n      restoreStyle(moveable);\n    }\n\n    var prevInputTarget = datas.inputTarget;\n    var inputTarget = inputEvent.target;\n\n    if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n      return;\n    }\n\n    var targets = moveable.props.targets;\n    var targetIndex = targets.indexOf(inputTarget);\n    var isTarget = targetIndex > -1;\n    var containsTarget = false;\n\n    if (targetIndex === -1) {\n      targetIndex = findIndex(targets, function (parentTarget) {\n        return parentTarget.contains(inputTarget);\n      });\n      containsTarget = targetIndex > -1;\n    }\n\n    triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n      targets: targets,\n      inputTarget: inputTarget,\n      targetIndex: targetIndex,\n      isTarget: isTarget,\n      containsTarget: containsTarget\n    }));\n  }\n};\nvar Origin = {\n  name: \"origin\",\n  props: {\n    origin: Boolean\n  },\n  render: function (moveable, React) {\n    if (!moveable.props.origin) {\n      return null;\n    }\n\n    var _a = moveable.state,\n        beforeOrigin = _a.beforeOrigin,\n        rotation = _a.rotation;\n    return [React.createElement(\"div\", {\n      className: prefix(\"control\", \"origin\"),\n      style: getControlTransform(rotation, beforeOrigin),\n      key: \"beforeOrigin\"\n    })];\n  }\n};\n\nfunction getDefaultScrollPosition(e) {\n  var scrollContainer = e.scrollContainer;\n  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];\n}\n\nvar Scrollable = {\n  name: \"scrollable\",\n  canPinch: true,\n  props: {\n    scrollable: Boolean,\n    scrollContainer: Object,\n    scrollThreshold: Number\n  },\n  dragStart: function (moveable, e) {\n    var props = moveable.props;\n    var _a = props.scrollContainer,\n        scrollContainer = _a === void 0 ? moveable.getContainer() : _a;\n    var dragScroll = new DragScroll();\n    e.datas.dragScroll = dragScroll;\n    var draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n    var targets = e.targets;\n    dragScroll.on(\"scroll\", function (_a) {\n      var container = _a.container,\n          direction = _a.direction;\n      var params = fillParams(moveable, e, {\n        scrollContainer: container,\n        direction: direction\n      });\n      var eventName = targets ? \"onScrollGroup\" : \"onScroll\";\n\n      if (targets) {\n        params.targets = targets;\n      }\n\n      triggerEvent(moveable, eventName, params);\n    }).on(\"move\", function (_a) {\n      var offsetX = _a.offsetX,\n          offsetY = _a.offsetY;\n      moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n    });\n    dragScroll.dragStart(e, {\n      container: scrollContainer\n    });\n  },\n  checkScroll: function (moveable, e) {\n    var dragScroll = e.datas.dragScroll;\n\n    if (!dragScroll) {\n      return;\n    }\n\n    var _a = moveable.props,\n        _b = _a.scrollContainer,\n        scrollContainer = _b === void 0 ? moveable.getContainer() : _b,\n        _c = _a.scrollThreshold,\n        scrollThreshold = _c === void 0 ? 0 : _c,\n        _d = _a.getScrollPosition,\n        getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;\n    dragScroll.drag(e, {\n      container: scrollContainer,\n      threshold: scrollThreshold,\n      getScrollPosition: function (ev) {\n        return getScrollPosition({\n          scrollContainer: ev.container,\n          direction: ev.direction\n        });\n      }\n    });\n    return true;\n  },\n  drag: function (moveable, e) {\n    return this.checkScroll(moveable, e);\n  },\n  dragEnd: function (moveable, e) {\n    e.datas.dragScroll.dragEnd();\n    e.datas.dragScroll = null;\n  },\n  dragControlStart: function (moveable, e) {\n    return this.dragStart(moveable, __assign({}, e, {\n      isControl: true\n    }));\n  },\n  dragControl: function (moveable, e) {\n    return this.drag(moveable, e);\n  },\n  dragControlEnd: function (moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupStart: function (moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroup: function (moveable, e) {\n    return this.drag(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupEnd: function (moveable, e) {\n    return this.dragEnd(moveable, e);\n  },\n  dragGroupControlStart: function (moveable, e) {\n    return this.dragStart(moveable, e);\n  },\n  dragGroupContro: function (moveable, e) {\n    return this.drag(moveable, __assign({}, e, {\n      targets: moveable.props.targets\n    }));\n  },\n  dragGroupControEnd: function (moveable, e) {\n    return this.dragEnd(moveable, e);\n  }\n};\nvar Default = {\n  name: \"\",\n  props: {\n    target: Object,\n    container: Object,\n    dragArea: Boolean,\n    origin: Boolean,\n    transformOrigin: Array,\n    edge: Boolean,\n    ables: Array,\n    className: String,\n    pinchThreshold: Number\n  }\n};\nvar MOVEABLE_ABLES = [Default, Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea, Origin];\nvar Groupable = {\n  name: \"groupable\",\n  props: {\n    defaultGroupRotate: Number,\n    groupable: Boolean\n  },\n  render: function (moveable, React) {\n    var targets = moveable.props.targets || [];\n    moveable.moveables = [];\n    var _a = moveable.state,\n        left = _a.left,\n        top = _a.top;\n    var position = {\n      left: left,\n      top: top\n    };\n    return targets.map(function (target, i) {\n      return React.createElement(MoveableManager, {\n        key: \"moveable\" + i,\n        ref: refs(moveable, \"moveables\", i),\n        target: target,\n        origin: false,\n        parentMoveable: moveable,\n        parentPosition: position\n      });\n    });\n  }\n};\n\nfunction getMaxPos(poses, index) {\n  return Math.max.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getMinPos(poses, index) {\n  return Math.min.apply(Math, poses.map(function (_a) {\n    var pos1 = _a[0],\n        pos2 = _a[1],\n        pos3 = _a[2],\n        pos4 = _a[3];\n    return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n  }));\n}\n\nfunction getGroupRect(moveables, rotation) {\n  if (!moveables.length) {\n    return [0, 0, 0, 0];\n  }\n\n  var moveablePoses = moveables.map(function (_a) {\n    var state = _a.state;\n    return getAbsolutePosesByState(state);\n  });\n  var minX = MAX_NUM;\n  var minY = MAX_NUM;\n  var groupWidth = 0;\n  var groupHeight = 0;\n  var fixedRotation = throttle(rotation, TINY_NUM);\n\n  if (fixedRotation % 90) {\n    var rad_1 = rotation / 180 * Math.PI;\n    var a1_1 = Math.tan(rad_1);\n    var a2_1 = -1 / a1_1;\n    var b1s_1 = [MIN_NUM, MAX_NUM];\n    var b2s_1 = [MIN_NUM, MAX_NUM];\n    moveablePoses.forEach(function (poses) {\n      poses.forEach(function (pos) {\n        // ax + b = y\n        //  = y - ax\n        var b1 = pos[1] - a1_1 * pos[0];\n        var b2 = pos[1] - a2_1 * pos[0];\n        b1s_1[0] = Math.max(b1s_1[0], b1);\n        b1s_1[1] = Math.min(b1s_1[1], b1);\n        b2s_1[0] = Math.max(b2s_1[0], b2);\n        b2s_1[1] = Math.min(b2s_1[1], b2);\n      });\n    });\n    b1s_1.forEach(function (b1) {\n      // a1x + b1 = a2x + b2\n      b2s_1.forEach(function (b2) {\n        // (a1 - a2)x = b2 - b1\n        var x = (b2 - b1) / (a1_1 - a2_1);\n        var y = a1_1 * x + b1;\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n      });\n    });\n    var rotatePoses = moveablePoses.map(function (_a) {\n      var pos1 = _a[0],\n          pos2 = _a[1],\n          pos3 = _a[2],\n          pos4 = _a[3];\n      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];\n    });\n    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n  } else {\n    minX = getMinPos(moveablePoses, 0);\n    minY = getMinPos(moveablePoses, 1);\n    groupWidth = getMaxPos(moveablePoses, 0) - minX;\n    groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n    if (fixedRotation % 180) {\n      var changedWidth = groupWidth;\n      groupWidth = groupHeight;\n      groupHeight = changedWidth;\n    }\n  }\n\n  return [minX, minY, groupWidth, groupHeight];\n}\n\nvar MoveableGroup = /*#__PURE__*/function (_super) {\n  __extends(MoveableGroup, _super);\n\n  function MoveableGroup() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.differ = new ChildrenDiffer();\n    _this.moveables = [];\n    _this.rotation = 0;\n    return _this;\n  }\n\n  var __proto = MoveableGroup.prototype;\n\n  __proto.updateEvent = function (prevProps) {\n    var state = this.state;\n    var props = this.props;\n\n    if (!state.target) {\n      state.target = this.areaElement;\n      this.controlBox.getElement().style.display = \"block\";\n      this.targetDragger = getAbleDragger(this, state.target, \"targetAbles\", \"Group\");\n      this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n    }\n\n    var isContainerChanged = !equals(prevProps.container, props.container);\n\n    if (isContainerChanged) {\n      state.container = props.container;\n    }\n\n    var _a = this.differ.update(props.targets),\n        added = _a.added,\n        changed = _a.changed,\n        removed = _a.removed;\n\n    if (isContainerChanged || added.length || changed.length || removed.length) {\n      this.updateRect();\n    }\n  };\n\n  __proto.checkUpdate = function () {\n    this.updateAbles();\n  };\n\n  __proto.updateRect = function (type, isTarget, isSetState) {\n    var _a;\n\n    if (isSetState === void 0) {\n      isSetState = true;\n    }\n\n    if (!this.controlBox) {\n      return;\n    }\n\n    this.moveables.forEach(function (moveable) {\n      moveable.updateRect(type, false, false);\n    });\n    var state = this.state;\n    var props = this.props;\n    var target = state.target || props.target;\n\n    if (!isTarget || type !== \"\" && props.updateGroup) {\n      // reset rotataion\n      this.rotation = props.defaultGroupRotate;\n    }\n\n    var rotation = this.rotation;\n\n    var _b = getGroupRect(this.moveables, rotation),\n        left = _b[0],\n        top = _b[1],\n        width = _b[2],\n        height = _b[3]; // tslint:disable-next-line: max-line-length\n\n\n    target.style.cssText += \"left:0px;top:0px;width:\" + width + \"px; height:\" + height + \"px;transform:rotate(\" + rotation + \"deg)\";\n    state.width = width;\n    state.height = height;\n    var container = this.getContainer();\n    var info = getTargetInfo(target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container, state);\n    var pos = [info.left, info.top];\n    _a = getAbsolutePosesByState(info), info.pos1 = _a[0], info.pos2 = _a[1], info.pos3 = _a[2], info.pos4 = _a[3];\n    info.origin = plus(pos, info.origin);\n    info.beforeOrigin = plus(pos, info.beforeOrigin);\n    var clientRect = info.targetClientRect;\n    clientRect.top += top - info.top - state.top;\n    clientRect.left += left - info.left - state.left;\n    this.updateState(__assign({}, info, {\n      left: left - info.left,\n      top: top - info.top\n    }), isSetState);\n  };\n\n  __proto.triggerEvent = function (name, e) {\n    if (name.indexOf(\"Group\") > -1) {\n      return _super.prototype.triggerEvent.call(this, name, e);\n    }\n  };\n\n  __proto.updateAbles = function () {\n    _super.prototype.updateAbles.call(this, this.props.ables.concat([Groupable]), \"Group\");\n  };\n\n  MoveableGroup.defaultProps = __assign({}, MoveableManager.defaultProps, {\n    transformOrigin: [\"50%\", \"50%\"],\n    groupable: true,\n    dragArea: true,\n    keepRatio: true,\n    targets: [],\n    defaultGroupRotate: 0\n  });\n  return MoveableGroup;\n}(MoveableManager);\n\nvar Moveable = /*#__PURE__*/function (_super) {\n  __extends(Moveable, _super);\n\n  function Moveable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  var __proto = Moveable.prototype;\n\n  __proto.render = function () {\n    var props = this.props;\n    var ables = props.ables || [];\n    var target = this.props.target || this.props.targets;\n    var isArr = isArray(target);\n    var isGroup = isArr && target.length > 1;\n\n    if (isGroup) {\n      var nextProps = __assign({}, this.props, {\n        target: null,\n        targets: target,\n        ables: MOVEABLE_ABLES.concat([Groupable], ables)\n      });\n\n      return createElement(MoveableGroup, __assign({\n        key: \"group\",\n        ref: ref(this, \"moveable\")\n      }, nextProps));\n    } else {\n      var moveableTarget = isArr ? target[0] : target;\n      return createElement(MoveableManager, __assign({\n        key: \"single\",\n        ref: ref(this, \"moveable\")\n      }, __assign({}, this.props, {\n        target: moveableTarget,\n        ables: MOVEABLE_ABLES.concat(ables)\n      })));\n    }\n  };\n  /**\n   * Check if the target is an element included in the moveable.\n   * @method Moveable#isMoveableElement\n   * @param - the target\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"click\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *         moveable.target = e.target;\n   *     }\n   * });\n   */\n\n\n  __proto.isMoveableElement = function (target) {\n    return this.moveable.isMoveableElement(target);\n  };\n  /**\n   * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n   * @method Moveable#dragStart\n   * @param - external `MouseEvent`or `TouchEvent`\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (!moveable.isMoveableElement(e.target)) {\n   *          moveable.dragStart(e);\n   *     }\n   * });\n   */\n\n\n  __proto.dragStart = function (e) {\n    this.moveable.dragStart(e);\n  };\n  /**\n   * Whether the coordinates are inside Moveable\n   * @method Moveable#isInside\n   * @param - x coordinate\n   * @param - y coordinate\n   * @return - True if the coordinate is in moveable or false\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * document.body.addEventListener(\"mousedown\", e => {\n   *     if (moveable.isInside(e.clientX, e.clientY)) {\n   *          console.log(\"inside\");\n   *     }\n   * });\n   */\n\n\n  __proto.isInside = function (clientX, clientY) {\n    return this.moveable.isInside(clientX, clientY);\n  };\n  /**\n   * If the width, height, left, and top of all elements change, update the shape of the moveable.\n   * @method Moveable#updateRect\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * window.addEventListener(\"resize\", e => {\n   *     moveable.updateRect();\n   * });\n   */\n\n\n  __proto.updateRect = function () {\n    this.moveable.updateRect();\n  };\n  /**\n   * If the width, height, left, and top of the only target change, update the shape of the moveable.\n   * @method Moveable#updateTarget\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.updateTarget();\n   */\n\n\n  __proto.updateTarget = function () {\n    this.moveable.updateTarget();\n  };\n  /**\n   * You can get the vertex information, position and offset size information of the target based on the container.\n   * @method Moveable#getRect\n   * @return - The Rect Info\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * const rectInfo = moveable.getRect();\n   */\n\n\n  __proto.getRect = function () {\n    return this.moveable.getRect();\n  };\n  /**\n   * Request able through a method rather than an event.\n   * At the moment of execution, requestStart is executed,\n   * and then request and requestEnd can be executed through Requester.\n   * @method Moveable#request\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n   * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n   * @param - ableName\n   * @param - request to be able params. If isInstant is true, request and requestEnd are executed immediately.\n   * @return - Able Requester. If there is no request in able, nothing will work.\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * // Instantly Request (requestStart - request - requestEnd)\n   * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n   *\n   * // Start move\n   * const requester = moveable.request(\"draggable\");\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.request({ deltaX: 10, deltaY: 10 });\n   * requester.requestEnd();\n   */\n\n\n  __proto.request = function (ableName, params) {\n    return this.moveable.request(ableName, params);\n  };\n  /**\n   * Remove the Moveable object and the events.\n   * @method Moveable#destroy\n   * @example\n   * import Moveable from \"moveable\";\n   *\n   * const moveable = new Moveable(document.body);\n   *\n   * moveable.destroy();\n   */\n\n\n  __proto.destroy = function () {\n    this.moveable.componentWillUnmount();\n  };\n\n  return Moveable;\n}(PureComponent);\n\nexport default Moveable;","map":{"version":3,"sources":["../src/react-moveable/consts.ts","../src/react-moveable/utils.ts","../src/react-moveable/ables/triggerRender.ts","../src/react-moveable/getAbleDragger.ts","../src/react-moveable/MoveableManager.tsx","../src/react-moveable/ables/Pinchable.ts","../src/react-moveable/groupUtils.ts","../src/react-moveable/DraggerUtils.ts","../src/react-moveable/ables/utils.ts","../src/react-moveable/ables/snappable/snap.ts","../src/react-moveable/ables/snappable/innerBounds.ts","../src/react-moveable/ables/snappable/bounds.ts","../src/react-moveable/ables/Snappable.tsx","../src/react-moveable/ables/Draggable.tsx","../src/react-moveable/CustomDragger.ts","../src/react-moveable/ables/Rotatable.tsx","../src/react-moveable/renderDirection.tsx","../src/react-moveable/ables/Resizable.ts","../src/react-moveable/ables/Scalable.ts","../src/react-moveable/ables/Warpable.tsx","../src/react-moveable/classNames.ts","../src/react-moveable/ables/DragArea.tsx","../src/react-moveable/ables/Origin.tsx","../src/react-moveable/ables/Scrollable.ts","../src/react-moveable/ables/Default.ts","../src/react-moveable/ables/consts.ts","../src/react-moveable/ables/Groupable.tsx","../src/react-moveable/MoveableGroup.tsx","../src/react-moveable/Moveable.tsx"],"names":["x1","getSVGCursor","x2","degree45","Math","degree","defaultCursor","agent","getAgent","IS_WEBKIT","PREFIX","MOVEABLE_CSS","prefixCSS","getCursorCSS","NEARBY_POS","TINY_NUM","MIN_SCALE","MAX_NUM","MIN_NUM","DIRECTION_INDEXES","n","s","w","e","nw","ne","sw","se","DIRECTION_ROTATIONS","multiply2","pos1","pos2","prefix","classNames","prefixNames","createIdentityMatrix3","createIdentityMatrix","getTransformMatrix","transform","isObject","value","splitBracket","parseFloat","getAbsoluteMatrix","matrix","origin","multiplies","createOriginMatrix","measureSVGSize","el","unit","isHorizontal","viewBox","getBeforeTransformOrigin","relativeOrigin","getTransformOrigin","getComputedStyle","_a","i","style","transformOrigin","getOffsetInfo","lastParent","isParent","body","document","target","isEnd","position","isStatic","offsetParent","getOffsetPosInfo","container","isFixed","tagName","offsetLeft","offsetTop","containerClientRect","isSVG","isUndefined","hasOffset","offset","getMatrixStackInfo","prevMatrix","matrixes","is3d","offsetContainer","styleTransform","convertCSStoMatrix","length","matrixesLength","convertDimension","offsetPos","getSVGMatrix","_b","isOffsetEnd","parentClientLeft","parentClientTop","targetMatrix","caculateMatrixStack","rootContainer","prevRootMatrix","prevN","prevTargetMatrix","rootMatrixes","isRoot3d","isSVGGraphicElement","originalContainer","allMatrix","rootMatrix","beforeMatrix","offsetMatrix","endContainer","multiply","isMatrix3d","convertMatrixtoCSS","ignoreDimension","clientWidth","clientHeight","viewBoxWidth","viewBoxHeight","scaleX","scaleY","preserveAspectRatio","align","meetOrSlice","svgOrigin","scale","translate","xAlign","yAlign","scaleDimension","scaleMatrix","createScaleMatrix","getSVGGraphicsOffset","bbox","svgElement","left","top","caculatePosition","pos","caculate","convertPositionMatrix","caculatePoses","width","height","pos3","pos4","getRect","poses","posesX","posesY","right","bottom","rectWidth","rectHeight","caculateRect","getSVGOffset","absoluteMatrix","rect","rectLeft","rectTop","mat","_c","prevLeft","prevTop","prevWidth","prevHeight","posOrigin","prevOrigin","minus","rectOrigin","count","inverseBeforeMatrix","invert","mat2","_d","nextLeft","nextTop","distLeft","distTop","caculateMoveablePosition","y1","y2","x3","y3","_e","x4","y4","_f","originX","originY","center","pos1Rad","getRad","pos2Rad","direction","getDistSize","vec","getDiagonalSize","getLineStyle","rad","getControlTransform","rotation","x","prev","y","getCSSSize","window","getSize","isOffset","isBoxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","getRotationRad","getTargetInfo","parentContainer","state","beforeDirection","targetTransform","beforeOrigin","targetClientRect","resetClientRect","beforePos","getClientRect","scrollWidth","scrollHeight","isExtends","getDirection","direciton","dir","getAbsolutePoses","dist","plus","getAbsolutePosesByState","roundSign","num","throttle","throttleArray","nums","unset","self","name","getOrientationDirection","isInside","k1","k2","k3","k4","k5","k6","signs1","signs2","sign","fillParams","moveable","params","datas","clientX","clientY","inputEvent","currentTarget","triggerEvent","pseudoElt","filterAbles","ables","methods","enabledAbles","ableGroups","able","getKeepRatioHeight","isWidth","ratio","getKeepRatioWidth","equals","a1","a2","selectValue","values","groupBy","arr","func","group","groupMap","groupKey","flat","maxOffset","args","convertDragDist","triggerRenderStart","isGroup","isPinch","eventAffix","triggerRender","triggerRenderEnd","isDrag","triggerAble","ableType","eventOperation","eventType","isReqeust","isStart","eventName","conditionName","isAfter","events","results","condition","isUpdate","childeMoveable","getAbleDragger","options","pinchThreshold","ControlBoxElement","styled","key","index","className","tslib_1","MoveableManager","edge","parentMoveable","parentPosition","dragArea","zoom","_this","props","propsTarget","parentLeft","parentTop","stateTarget","groupTargets","isDisplay","ref","renderLine","isSetState","isTarget","controlBoxElement","hasTargetAble","hasControlAble","prevTarget","prevProps","prevDragArea","isTargetChanged","isUnset","dragger","offsetWidth","offsetHeight","statePos","param","groupable","requsetAble","request","requestEnd","ableRequester","requester","isRequest","stateContainer","isChanged","callback","dragStart","pinchStart","dragControlStart","targetAbles","controlAbles","nextState","Renderer","createElement","React","render","touches","updateRect","pinchable","Number","targets","controlEventName","pinchAbles","result","parentRotate","getRotatiion","ableEvent","pinchFlag","pinch","pinchScale","distance","parentDistance","pinchEnd","pinchGroupStart","pinchGroup","pinchGroupEnd","triggerChildAble","type","eachEvent","ableDatas","childs","childDatas","childEvent","isFunction","parentFlag","child","setDragStart","getDragDist","distX","distY","isBefore","inverseMatrix","startDragBeforeDist","startDragDist","absoluteOrigin","getInverseDragDist","caculateTransformOrigin","prevSize","size","isNaN","measureRatio","getPosIndexesByDirection","indexes","getPosesByDirection","getPosByDirection","nextPoses","getPosByReverseDirection","startPos1","startPos2","startPos3","startPos4","startPos","getNextMatrix","getScaleDist","dragClient","nextMatrix","groupLeft","groupTop","getStartPos","getDist","getResizeDist","fixedPosition","nextOrigin","getStartDirection","baseDirection","getAbsoluteFixedPosition","directionCondition","hasClass","getTotalGuidelines","guidelines","containerHeight","containerWidth","verticalGuidelines","horizontalGuidelines","totalGuidelines","snapHorizontal","snapVertical","checkSnapPoses","snapCenter","customSnapThreshold","snapThreshold","vertical","checkSnap","horizontal","checkSnapKeepRatio","endPos","endX","endY","startX","startY","dx","dy","isBottom","isRight","verticalInfo","isSnap","horizontalInfo","verticalSnapInfo","horizontalSnapInfo","isVerticalSnap","verticalGuideline","isHorizontalSnap","horizontalGuideline","horizontalPos","verticalPos","a","b","checkSnaps","isCenter","isSnapCenter","verticalNames","horizontalNames","getNearestSnapGuidelineInfo","snapInfo","guideline","posInfo","guidelineInfo","posInfos","isVertical","targetType","posType","snapPosInfos","guidelineInfos","targetPos","element","snapPosInfo","getSnapInfosByDirection","snapDirection","alignPoses","getNearOffsetInfo","offsets","aSign","bSign","aOffset","bOffset","aDist","bDist","cx","average","line","cy","dot","test1","test2","error","centerSign","hitTestLine","dots","threshold","start","end","isBound","bounds","isAllBound","isVerticalBound","isHorizontalBound","leftLine","topLine","rightLine","bottomLine","isHorizontalStart","isVerticalStart","isSameStartLine","topBoundInfo","checkLineBoundCollision","bottomBoundInfo","leftBoundInfo","rightBoundInfo","isAllVerticalBound","isAllHorizontalBound","verticalOffset","horizontalOffset","dot1","dot2","boundDot1","boundLine","boundDot2","dy1","dx1","dy2","dx2","checkInnerBoundDot","getInnerBoundInfo","lines","multiple","sizeOffset","getInnerBoundDragInfo","innerBoundInfo","widthOffsetInfo","heightOffsetInfo","getCheckSnapLineDirections","keepRatio","lineDirections","getCheckSnapLines","dir1","dir2","rotate","checkRotateInnerBounds","prevPoses","relativeLeft","relativeRight","relativeTop","relativeBottom","isBoundRotate","dotInfos","lineRad","solveReverseLine","lineDist","getDistPointLine","dotDist","dotRad","distRad","nextRad1","nextRad2","nextRad","checkInnerBoundPoses","innerBounds","horizontalPoses","verticalPoses","boundMap","checkBoundPoses","checkBound","checkBoundKeepRatio","startBoundPos","endBoundPos","minPos","maxPos","relativePoses","boundRect","boundRotate","boundPos","r","nextPos","checkRotateBounds","relativeRad1","snapStart","elementGuidelines","containerTop","containerLeft","clientTop","clientLeft","targetLeft","targetTop","elementTop","elementBottom","elementLeft","elementRight","hasGuidelines","ableName","snappable","enableSnap","solveEquation","widthOffset","heightOffset","boundInfo","checkSnapBoundsKeepRatio","horizontalBoundInfo","verticalBoundInfo","getSnapBoundOffset","horizontalDist","verticalDist","checkSnapBounds","boundPoses","getSnapBound","checkMaxBounds","fixedPos","fixedDirection","maxWidth","maxHeight","directions","isCheckVertical","otherDirection","isCheckHorizontal","otherPos","startDirection","endDirection","otherStartPos","otherEndPos","snapBoundInfo","otherHorizontalDist","otherHorizontalOffset","isOtherHorizontalBound","isOtherHorizontalSnap","otherVerticalDist","otherVerticalOffset","isOtherVerticalBound","isOtherVerticalSnap","getCheckSnapDirections","getSizeOffsetInfo","getSnapBoundInfo","recheckSizeByTwoDirection","snapPos","nextWidthOffset","nextHeightOffset","nextWidth","nextHeight","checkSizeDist","getNextPoses","isWidthBound","isHeightBound","widthDist","heightDist","isGetWidthOffset","checkSnapRotate","checkSnapSize","getNextFixedPoses","checkSnapScale","sizeDist","snapOffset","startCheckSnapDrag","checkThrottleDragRotate","throttleDragRotate","offsetX","offsetY","adjustPoses","adjustPos","prevDistY","checkSnapDrag","snapPoses","verticalSnapBoundInfo","horizontalSnapBoundInfo","verticalInnerBoundInfo","horizontalInnerBoundInfo","relativePos","elementPos","groupInfos","size2","groupInfo","find","groupElement","groupPos","getElementGuidelineDist","directionName","posName1","posName2","sizeName","isFirstRenderSize","linePos","lineSize","isRenderSize","snapSize","isDisplaySnapDigit","j","verticalBoundPos","horizontalBoundPos","verticalSnapPoses","horizontalSnapPoses","verticalInnerBoundPoses","horizontalInnerBoundPoses","snapElement","snapDigit","Object","snapRenderInfo","minLeft","minTop","verticalGuildelines","snapInfos","verticalPosInfos","horizontalPosInfos","getSnapGuidelines","addBoundGuidelines","elementHorizontalGroup","groupByElementGuidelines","elementVerticalGroup","renderElementGroup","renderSnapPoses","renderGuidelines","snap","dragEnd","dragControlCondition","rotatableDragControlCondtion","dragControlEnd","dragGroupStart","dragGroupEnd","dragGroupControlStart","dragGroupControlEnd","draggable","throttleDrag","dragInfo","parentEvent","parentDragger","set","startRect","drag","prevDist","prevBeforeDist","startTranslate","dragRotateRad","deg","beforeTranslate","beforeDist","delta","beforeDelta","nextTransform","nextParams","dragGroup","passDistX","passDistY","isControl","requestStart","setCustomDrag","isConvert","client","deltaX","deltaY","startAbsoluteOrigin","prevDeg","absoluteDeg","startRotate","prevSnapDeg","startDeg","prevLoop","loop","absolutePrevSnapDeg","getDeg","getPositions","rotationPosition","canPinch","rotatable","throttleRotate","rotationRad","externalRotate","controlRect","setRotateStartInfo","dragControl","beforeInfo","afterInfo","isRotate","_g","_h","parentDist","beforeRotate","dragGroupControlCondition","parentBeforeOrigin","childClient","eventParams","Draggable","dragGroupControl","prevX","prevY","dragResult","distRotate","renderControls","defaultDirections","directionMap","directionRotation","renderAllDirections","renderDiagonalDirections","ableGroup","resizable","throttleResize","renderDirections","Boolean","parentDirection","startWidth","startHeight","setOrigin","parentScale","parentKeepRatio","isResize","startOffsetWidth","startOffsetHeight","sizeDirection","distWidth","distHeight","standardRad","ratioRad","signSize","snapDist","isNoSnap","inverseDelta","dragControlAfter","errorWidth","errorHeight","isErrorWidth","isErrorHeight","originalX","originalY","scalable","throttleScale","isScale","startScale","nowDist","stateDirection","isArray","snapHeight","snapWidth","rad1","rad2","getTriangleRad","poses1","poses2","pi","warpable","Array","linePosFrom1","getMiddleLinePos","linePosFrom2","linePosFrom3","linePosFrom4","linePosTo1","linePosTo2","linePosTo3","linePosTo4","inputTarget","targetInverseMatrix","isWarp","startMatrix","posIndexes","absolutePoses","selectedPoses","h","createWarpMatrix","multiplyCSS","AREA","AREA_PIECES","AREA_PIECE","AVOID","removeClass","renderPieces","areaElement","rootLeft","rootTop","rootRelativePos","posX","posY","rects","children","addClass","restoreStyle","isDragArea","containsTarget","prevInputTarget","targetIndex","findIndex","parentTarget","scrollContainer","scrollable","scrollThreshold","dragScroll","draggerName","checkScroll","getScrollPosition","ev","dragGroupContro","dragGroupControEnd","MOVEABLE_ABLES","defaultGroupRotate","refs","moveables","moveablePoses","minX","minY","groupWidth","groupHeight","fixedRotation","rad_1","a1_1","a2_1","b1s_1","b2s_1","b1","b2","rotatePoses","getMaxPos","getMinPos","changedWidth","MoveableGroup","defaultProps","isContainerChanged","added","changed","removed","info","clientRect","_super","isArr","nextProps","moveableTarget"],"mappings":"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","sourcesContent":["import { prefixCSS } from \"framework-utils\";\nimport getAgent from \"@egjs/agent\";\nimport { IObject } from \"@daybrush/utils\";\n\nfunction getSVGCursor(scale: number, degree: number) {\n    return `data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${32 * scale}px\" height=\"${32 * scale}px\" viewBox=\"0 0 32 32\" ><path d=\"M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z\" stroke-linejoin=\"round\" stroke-width=\"1.2\" fill=\"black\" stroke=\"white\" style=\"transform:rotate(${degree}deg);transform-origin: 16px 16px\"></path></svg>`;\n}\nfunction getCursorCSS(degree: number) {\n    const x1 = getSVGCursor(1, degree);\n    const x2 = getSVGCursor(2, degree);\n    const degree45 = (Math.round(degree / 45) * 45) % 180;\n    const defaultCursor\n        = degree45 === 135\n        ? \"nwse-resize\"\n        : degree45 === 45\n        ? \"nesw-resize\"\n        : degree45 === 90\n        ? \"ew-resize\"\n        : \"ns-resize\"; // 135\n\n    // tslint:disable-next-line: max-line-length\n    return `cursor:${defaultCursor};cursor: url('${x1}') 16 16, ${defaultCursor};cursor: -webkit-image-set(url('${x1}') 1x, url('${x2}') 2x) 16 16, ${defaultCursor};`;\n}\n\nexport const agent = getAgent();\nexport const IS_WEBKIT\n    = agent.os.name.indexOf(\"ios\") > -1 || agent.browser.name.indexOf(\"safari\") > -1;\n\nexport const PREFIX = \"moveable-\";\nexport const MOVEABLE_CSS = prefixCSS(PREFIX, `\n{\n\tposition: fixed;\n\twidth: 0;\n\theight: 0;\n\tleft: 0;\n\ttop: 0;\n    z-index: 3000;\n    --zoom: 1;\n    --zoompx: 1px;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n\tleft: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n\tposition: absolute;\n\twidth: 14px;\n\theight: 14px;\n\tborder-radius: 50%;\n\tborder: 2px solid #fff;\n\tbox-sizing: border-box;\n\tbackground: #4af;\n\tmargin-top: -7px;\n    margin-left: -7px;\n    width: calc(14 * var(--zoompx));\n    height: calc(14 * var(--zoompx));\n    margin-top: calc(-7 * var(--zoompx));\n    margin-left: calc(-7 * var(--zoompx));\n    border: calc(2 * var(--zoompx)) solid #fff;\n    z-index: 10;\n}\n.line {\n\tposition: absolute;\n\twidth: 1px;\n    height: 1px;\n    width: var(--zoompx);\n    height: var(--zoompx);\n\tbackground: #4af;\n\ttransform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top: var(--zoompx) dashed #4af;\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left: var(--zoompx) dashed #4af;\n}\n.line.dashed:before {\n    position: absolute;\n    content: attr(data-size);\n    color: #4af;\n    font-size: 12px;\n    font-weight: bold;\n}\n.line.dashed.horizontal:before {\n    left: 50%;\n    transform: translateX(-50%);\n    bottom: 5px;\n}\n.line.dashed.vertical:before {\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.line.rotation-line {\n\theight: 40px;\n    width: 1px;\n    transform-origin: 50% calc(100% - 0.5px);\n    top: -40px;\n    width: var(--zoompx);\n    height: calc(40 * var(--zoompx));\n    top: calc(-40 * var(--zoompx));\n    transform-origin: 50% calc(100% - 0.5 * var(--zoompx));\n}\n.line.rotation-line .control {\n\tborder-color: #4af;\n\tbackground:#fff;\n    cursor: alias;\n    left: 50%;\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n    width: calc(2 * var(--zoompx));\n}\n.line.horizontal.bold {\n    height: 2px;\n    height: calc(2 * var(--zoompx));\n}\n.control.origin {\n\tborder-color: #f55;\n\tbackground: #fff;\n\twidth: 12px;\n\theight: 12px;\n\tmargin-top: -6px;\n    margin-left: -6px;\n    width: calc(12 * var(--zoompx));\n    height: calc(12 * var(--zoompx));\n    margin-top: calc(-6 * var(--zoompx));\n    margin-left: calc(-6 * var(--zoompx));\n\tpointer-events: none;\n}\n${[0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(degree => `\n.direction[data-rotation=\"${degree}\"] {\n\t${getCursorCSS(degree)}\n}\n`).join(\"\\n\")}\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n${IS_WEBKIT ? `:global svg *:before {\n\tcontent:\"\";\n\ttransform-origin: inherit;\n}` : \"\"}\n`);\nexport const DRAGGER_EVENTS = [\"dragstart\", \"drag\", \"dragend\", \"pinchstart\", \"pinch\", \"pinchend\"];\n\nexport const NEARBY_POS = [\n    [0, 1, 2],\n    [1, 0, 3],\n    [2, 0, 3],\n    [3, 1, 2],\n];\n\nexport const TINY_NUM = 0.0000001;\nexport const MIN_SCALE = 0.000000001;\nexport const MAX_NUM = Math.pow(10, 10);\nexport const MIN_NUM = -MAX_NUM;\n\nexport const DIRECTION_INDEXES: IObject<number[]> = {\n    n: [0, 1],\n    s: [2, 3],\n    w: [2, 0],\n    e: [1, 3],\n    nw: [0],\n    ne: [1],\n    sw: [2],\n    se: [3],\n};\nexport const DIRECTION_ROTATIONS: IObject<number> = {\n    n: 0,\n    s: 180,\n    w: 270,\n    e: 90,\n    nw: 315,\n    ne: 45,\n    sw: 225,\n    se: 135,\n};\n","import { PREFIX, IS_WEBKIT } from \"./consts\";\nimport { prefixNames } from \"framework-utils\";\nimport { splitBracket, isUndefined, isObject, splitUnit, IObject } from \"@daybrush/utils\";\nimport {\n    multiply, invert,\n    convertCSStoMatrix, convertMatrixtoCSS,\n    convertDimension, createIdentityMatrix,\n    createOriginMatrix, convertPositionMatrix, caculate,\n    multiplies,\n    minus,\n    getOrigin,\n    createScaleMatrix,\n    plus,\n    getRad,\n    ignoreDimension,\n} from \"@moveable/matrix\";\n\nimport MoveableManager from \"./MoveableManager\";\nimport { MoveableManagerState, Able, MoveableClientRect } from \"./types\";\n\nexport function round(num: number) {\n    return Math.round(num);\n}\nexport function multiply2(pos1: number[], pos2: number[]) {\n    return [\n        pos1[0] * pos2[0],\n        pos1[1] * pos2[1],\n    ];\n}\nexport function prefix(...classNames: string[]) {\n    return prefixNames(PREFIX, ...classNames);\n}\n\nexport function createIdentityMatrix3() {\n    return createIdentityMatrix(3);\n}\n\nexport function getTransform(target: SVGElement | HTMLElement, isInit: true): number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: false): \"none\" | number[];\nexport function getTransform(target: SVGElement | HTMLElement, isInit?: boolean) {\n    const transform = getComputedStyle(target).transform!;\n\n    if (!transform || (transform === \"none\" && !isInit)) {\n        return \"none\";\n    }\n    return getTransformMatrix(transform);\n}\n\nexport function getTransformMatrix(transform: string | number[]) {\n    if (!transform || transform === \"none\") {\n        return [1, 0, 0, 1, 0, 0];\n\n    }\n    if (isObject(transform)) {\n        return transform;\n    }\n    const value = splitBracket(transform).value!;\n    return value.split(/s*,\\s*/g).map(v => parseFloat(v));\n}\nexport function getAbsoluteMatrix(matrix: number[], n: number, origin: number[]) {\n\n    return multiplies(\n        n,\n        createOriginMatrix(origin, n),\n        matrix,\n        createOriginMatrix(origin.map(a => -a), n),\n    );\n}\nexport function measureSVGSize(el: SVGElement, unit: string, isHorizontal: boolean) {\n    if (unit === \"%\") {\n        const viewBox = el.ownerSVGElement!.viewBox.baseVal;\n        return viewBox[isHorizontal ? \"width\" : \"height\"] / 100;\n    }\n    return 1;\n}\nexport function getBeforeTransformOrigin(el: SVGElement) {\n    const relativeOrigin = getTransformOrigin(getComputedStyle(el, \":before\"));\n\n    return relativeOrigin.map((o, i) => {\n        const { value, unit } = splitUnit(o);\n\n        return value * measureSVGSize(el, unit, i === 0);\n    });\n}\nexport function getTransformOrigin(style: CSSStyleDeclaration) {\n    const transformOrigin = style.transformOrigin;\n\n    return transformOrigin ? transformOrigin.split(\" \") : [\"0\", \"0\"];\n}\nexport function getOffsetInfo(\n    el: SVGElement | HTMLElement | null | undefined,\n    lastParent: SVGElement | HTMLElement | null | undefined,\n    isParent?: boolean,\n) {\n    const body = document.body;\n    let target = !el || isParent ? el : el.parentElement;\n    let isEnd = false;\n    let position = \"relative\";\n\n    while (target && target !== body) {\n        if (lastParent === target) {\n            isEnd = true;\n        }\n        const style = getComputedStyle(target);\n        const transform = style.transform;\n        position = style.position!;\n\n        if (position !== \"static\" || (transform && transform !== \"none\")) {\n            break;\n        }\n        target = target.parentElement;\n        position = \"relative\";\n    }\n    return {\n        isStatic: position === \"static\",\n        isEnd: isEnd || !target || target === body,\n        offsetParent: target as HTMLElement || body,\n    };\n\n}\nexport function getOffsetPosInfo(\n    el: HTMLElement | SVGElement,\n    container: SVGElement | HTMLElement | null,\n    style: CSSStyleDeclaration,\n    isFixed: boolean,\n) {\n    const tagName = el.tagName.toLowerCase();\n    let offsetLeft = (el as HTMLElement).offsetLeft;\n    let offsetTop = (el as HTMLElement).offsetTop;\n\n    if (isFixed) {\n        const containerClientRect = (container || document.documentElement).getBoundingClientRect();\n\n        offsetLeft -= containerClientRect.left;\n        offsetTop -= containerClientRect.top;\n    }\n    // svg\n    const isSVG = isUndefined(offsetLeft);\n    let hasOffset = !isSVG;\n    let origin: number[];\n    // inner svg element\n    if (!hasOffset && tagName !== \"svg\") {\n        origin = IS_WEBKIT\n            ? getBeforeTransformOrigin(el as SVGElement)\n            : getTransformOrigin(style).map(pos => parseFloat(pos));\n\n        hasOffset = true;\n\n        if (tagName === \"g\") {\n            offsetLeft = 0;\n            offsetTop = 0;\n        } else {\n            [\n                offsetLeft, offsetTop, origin[0], origin[1],\n            ] = getSVGGraphicsOffset(el as SVGGraphicsElement, origin);\n        }\n    } else {\n        origin = getTransformOrigin(style).map(pos => parseFloat(pos));\n    }\n    return {\n        isSVG,\n        hasOffset,\n        offset: [offsetLeft, offsetTop],\n        origin,\n    };\n}\nexport function getMatrixStackInfo(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n) {\n    let el: SVGElement | HTMLElement | null = target;\n    const matrixes: number[][] = [];\n    let isEnd = false;\n    let is3d = false;\n    let n = 3;\n    let transformOrigin!: number[];\n    let targetMatrix!: number[];\n\n    const offsetContainer = getOffsetInfo(container, container, true).offsetParent;\n\n    if (prevMatrix) {\n        isEnd = target === container;\n        if (prevMatrix.length > 10) {\n            is3d = true;\n            n = 4;\n        }\n        container = target.parentElement;\n    }\n\n    while (el && !isEnd) {\n        const style: CSSStyleDeclaration = getComputedStyle(el);\n        const tagName = el.tagName.toLowerCase();\n        const position = style.position;\n        const isFixed = position === \"fixed\";\n        const styleTransform = style.transform!;\n        let matrix: number[] = convertCSStoMatrix(getTransformMatrix(styleTransform));\n\n        // convert 3 to 4\n        const length = matrix.length;\n        if (!is3d && length === 16) {\n            is3d = true;\n            n = 4;\n            const matrixesLength = matrixes.length;\n\n            for (let i = 0; i < matrixesLength; ++i) {\n                matrixes[i] = convertDimension(matrixes[i], 3, 4);\n            }\n        }\n        if (is3d &&  length === 9) {\n            matrix = convertDimension(matrix, 3, 4);\n        }\n        const {\n            hasOffset,\n            isSVG,\n            origin,\n            offset: offsetPos,\n        } = getOffsetPosInfo(el, container, style, isFixed);\n        let [\n            offsetLeft,\n            offsetTop,\n        ] = offsetPos;\n        if (tagName === \"svg\" && targetMatrix) {\n            matrixes.push(\n                // scale matrix for svg's SVGElements.\n                getSVGMatrix(el as SVGSVGElement, n),\n                createIdentityMatrix(n),\n            );\n        }\n        const {\n            offsetParent,\n            isEnd: isOffsetEnd,\n            isStatic,\n        } = getOffsetInfo(el, container);\n\n        if (IS_WEBKIT && hasOffset && !isSVG && isStatic && position === \"relative\") {\n            offsetLeft -= offsetParent.offsetLeft;\n            offsetTop -= offsetParent.offsetTop;\n            isEnd = isEnd || isOffsetEnd;\n        }\n        let parentClientLeft = 0;\n        let parentClientTop = 0;\n\n        if (hasOffset && offsetContainer !== offsetParent) {\n            // border\n            parentClientLeft = offsetParent.clientLeft;\n            parentClientTop = offsetParent.clientTop;\n        }\n        matrixes.push(\n            // absolute matrix\n            getAbsoluteMatrix(matrix, n, origin),\n            // offset matrix (offsetPos + clientPos(border))\n            createOriginMatrix(hasOffset ? [\n                offsetLeft - el.scrollLeft + parentClientLeft,\n                offsetTop - el.scrollTop + parentClientTop,\n            ] : [el, origin] as any, n),\n        );\n        if (!targetMatrix) {\n            targetMatrix = matrix;\n        }\n        if (!transformOrigin) {\n            transformOrigin = origin;\n        }\n        if (isEnd || isFixed) {\n            break;\n        } else {\n            el = offsetParent;\n            isEnd = isOffsetEnd;\n        }\n    }\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(n);\n    }\n    if (!transformOrigin) {\n        transformOrigin = [0, 0];\n    }\n    return {\n        offsetContainer,\n        matrixes,\n        targetMatrix,\n        transformOrigin,\n        is3d,\n    };\n}\nexport function caculateMatrixStack(\n    target: SVGElement | HTMLElement,\n    container: SVGElement | HTMLElement | null,\n    rootContainer: SVGElement | HTMLElement | null,\n    prevMatrix?: number[],\n    prevRootMatrix?: number[],\n    prevN?: number,\n): [number[], number[], number[], number[], number[], string, number[], boolean] {\n    const {\n        matrixes,\n        is3d,\n        targetMatrix: prevTargetMatrix,\n        transformOrigin,\n        offsetContainer,\n    } = getMatrixStackInfo(target, container, prevMatrix);\n    const {\n        matrixes: rootMatrixes,\n        is3d: isRoot3d,\n    } = getMatrixStackInfo(offsetContainer, rootContainer, prevRootMatrix);\n\n    const n = isRoot3d || is3d ? 4 : 3;\n    const isSVGGraphicElement = target.tagName.toLowerCase() !== \"svg\" && \"ownerSVGElement\" in target;\n    const originalContainer = container || document.body;\n    let allMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let targetMatrix = prevTargetMatrix;\n    let rootMatrix = prevRootMatrix ? convertDimension(prevRootMatrix, prevN!, n) : createIdentityMatrix(n);\n    let beforeMatrix = prevMatrix ? convertDimension(prevMatrix, prevN!, n) : createIdentityMatrix(n);\n    let offsetMatrix = createIdentityMatrix(n);\n    const length = matrixes.length;\n    const endContainer = getOffsetInfo(originalContainer, originalContainer, true).offsetParent;\n\n    rootMatrixes.reverse();\n    matrixes.reverse();\n\n    if (!is3d && isRoot3d) {\n        targetMatrix = convertDimension(targetMatrix, 3, 4);\n        matrixes.forEach((matrix, i) => {\n            matrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n    if (is3d && !isRoot3d) {\n        rootMatrixes.forEach((matrix, i) => {\n            rootMatrixes[i] = convertDimension(matrix, 3, 4);\n        });\n    }\n\n    // rootMatrix = (...) -> container -> offset -> absolute -> offset -> absolute(targetMatrix)\n    // beforeMatrix = (... -> container -> offset -> absolute) -> offset -> absolute(targetMatrix)\n    // offsetMatrix = (... -> container -> offset -> absolute -> offset) -> absolute(targetMatrix)\n\n    if (!prevRootMatrix) {\n        rootMatrixes.forEach(matrix => {\n            rootMatrix = multiply(rootMatrix, matrix, n);\n        });\n    }\n    matrixes.forEach((matrix, i) => {\n        if (length - 2 === i) {\n            // length - 3\n            beforeMatrix = allMatrix.slice();\n        }\n        if (length - 1 === i) {\n            // length - 2\n            offsetMatrix = allMatrix.slice();\n        }\n\n        // caculate for SVGElement\n        if (isObject(matrix[n - 1])) {\n            [matrix[n - 1], matrix[2 * n - 1]] =\n                getSVGOffset(\n                    matrix[n - 1] as any,\n                    endContainer,\n                    n,\n                    matrix[2 * n - 1] as any,\n                    allMatrix,\n                    matrixes[i + 1],\n                );\n        }\n        allMatrix = multiply(allMatrix, matrix, n);\n    });\n    const isMatrix3d = !isSVGGraphicElement && is3d;\n\n    if (!targetMatrix) {\n        targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);\n    }\n    const transform = `${isMatrix3d ? \"matrix3d\" : \"matrix\"}(${\n        convertMatrixtoCSS(isSVGGraphicElement && targetMatrix.length === 16\n            ? convertDimension(targetMatrix, 4, 3) : targetMatrix)\n        })`;\n\n    rootMatrix = ignoreDimension(rootMatrix, n, n);\n    return [\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        allMatrix,\n        targetMatrix,\n        transform,\n        transformOrigin,\n        is3d || isRoot3d,\n    ];\n}\nexport function getSVGMatrix(\n    el: SVGSVGElement,\n    n: number,\n) {\n    const clientWidth = el.clientWidth;\n    const clientHeight = el.clientHeight;\n    const viewBox = (el as SVGSVGElement).viewBox.baseVal;\n    const viewBoxWidth = viewBox.width || clientWidth;\n    const viewBoxHeight = viewBox.height || clientHeight;\n    const scaleX = clientWidth / viewBoxWidth;\n    const scaleY = clientHeight / viewBoxHeight;\n\n    const preserveAspectRatio = (el as SVGSVGElement).preserveAspectRatio.baseVal;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio\n    const align = preserveAspectRatio.align;\n    // 1 : meet 2: slice\n    const meetOrSlice = preserveAspectRatio.meetOrSlice;\n    const svgOrigin = [0, 0];\n    const scale = [scaleX, scaleY];\n    const translate = [0, 0];\n\n    if (align !== 1) {\n        const xAlign = (align - 2) % 3;\n        const yAlign = Math.floor((align - 2) / 3);\n\n        svgOrigin[0] = viewBoxWidth * xAlign / 2;\n        svgOrigin[1] = viewBoxHeight * yAlign / 2;\n\n        const scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);\n\n        scale[0] = scaleDimension;\n        scale[1] = scaleDimension;\n\n        translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;\n        translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;\n    }\n\n    const scaleMatrix = createScaleMatrix(scale, n);\n    [\n        scaleMatrix[n - 1],\n        scaleMatrix[2 * n - 1],\n    ] = translate;\n\n    return getAbsoluteMatrix(\n        scaleMatrix,\n        n,\n        svgOrigin,\n    );\n}\nexport function getSVGGraphicsOffset(\n    el: SVGGraphicsElement,\n    origin: number[],\n) {\n    if (!el.getBBox) {\n        return [0, 0];\n    }\n    const bbox = el.getBBox();\n    const svgElement = el.ownerSVGElement!;\n    const viewBox = svgElement.viewBox.baseVal;\n    const left = bbox.x - viewBox.x;\n    const top = bbox.y - viewBox.y;\n\n    return [\n        left,\n        top,\n        origin[0] - left,\n        origin[1] - top,\n    ];\n}\nexport function caculatePosition(matrix: number[], pos: number[], n: number) {\n    return caculate(matrix, convertPositionMatrix(pos, n), n);\n}\nexport function caculatePoses(matrix: number[], width: number, height: number, n: number) {\n    const pos1 = caculatePosition(matrix, [0, 0], n);\n    const pos2 = caculatePosition(matrix, [width, 0], n);\n    const pos3 = caculatePosition(matrix, [0, height], n);\n    const pos4 = caculatePosition(matrix, [width, height], n);\n\n    return [pos1, pos2, pos3, pos4];\n}\nexport function getRect(poses: number[][]) {\n    const posesX = poses.map(pos => pos[0]);\n    const posesY = poses.map(pos => pos[1]);\n    const left = Math.min(...posesX);\n    const top = Math.min(...posesY);\n    const right = Math.max(...posesX);\n    const bottom = Math.max(...posesY);\n    const rectWidth = right - left;\n    const rectHeight = bottom - top;\n\n    return {\n        left, top,\n        right, bottom,\n        width: rectWidth,\n        height: rectHeight,\n    };\n}\nexport function caculateRect(matrix: number[], width: number, height: number, n: number) {\n    const poses = caculatePoses(matrix, width, height, n);\n\n    return getRect(poses);\n}\nexport function getSVGOffset(\n    el: SVGElement,\n    container: HTMLElement | SVGElement,\n    n: number, origin: number[], beforeMatrix: number[], absoluteMatrix: number[]) {\n\n    const [width, height] = getSize(el);\n    const containerClientRect = container.getBoundingClientRect();\n    const rect = el.getBoundingClientRect();\n    const rectLeft = rect.left - containerClientRect.left + container.scrollLeft;\n    const rectTop = rect.top - containerClientRect.top + container.scrollTop;\n    const rectWidth = rect.width;\n    const rectHeight = rect.height;\n    const mat = multiplies(\n        n,\n        beforeMatrix,\n        absoluteMatrix,\n    );\n    const {\n        left: prevLeft,\n        top: prevTop,\n        width: prevWidth,\n        height: prevHeight,\n    } = caculateRect(mat, width, height, n);\n    const posOrigin = caculatePosition(mat, origin, n);\n    const prevOrigin = minus(posOrigin, [prevLeft, prevTop]);\n    const rectOrigin = [\n        rectLeft + prevOrigin[0] * rectWidth / prevWidth,\n        rectTop + prevOrigin[1] * rectHeight / prevHeight,\n    ];\n    const offset = [0, 0];\n    let count = 0;\n\n    while (++count < 10) {\n        const inverseBeforeMatrix = invert(beforeMatrix, n);\n        [offset[0], offset[1]] = minus(\n            caculatePosition(inverseBeforeMatrix, rectOrigin, n),\n            caculatePosition(inverseBeforeMatrix, posOrigin, n),\n        );\n        const mat2 = multiplies(\n            n,\n            beforeMatrix,\n            createOriginMatrix(offset, n),\n            absoluteMatrix,\n        );\n        const {\n            left: nextLeft,\n            top: nextTop,\n        } = caculateRect(mat2, width, height, n);\n        const distLeft = nextLeft - rectLeft;\n        const distTop = nextTop - rectTop;\n\n        if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {\n            break;\n        }\n        rectOrigin[0] -= distLeft;\n        rectOrigin[1] -= distTop;\n    }\n    return offset.map(p => Math.round(p));\n}\nexport function caculateMoveablePosition(matrix: number[], origin: number[], width: number, height: number): [\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    number[],\n    1 | -1,\n] {\n    const is3d = matrix.length === 16;\n    const n = is3d ? 4 : 3;\n    let [\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n    ] = caculatePoses(matrix, width, height, n);\n    let [originX, originY] = caculatePosition(matrix, origin, n);\n\n    const left = Math.min(x1, x2, x3, x4);\n    const top = Math.min(y1, y2, y3, y4);\n    const right = Math.max(x1, x2, x3, x4);\n    const bottom = Math.max(y1, y2, y3, y4);\n\n    x1 = (x1 - left) || 0;\n    x2 = (x2 - left) || 0;\n    x3 = (x3 - left) || 0;\n    x4 = (x4 - left) || 0;\n\n    y1 = (y1 - top) || 0;\n    y2 = (y2 - top) || 0;\n    y3 = (y3 - top) || 0;\n    y4 = (y4 - top) || 0;\n\n    originX = (originX - left) || 0;\n    originY = (originY - top) || 0;\n\n    const center = [\n        (x1 + x2 + x3 + x4) / 4,\n        (y1 + y2 + y3 + y4) / 4,\n    ];\n    const pos1Rad = getRad(center, [x1, y1]);\n    const pos2Rad = getRad(center, [x2, y2]);\n    const direction =\n        (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n            ? 1 : -1;\n\n    return [\n        [left, top, right, bottom],\n        [originX, originY],\n        [x1, y1],\n        [x2, y2],\n        [x3, y3],\n        [x4, y4],\n        direction,\n    ];\n}\nexport function getDistSize(vec: number[]) {\n    return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);\n}\nexport function getDiagonalSize(pos1: number[], pos2: number[]) {\n    return getDistSize([\n        pos2[0] - pos1[0],\n        pos2[1] - pos1[1],\n    ]);\n}\nexport function getLineStyle(pos1: number[], pos2: number[], rad: number = getRad(pos1, pos2)) {\n    const width = getDiagonalSize(pos1, pos2);\n\n    return {\n        transform: `translateY(-50%) translate(${pos1[0]}px, ${pos1[1]}px) rotate(${rad}rad)`,\n        width: `${width}px`,\n    };\n}\nexport function getControlTransform(rotation: number, ...poses: number[][]) {\n    const length = poses.length;\n\n    const x = poses.reduce((prev, pos) => prev + pos[0], 0) / length;\n    const y = poses.reduce((prev, pos) => prev + pos[1], 0) / length;\n    return {\n        transform: `translate(${x}px, ${y}px) rotate(${rotation}rad)`,\n    };\n}\nexport function getCSSSize(target: SVGElement | HTMLElement) {\n    const style = window.getComputedStyle(target);\n\n    return [\n        parseFloat(style.width!),\n        parseFloat(style.height!),\n    ];\n}\nexport function getSize(\n    target: SVGElement | HTMLElement,\n    style: CSSStyleDeclaration = window.getComputedStyle(target),\n    isOffset?: boolean,\n    isBoxSizing: boolean = isOffset || style.boxSizing === \"border-box\",\n) {\n    let width = (target as HTMLElement).offsetWidth;\n    let height = (target as HTMLElement).offsetHeight;\n    const hasOffset = !isUndefined(width);\n\n    if ((isOffset || isBoxSizing) && hasOffset) {\n        return [width, height];\n    }\n    width = target.clientWidth;\n    height = target.clientHeight;\n\n    if (!hasOffset && !width && !height) {\n        const bbox = (target as SVGGraphicsElement).getBBox();\n\n        return [bbox.width, bbox.height];\n    }\n    if (isOffset || isBoxSizing) {\n        const borderLeft = parseFloat(style.borderLeftWidth!) || 0;\n        const borderRight = parseFloat(style.borderRightWidth!) || 0;\n        const borderTop = parseFloat(style.borderTopWidth!) || 0;\n        const borderBottom = parseFloat(style.borderBottomWidth!) || 0;\n\n        return [\n            width + borderLeft + borderRight,\n            height + borderTop + borderBottom,\n        ];\n    } else {\n        const paddingLeft = parseFloat(style.paddingLeft!) || 0;\n        const paddingRight = parseFloat(style.paddingRight!) || 0;\n        const paddingTop = parseFloat(style.paddingTop!) || 0;\n        const paddingBottom = parseFloat(style.paddingBottom!) || 0;\n\n        return [\n            width - paddingLeft - paddingRight,\n            height - paddingTop - paddingBottom,\n        ];\n    }\n}\nexport function getRotationRad(\n    poses: number[][],\n    direction: number,\n) {\n    return getRad(direction > 0 ? poses[0] : poses[1], direction > 0 ? poses[1] : poses[0]);\n}\nexport function getTargetInfo(\n    target?: HTMLElement | SVGElement,\n    container?: HTMLElement | SVGElement | null,\n    parentContainer?: HTMLElement | SVGElement | null,\n    rootContainer?: HTMLElement | SVGElement | null,\n    state?: Partial<MoveableManagerState> | false | undefined,\n): Partial<MoveableManagerState> {\n    let left = 0;\n    let top = 0;\n    let right = 0;\n    let bottom = 0;\n    let origin = [0, 0];\n    let pos1 = [0, 0];\n    let pos2 = [0, 0];\n    let pos3 = [0, 0];\n    let pos4 = [0, 0];\n    let rootMatrix = createIdentityMatrix3();\n    let offsetMatrix = createIdentityMatrix3();\n    let beforeMatrix = createIdentityMatrix3();\n    let matrix = createIdentityMatrix3();\n    let targetMatrix = createIdentityMatrix3();\n    let width = 0;\n    let height = 0;\n    let transformOrigin = [0, 0];\n    let direction: 1 | -1 = 1;\n    let beforeDirection: 1 | -1 = 1;\n    let is3d = false;\n    let targetTransform = \"\";\n    let beforeOrigin = [0, 0];\n    let targetClientRect = resetClientRect();\n    let containerClientRect = resetClientRect();\n    let rotation = 0;\n\n    const prevMatrix = state ? state.beforeMatrix : undefined;\n    const prevRootMatrix = state ? state.rootMatrix : undefined;\n    const prevN = state ? (state.is3d ? 4 : 3) : undefined;\n\n    if (target) {\n        if (state) {\n            width = state.width!;\n            height = state.height!;\n        } else {\n            const style = getComputedStyle(target);\n\n            width = (target as HTMLElement).offsetWidth;\n            height = (target as HTMLElement).offsetHeight;\n\n            if (isUndefined(width)) {\n                [width, height] = getSize(target, style, true);\n            }\n        }\n        [\n            rootMatrix,\n            beforeMatrix,\n            offsetMatrix,\n            matrix,\n            targetMatrix,\n            targetTransform, transformOrigin, is3d,\n        ] = caculateMatrixStack(\n            target, container!, rootContainer!,\n            prevMatrix, prevRootMatrix, prevN,\n        );\n\n        [\n            [left, top, right, bottom],\n            origin,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            direction,\n        ] = caculateMoveablePosition(matrix, transformOrigin, width, height);\n\n        const n = is3d ? 4 : 3;\n        let beforePos = [0, 0];\n\n        [\n            beforePos, beforeOrigin, , , , , beforeDirection,\n        ] = caculateMoveablePosition(offsetMatrix, plus(transformOrigin, getOrigin(targetMatrix, n)), width, height);\n\n        beforeOrigin = [\n            beforeOrigin[0] + beforePos[0] - left,\n            beforeOrigin[1] + beforePos[1] - top,\n        ];\n\n        targetClientRect = getClientRect(target);\n        containerClientRect = getClientRect(\n            getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body,\n            true,\n        );\n        rotation = getRotationRad([pos1, pos2], direction);\n    }\n\n    return {\n        rotation,\n        targetClientRect,\n        containerClientRect,\n        beforeDirection,\n        direction,\n        target,\n        left,\n        top,\n        right,\n        bottom,\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n        width,\n        height,\n        rootMatrix,\n        beforeMatrix,\n        offsetMatrix,\n        targetMatrix,\n        matrix,\n        targetTransform,\n        is3d,\n        beforeOrigin,\n        origin,\n        transformOrigin,\n    };\n}\nexport function resetClientRect(): MoveableClientRect {\n    return {\n        left: 0, right: 0,\n        top: 0, bottom: 0,\n        width: 0, height: 0,\n        clientWidth: 0, clientHeight: 0,\n        scrollWidth: 0, scrollHeight: 0,\n    };\n}\nexport function getClientRect(el: HTMLElement | SVGElement, isExtends?: boolean) {\n    const { left, width, top, bottom, right, height } = el.getBoundingClientRect();\n\n    const rect: MoveableClientRect = {\n        left,\n        right,\n        top,\n        bottom,\n        width,\n        height,\n    };\n\n    if (isExtends) {\n        rect.clientWidth = el.clientWidth;\n        rect.clientHeight = el.clientHeight;\n        rect.scrollWidth = el.scrollWidth;\n        rect.scrollHeight = el.scrollHeight;\n    }\n    return rect;\n}\nexport function getDirection(target: SVGElement | HTMLElement) {\n    if (!target) {\n        return;\n    }\n    const direciton = target.getAttribute(\"data-direction\")!;\n\n    if (!direciton) {\n        return;\n    }\n    const dir = [0, 0];\n\n    (direciton.indexOf(\"w\") > -1) && (dir[0] = -1);\n    (direciton.indexOf(\"e\") > -1) && (dir[0] = 1);\n    (direciton.indexOf(\"n\") > -1) && (dir[1] = -1);\n    (direciton.indexOf(\"s\") > -1) && (dir[1] = 1);\n\n    return dir;\n}\nexport function getAbsolutePoses(poses: number[][], dist: number[]) {\n    return [\n        plus(dist, poses[0]),\n        plus(dist, poses[1]),\n        plus(dist, poses[2]),\n        plus(dist, poses[3]),\n    ];\n}\nexport function getAbsolutePosesByState({\n    left,\n    top,\n    pos1,\n    pos2,\n    pos3,\n    pos4,\n}: {\n    left: number,\n    top: number,\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n}) {\n    return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);\n}\nexport function roundSign(num: number) {\n    return Math.round(num % 1 === -0.5 ? num - 1 : num);\n}\nexport function throttle(num: number, unit: number) {\n    if (!unit) {\n        return num;\n    }\n    return Math.round(num / unit) * unit;\n}\nexport function throttleArray(nums: number[], unit: number) {\n    nums.forEach((_, i) => {\n        nums[i] = throttle(nums[i], unit);\n    });\n    return nums;\n}\n\nexport function unset(self: any, name: string) {\n    if (self[name]) {\n        self[name].unset();\n        self[name] = null;\n    }\n}\n\nexport function getOrientationDirection(pos: number[], pos1: number[], pos2: number[]) {\n    return (pos[0] - pos1[0]) * (pos2[1] - pos1[1]) - (pos[1] - pos1[1]) * (pos2[0] - pos1[0]);\n}\nexport function isInside(pos: number[], pos1: number[], pos2: number[], pos3: number[], pos4: number[]) {\n    const k1 = getOrientationDirection(pos, pos1, pos2);\n    const k2 = getOrientationDirection(pos, pos2, pos4);\n    const k3 = getOrientationDirection(pos, pos4, pos1);\n\n    const k4 = getOrientationDirection(pos, pos2, pos4);\n    const k5 = getOrientationDirection(pos, pos4, pos3);\n    const k6 = getOrientationDirection(pos, pos3, pos2);\n    const signs1 = [k1, k2, k3];\n    const signs2 = [k4, k5, k6];\n\n    if (\n        signs1.every(sign => sign >= 0)\n        || signs1.every(sign => sign <= 0)\n        || signs2.every(sign => sign >= 0)\n        || signs2.every(sign => sign <= 0)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nexport function fillParams<T extends IObject<any>>(\n    moveable: MoveableManager,\n    e: any,\n    params: Pick<T, Exclude<keyof T, \"target\" | \"clientX\" | \"clientY\" | \"inputEvent\" | \"datas\" | \"currentTarget\">>,\n): T {\n    const datas = e.datas;\n\n    if (!datas.datas) {\n        datas.datas = {};\n    }\n    return {\n        ...params,\n        target: moveable.state.target,\n        clientX: e.clientX,\n        clientY: e.clientY,\n        inputEvent: e.inputEvent,\n        currentTarget: moveable,\n        datas: datas.datas,\n    } as any;\n}\n\nexport function triggerEvent<T extends IObject<any>, U extends keyof T>(\n    moveable: MoveableManager<T>,\n    name: U & string,\n    params: T[U] extends ((e: infer P) => any) | undefined ? P : {},\n): any {\n    return moveable.triggerEvent(name, params);\n}\n\nexport function getComputedStyle(el: HTMLElement | SVGElement, pseudoElt?: string | null) {\n    return window.getComputedStyle(el, pseudoElt);\n}\n\nexport function filterAbles(ables: Able[], methods: Array<keyof Able>) {\n    const enabledAbles: IObject<boolean> = {};\n    const ableGroups: IObject<boolean> = {};\n\n    return ables.filter(able => {\n        const name = able.name;\n\n        if (enabledAbles[name] || !methods.some(method => able[method])) {\n            return false;\n        }\n        if (able.ableGroup) {\n            if (ableGroups[able.ableGroup]) {\n                return false;\n            }\n            ableGroups[able.ableGroup] = true;\n        }\n        enabledAbles[name] = true;\n        return true;\n    });\n}\n\nexport function getKeepRatioHeight(width: number, isWidth: boolean, ratio: number) {\n    return width * (isWidth ? ratio : 1 / ratio);\n}\nexport function getKeepRatioWidth(height: number, isWidth: boolean, ratio: number) {\n    return height * (isWidth ? 1 / ratio : ratio);\n}\n\nexport function equals(a1: any, a2: any) {\n    return a1 === a2 || (a1 == null && a2 == null);\n}\n\nexport function selectValue<T = any>(...values: any[]): T {\n    const length = values.length - 1;\n    for (let i = 0; i < length; ++i) {\n        const value = values[i];\n\n        if (!isUndefined(value)) {\n            return value;\n        }\n    }\n\n    return values[length];\n}\n\nexport function groupBy<T>(arr: T[], func: (el: T, index: number, arr: T[]) => number | string) {\n    const group: T[][] = [];\n    const groupMap: IObject<T[]> = {};\n\n    arr.forEach((el, index) => {\n        const groupKey = func(el, index, arr);\n\n        if (!groupMap[groupKey]) {\n            groupMap[groupKey] = [];\n            group.push(groupMap[groupKey]);\n        }\n        groupMap[groupKey].push(el);\n    });\n    return group;\n}\n\nexport function flat<T>(arr: T[][]): T[] {\n    return arr.reduce((prev, cur) => {\n        return prev.concat(cur);\n    }, []);\n}\n\nexport function equalSign(a: number, b: number) {\n    return (a >= 0 && b >= 0) || (a < 0 && b < 0);\n}\n\nexport function maxOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(b) - Math.abs(a));\n\n    return args[0];\n}\nexport function miinOffset(...args: number[]) {\n    args.sort((a, b) => Math.abs(a) - Math.abs(b));\n\n    return args[0];\n}\n\nexport function convertDragDist(state: MoveableManagerState, e: any) {\n    const {\n        is3d,\n        rootMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n    [\n        e.distX, e.distY,\n    ] = caculate(\n        invert(rootMatrix, n),\n        convertPositionMatrix([e.distX, e.distY], n),\n        n,\n    );\n\n    return e;\n}\n","import MoveableManager from \"../MoveableManager\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function triggerRenderStart(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}Start`, params);\n}\nexport function triggerRender(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.isPinch,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}`, params);\n}\nexport function triggerRenderEnd(\n    moveable: MoveableManager<any>,\n    isGroup: boolean,\n    e: any,\n) {\n    const params: IObject<any> = fillParams(moveable, e, {\n        isPinch: !!e.sPinch,\n        isDrag: e.isDrag,\n    });\n\n    const eventAffix = isGroup ? \"Group\" : \"\";\n\n    if (isGroup) {\n        params.targets = moveable.props.targets;\n    }\n    triggerEvent(moveable, `onRender${eventAffix}End`, params);\n}\n","import MoveableManager from \"./MoveableManager\";\nimport Dragger from \"@daybrush/drag\";\nimport { Able } from \"./types\";\nimport { IObject } from \"@daybrush/utils\";\nimport { triggerRenderStart, triggerRenderEnd, triggerRender } from \"./ables/triggerRender\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { convertDragDist } from \"./utils\";\n\nexport function triggerAble<T extends IObject<any>>(\n    moveable: MoveableManager<any>,\n    ableType: string,\n    eventOperation: string,\n    eventAffix: string,\n    eventType: any,\n    e: any,\n    isReqeust?: boolean,\n) {\n    const isStart = eventType === \"Start\";\n\n    if (isStart && eventAffix.indexOf(\"Control\") > -1 && !e.isRequest && moveable.areaElement === e.inputEvent.target) {\n        return false;\n    }\n    const eventName = `${eventOperation}${eventAffix}${eventType}`;\n    const conditionName = `${eventOperation}${eventAffix}Condition`;\n    const isEnd = eventType === \"End\";\n    const isAfter = eventType.indexOf(\"After\") > -1;\n\n    if (isStart) {\n        moveable.updateRect(eventType, true, false);\n    }\n    if (eventType === \"\" && !isAfter) {\n       convertDragDist(moveable.state, e);\n    }\n    const isGroup = eventAffix.indexOf(\"Group\") > -1;\n    const ables: Array<Able<T>> = (moveable as any)[ableType];\n    const events = ables.filter((able: any) => able[eventName]);\n    const results = events.filter((able: any) => {\n        const condition = isStart && able[conditionName];\n\n        if (!condition || condition(e, moveable)) {\n            return able[eventName](moveable, e);\n        }\n        return false;\n    });\n    const isUpdate = results.length;\n\n    if (isStart) {\n        if (events.length && !isUpdate) {\n            moveable.state.dragger = null;\n\n            if ((moveable as MoveableGroup).moveables) {\n                (moveable as MoveableGroup).moveables.forEach(childeMoveable => {\n                    childeMoveable.state.dragger = null;\n                });\n            }\n            return false;\n        }\n        triggerRenderStart(moveable, isGroup, e);\n    } else if (isEnd) {\n        triggerRenderEnd(moveable, isGroup, e);\n    } else if (isUpdate) {\n        triggerRender(moveable, isGroup, e);\n    }\n    if (isEnd) {\n        moveable.state.dragger = null;\n    }\n    if (!isStart && isUpdate) {\n        if (results.some(able => able.updateRect) && !isGroup) {\n            moveable.updateRect(eventType, false, false);\n        } else {\n            moveable.updateRect(eventType, true, false);\n        }\n    }\n    if (((!isStart && isUpdate) || (isEnd && !isUpdate)) && !isReqeust) {\n        moveable.forceUpdate();\n    }\n    if (!isStart && !isEnd && !isAfter && isUpdate) {\n        triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + \"After\", e);\n    }\n}\nexport function getAbleDragger<T>(\n    moveable: MoveableManager<T>,\n    target: HTMLElement | SVGElement,\n    ableType: string,\n    eventAffix: string,\n) {\n    const options: IObject<any> = {\n        container: window,\n        pinchThreshold: moveable.props.pinchThreshold,\n    };\n    [\"drag\", \"pinch\"].forEach(eventOperation => {\n        [\"Start\", \"\", \"End\"].forEach(eventType => {\n            options[`${eventOperation}${eventType.toLowerCase()}`]\n                = (e: any) => triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e);\n        });\n    });\n\n    return new Dragger(target!, options);\n}\n","import * as React from \"react\";\nimport { MOVEABLE_CSS, PREFIX } from \"./consts\";\nimport {\n    prefix, getLineStyle,\n    getTargetInfo,\n    unset,\n    createIdentityMatrix3,\n    isInside,\n    getAbsolutePosesByState,\n    getRect,\n    filterAbles,\n    equals,\n    resetClientRect,\n    throttle,\n    flat,\n} from \"./utils\";\nimport styled from \"react-css-styled\";\nimport Dragger from \"@daybrush/drag\";\nimport { ref } from \"framework-utils\";\nimport { MoveableManagerProps, MoveableManagerState, Able, RectInfo, Requester } from \"./types\";\nimport { getAbleDragger, triggerAble } from \"./getAbleDragger\";\nimport CustomDragger from \"./CustomDragger\";\nimport { getRad, plus } from \"@moveable/matrix\";\nimport { IObject } from \"@daybrush/utils\";\n\nconst ControlBoxElement = styled(\"div\", MOVEABLE_CSS);\n\nfunction renderLine(direction: string, pos1: number[], pos2: number[], index: number) {\n    const rad = getRad(pos1, pos2);\n    const rotation = direction ? (throttle(rad / Math.PI * 180, 15)) % 180 : -1;\n\n    return <div key={`line${index}`} className={prefix(\"line\", \"direction\", direction)}\n        data-rotation={rotation}\n        data-direction={direction} style={getLineStyle(pos1, pos2, rad)}></div>;\n}\nexport default class MoveableManager<T = {}, U = {}>\n    extends React.PureComponent<MoveableManagerProps<T>, MoveableManagerState<U>> {\n    public static defaultProps: Required<MoveableManagerProps> = {\n        target: null,\n        container: null,\n        rootContainer: null,\n        origin: true,\n        edge: false,\n        parentMoveable: null,\n        parentPosition: null,\n        ables: [],\n        pinchThreshold: 20,\n        dragArea: false,\n        transformOrigin: \"\",\n        className: \"\",\n        zoom: 1,\n    };\n    public state: MoveableManagerState<U> = {\n        container: null,\n        target: null,\n        beforeMatrix: createIdentityMatrix3(),\n        matrix: createIdentityMatrix3(),\n        targetMatrix: createIdentityMatrix3(),\n        targetTransform: \"\",\n        is3d: false,\n        left: 0,\n        top: 0,\n        width: 0,\n        height: 0,\n        transformOrigin: [0, 0],\n        direction: 1,\n        beforeDirection: 1,\n        beforeOrigin: [0, 0],\n        origin: [0, 0],\n        pos1: [0, 0],\n        pos2: [0, 0],\n        pos3: [0, 0],\n        pos4: [0, 0],\n        targetClientRect: resetClientRect(),\n        containerClientRect: resetClientRect(),\n        rotation: 0,\n    } as any;\n    public targetAbles: Array<Able<T>> = [];\n    public controlAbles: Array<Able<T>> = [];\n    public controlBox!: typeof ControlBoxElement extends new (...args: any[]) => infer K ? K : never;\n    public areaElement!: HTMLElement;\n    public targetDragger!: Dragger;\n    public controlDragger!: Dragger;\n    public customDragger!: CustomDragger;\n\n    public render() {\n        const props = this.props;\n        const { edge, parentPosition, className, target: propsTarget, zoom } = this.props;\n\n        this.checkUpdate();\n\n        const { left: parentLeft, top: parentTop } = parentPosition! || { left: 0, top: 0 };\n        const { left, top, pos1, pos2, pos3, pos4, target: stateTarget, direction } = this.state;\n        const groupTargets = (props as any).targets;\n        const isDisplay = ((groupTargets && groupTargets.length) || propsTarget) && stateTarget;\n\n        return (\n            <ControlBoxElement\n                ref={ref(this, \"controlBox\")}\n                className={`${prefix(\"control-box\", direction === -1 ? \"reverse\" : \"\")} ${className}`} style={{\n                    \"position\": \"absolute\",\n                    \"display\": isDisplay ? \"block\" : \"none\",\n                    \"transform\": `translate(${left - parentLeft}px, ${top - parentTop}px) translateZ(50px)`,\n                    \"--zoom\": zoom,\n                    \"--zoompx\": `${zoom}px`,\n                }}>\n                {this.renderAbles()}\n                {renderLine(edge ? \"n\" : \"\", pos1, pos2, 0)}\n                {renderLine(edge ? \"e\" : \"\", pos2, pos4, 1)}\n                {renderLine(edge ? \"w\" : \"\", pos1, pos3, 2)}\n                {renderLine(edge ? \"s\" : \"\", pos3, pos4, 3)}\n            </ControlBoxElement>\n        );\n    }\n    public componentDidMount() {\n        this.controlBox.getElement();\n        const props = this.props;\n        const { parentMoveable, container } = props;\n\n        this.updateEvent(props);\n        if (!container && !parentMoveable) {\n            this.updateRect(\"End\", false, true);\n        }\n    }\n    public componentDidUpdate(prevProps: MoveableManagerProps<T>) {\n        this.updateEvent(prevProps);\n    }\n    public componentWillUnmount() {\n        unset(this, \"targetDragger\");\n        unset(this, \"controlDragger\");\n    }\n    public getContainer(): HTMLElement | SVGElement {\n        const { parentMoveable, container } = this.props;\n\n        return container!\n            || (parentMoveable && parentMoveable.getContainer())\n            || this.controlBox.getElement().parentElement!;\n    }\n    public isMoveableElement(target: HTMLElement | SVGElement) {\n        return target && ((target.getAttribute(\"class\") || \"\").indexOf(PREFIX) > -1);\n    }\n    public dragStart(e: MouseEvent | TouchEvent) {\n        if (this.targetDragger) {\n            this.targetDragger.onDragStart(e);\n        }\n    }\n    public isInside(clientX: number, clientY: number) {\n        const { pos1, pos2, pos3, pos4, target, targetClientRect } = this.state;\n\n        if (!target) {\n            return false;\n        }\n        const { left, top } = targetClientRect;\n        const pos = [clientX - left, clientY - top];\n\n        return isInside(pos, pos1, pos2, pos4, pos3);\n    }\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        const props = this.props;\n        const parentMoveable = props.parentMoveable;\n        const state = this.state;\n        const target = (state.target || this.props.target) as HTMLElement | SVGElement;\n        const container = this.getContainer();\n        const rootContainer = parentMoveable\n            ? parentMoveable.props.rootContainer\n            : props.rootContainer;\n        this.updateState(\n            getTargetInfo(target, container, container, rootContainer || container,\n                isTarget ? state : undefined),\n            parentMoveable ? false : isSetState,\n        );\n    }\n    public updateEvent(prevProps: MoveableManagerProps<T>) {\n        const controlBoxElement = this.controlBox.getElement();\n        const hasTargetAble = this.targetAbles.length;\n        const hasControlAble = this.controlAbles.length;\n        const target = this.props.target;\n        const prevTarget = prevProps.target;\n        const dragArea = this.props.dragArea;\n        const prevDragArea = prevProps.dragArea;\n        const isTargetChanged = !dragArea && prevTarget !== target;\n        const isUnset = (!hasTargetAble && this.targetDragger)\n            || isTargetChanged\n            || prevDragArea !== dragArea;\n\n        if (isUnset) {\n            unset(this, \"targetDragger\");\n            this.updateState({ dragger: null });\n        }\n        if (!hasControlAble) {\n            unset(this, \"controlDragger\");\n        }\n\n        if (target && hasTargetAble && !this.targetDragger) {\n            if (dragArea) {\n                this.targetDragger = getAbleDragger(this, this.areaElement!, \"targetAbles\", \"\");\n            } else {\n                this.targetDragger = getAbleDragger(this, target!, \"targetAbles\", \"\");\n            }\n        }\n        if (!this.controlDragger && hasControlAble) {\n            this.controlDragger = getAbleDragger(this, controlBoxElement, \"controlAbles\", \"Control\");\n        }\n        if (isUnset) {\n            this.unsetAbles();\n        }\n    }\n    public isDragging() {\n        return (this.targetDragger ? this.targetDragger.isFlag() : false)\n        || (this.controlDragger ? this.controlDragger.isFlag() : false);\n    }\n    public updateTarget(type?: \"Start\" | \"\" | \"End\") {\n        this.updateRect(type, true);\n    }\n    public getRect(): RectInfo {\n        const state = this.state;\n        const poses = getAbsolutePosesByState(this.state);\n        const [pos1, pos2, pos3, pos4] = poses;\n        const rect = getRect(poses);\n        const {\n            width: offsetWidth,\n            height: offsetHeight,\n        } = state;\n        const {\n            width,\n            height,\n            left,\n            top,\n        } = rect;\n        const statePos = [state.left, state.top];\n        const origin = plus(statePos, state.origin);\n        const beforeOrigin = plus(statePos, state.beforeOrigin);\n        return {\n            width,\n            height,\n            left,\n            top,\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n            offsetWidth,\n            offsetHeight,\n            beforeOrigin,\n            origin,\n        };\n    }\n    public request(ableName: string, param: IObject<any> = {}, isInstant?: boolean): Requester {\n        const { ables, groupable } = this.props as any;\n        const requsetAble: Able = ables!.filter((able: Able) => able.name === ableName)[0];\n\n        if (this.isDragging() || !requsetAble || !requsetAble.request) {\n            return {\n                request() {\n                    return this;\n                },\n                requestEnd() {\n                    return this;\n                },\n            };\n        }\n        const self = this;\n        const ableRequester = requsetAble.request(this);\n\n        const ableType = ableRequester.isControl ? \"controlAbles\" : \"targetAbles\";\n        const eventAffix  = `${(groupable ? \"Group\" : \"\")}${ableRequester.isControl ? \"Control\" : \"\"}`;\n\n        const requester = {\n            request(ableParam: IObject<any>) {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"\", {\n                    ...ableRequester.request(ableParam),\n                    isRequest: true,\n                }, isInstant);\n                return this;\n            },\n            requestEnd() {\n                triggerAble(self, ableType, \"drag\", eventAffix, \"End\", {\n                    ...ableRequester.requestEnd(),\n                    isRequest: true,\n                });\n                return this;\n            },\n        };\n\n        triggerAble(self, ableType, \"drag\", eventAffix, \"Start\", {\n            ...ableRequester.requestStart(param),\n            isRequest: true,\n        }, isInstant);\n\n        return param.isInstant ? requester.request(param).requestEnd() : requester;\n    }\n    public checkUpdate() {\n        const { target, container, parentMoveable } = this.props;\n        const {\n            target: stateTarget,\n            container: stateContainer,\n        } = this.state;\n\n        if (!stateTarget && !target) {\n            return;\n        }\n        this.updateAbles();\n\n        const isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);\n\n        if (!isChanged) {\n            return;\n        }\n\n        this.updateState({ target, container });\n\n        if (!parentMoveable && (container || this.controlBox)) {\n            this.updateRect(\"End\", false, false);\n        }\n    }\n    public triggerEvent(name: string, e: any): any {\n        const callback = (this.props as any)[name];\n\n        return callback && callback(e);\n    }\n    protected unsetAbles() {\n        if (this.targetAbles.filter(able => {\n            if (able.unset) {\n                able.unset(this);\n                return true;\n            }\n            return false;\n        }).length) {\n            this.forceUpdate();\n        }\n    }\n    protected updateAbles(\n        ables: Able[] = this.props.ables!,\n        eventAffix: string = \"\",\n    ) {\n        const props = this.props as any;\n\n        const enabledAbles = ables!.filter(able => able && props[able.name]);\n\n        const dragStart = `drag${eventAffix}Start` as \"dragStart\";\n        const pinchStart = `pinch${eventAffix}Start` as \"pinchStart\";\n        const dragControlStart = `drag${eventAffix}ControlStart` as \"dragControlStart\";\n\n        const targetAbles = filterAbles(enabledAbles, [dragStart, pinchStart]);\n        const controlAbles = filterAbles(enabledAbles, [dragControlStart]);\n\n        this.targetAbles = targetAbles;\n        this.controlAbles = controlAbles;\n    }\n    protected updateState(nextState: any, isSetState?: boolean) {\n        if (isSetState) {\n            this.setState(nextState);\n        } else {\n            const state = this.state as any;\n\n            for (const name in nextState) {\n                state[name] = nextState[name];\n            }\n        }\n    }\n    protected renderAbles() {\n        const props = this.props as any;\n        const ables: Able[] = props.ables!;\n        const enabledAbles = ables.filter(able => able && props[able.name]);\n        const Renderer = { createElement: React.createElement };\n\n        return flat(filterAbles(enabledAbles, [\"render\"]).map(({ render }) => {\n            return render!(this, Renderer);\n        }));\n    }\n}\n","import { Client } from \"@daybrush/drag\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { PinchableProps, Able, SnappableState, OnPinchStart, OnPinch, OnPinchEnd } from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { getRad } from \"@moveable/matrix\";\n\nfunction getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport default {\n    name: \"pinchable\",\n    updateRect: true,\n    props: {\n        pinchable: Boolean,\n        pinchThreshold: Number,\n    },\n    pinchStart(\n        moveable: MoveableManager<PinchableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, touches, inputEvent, targets } = e;\n        const { pinchable, ables } = moveable.props;\n\n        if (!pinchable) {\n            return false;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}Start` as \"onPinchStart\";\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlStart` as \"dragControlStart\";\n\n        const pinchAbles = (pinchable === true ? moveable.controlAbles : ables!.filter(able => {\n            return pinchable.indexOf(able.name as any) > -1;\n        })).filter(able => able.canPinch && able[controlEventName]);\n\n        const params = fillParams<OnPinchStart>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const result = triggerEvent(moveable, eventName, params);\n\n        datas.isPinch = result !== false;\n        datas.ables = pinchAbles;\n\n        const isPinch = datas.isPinch;\n\n        if (!isPinch) {\n            return false;\n        }\n        const parentRotate = getRotatiion(touches);\n\n        pinchAbles.forEach(able => {\n            datas[able.name + \"Datas\"] = {};\n            const ableEvent: any = {\n                datas: datas[able.name + \"Datas\"],\n                clientX,\n                clientY,\n                inputEvent,\n                parentRotate,\n                pinchFlag: true,\n            };\n            able[controlEventName]!(moveable, ableEvent);\n        });\n\n        moveable.state.snapRenderInfo = {\n            direction: [0, 0],\n        };\n        return isPinch;\n    },\n    pinch(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, scale: pinchScale, distance, touches, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const parentRotate = getRotatiion(touches);\n        const parentDistance = distance * (1 - 1 / pinchScale);\n        const params = fillParams<OnPinch>(moveable, e, {}) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}` as \"onPinch\";\n        triggerEvent(moveable, eventName, params);\n\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}Control` as \"dragControl\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                parentDistance,\n                parentRotate,\n                pinchFlag: true,\n            } as any);\n        });\n        return params;\n    },\n    pinchEnd(\n        moveable: MoveableManager<PinchableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, isPinch, inputEvent, targets } = e;\n        if (!datas.isPinch) {\n            return;\n        }\n        const eventName = `onPinch${targets ? \"Group\" : \"\"}End` as \"onPinchEnd\";\n\n        const params = fillParams<OnPinchEnd>(moveable, e, { isDrag: isPinch }) as any;\n\n        if (targets) {\n            params.targets = targets;\n        }\n        triggerEvent(moveable, eventName, params);\n        const ables: Able[] = datas.ables;\n        const controlEventName = `drag${targets ? \"Group\" : \"\"}ControlEnd` as \"dragControlEnd\";\n\n        ables.forEach(able => {\n            able[controlEventName]!(moveable, {\n                clientX,\n                clientY,\n                isDrag: isPinch,\n                datas: datas[able.name + \"Datas\"],\n                inputEvent,\n                pinchFlag: true,\n            } as any);\n        });\n        return isPinch;\n    },\n    pinchGroupStart(moveable: MoveableGroup, e: any) {\n        return this.pinchStart(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroup(moveable: MoveableGroup, e: any) {\n        return this.pinch(moveable, { ...e, targets: moveable.props.targets });\n    },\n    pinchGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.pinchEnd(moveable, { ...e, targets: moveable.props.targets });\n    },\n};\n","import MoveableGroup from \"./MoveableGroup\";\nimport { Able } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { IObject, isFunction } from \"@daybrush/utils\";\n\nexport function triggerChildAble<T extends Able>(\n    moveable: MoveableGroup,\n    able: T,\n    type: keyof T & string,\n    datas: IObject<any>,\n    eachEvent: ((movebale: MoveableManager, datas: IObject<any>) => any) | IObject<any>,\n    callback?: (moveable: MoveableManager<any>, datas: IObject<any>, result: any, index: number) => any,\n) {\n    const name = able.name!;\n    const ableDatas = datas[name] || (datas[name] = []);\n    const isEnd = !!type.match(/End$/g);\n    const childs = moveable.moveables.map((child, i) => {\n        const childDatas = ableDatas[i] || (ableDatas[i] = {});\n\n        const childEvent = isFunction(eachEvent) ? eachEvent(child, childDatas) : eachEvent;\n        const result = (able as any)[type]!(child,  { ...childEvent, datas: childDatas, parentFlag: true });\n\n        result && callback && callback(child, childDatas, result, i);\n\n        if (isEnd) {\n            child.state.dragger = null;\n        }\n        return result;\n    });\n\n    return childs;\n}\n","import {\n    invert, caculate, minus, plus,\n    convertPositionMatrix, average,\n    createScaleMatrix, multiply,\n} from \"@moveable/matrix\";\nimport MoveableManager from \"./MoveableManager\";\nimport { caculatePoses, getAbsoluteMatrix, getAbsolutePosesByState } from \"./utils\";\nimport { splitUnit } from \"@daybrush/utils\";\nimport { MoveableManagerState, GroupableProps, ResizableProps } from \"./types\";\n\nexport function setDragStart(moveable: MoveableManager<any>, { datas }: any) {\n    const {\n        matrix,\n        beforeMatrix,\n        is3d,\n        left,\n        top,\n        origin,\n        offsetMatrix,\n        targetMatrix,\n        transformOrigin,\n    } = moveable.state;\n    const n = is3d ? 4 : 3;\n\n    datas.is3d = is3d;\n    datas.matrix = matrix;\n    datas.targetMatrix = targetMatrix;\n    datas.beforeMatrix = beforeMatrix;\n    datas.offsetMatrix = offsetMatrix;\n    datas.transformOrigin = transformOrigin;\n    datas.inverseMatrix = invert(matrix, n);\n    datas.inverseBeforeMatrix = invert(beforeMatrix, n);\n    datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);\n    datas.startDragBeforeDist = caculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);\n    datas.startDragDist = caculate(datas.inverseMatrix, datas.absoluteOrigin, n);\n}\nexport function getDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        inverseBeforeMatrix,\n        inverseMatrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? inverseBeforeMatrix : inverseMatrix,\n            plus(absoluteOrigin, [distX, distY]),\n            n,\n        ),\n        isBefore ? startDragBeforeDist : startDragDist,\n    );\n}\nexport function getInverseDragDist({ datas, distX, distY }: any, isBefore?: boolean) {\n    const {\n        beforeMatrix,\n        matrix,\n        is3d,\n        startDragBeforeDist,\n        startDragDist,\n        absoluteOrigin,\n    } = datas;\n    const n = is3d ? 4 : 3;\n\n    return minus(\n        caculate(\n            isBefore ? beforeMatrix : matrix,\n            plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]),\n            n,\n        ),\n        absoluteOrigin,\n    );\n}\nexport function caculateTransformOrigin(\n    transformOrigin: string[],\n    width: number,\n    height: number,\n    prevWidth: number = width,\n    prevHeight: number = height,\n    prevOrigin: number[] = [0, 0],\n) {\n\n    if (!transformOrigin) {\n        return prevOrigin;\n    }\n    return transformOrigin.map((pos, i) => {\n        const { value, unit } = splitUnit(pos);\n\n        const prevSize = (i ? prevHeight : prevWidth);\n        const size = (i ? height : width);\n        if (pos === \"%\" || isNaN(value)) {\n            // no value but %\n\n            const measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;\n\n            return size * measureRatio;\n        } else if (unit !== \"%\") {\n            return value;\n        }\n        return size * value / 100;\n    });\n}\nexport function getPosIndexesByDirection(direction: number[]) {\n    const indexes: number[] = [];\n\n    if (direction[1] >= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(3);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(2);\n        }\n    }\n    if (direction[1] <= 0) {\n        if (direction[0] >= 0) {\n            indexes.push(1);\n        }\n        if (direction[0] <= 0) {\n            indexes.push(0);\n        }\n    }\n    return indexes;\n}\nexport function getPosesByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    return getPosIndexesByDirection(direction).map(index => poses[index]);\n}\nexport function getPosByDirection(\n    poses: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos1)       [0, -1](pos1,pos2)       [1, -1](pos2)\n    [-1, 0](pos1, pos3)                           [1, 0](pos2, pos4)\n    [-1, 1](pos3)        [0, 1](pos3, pos4)       [1, 1](pos4)\n    */\n    const nextPoses = getPosesByDirection(poses, direction);\n\n    return [\n        average(...nextPoses.map(pos => pos[0])),\n        average(...nextPoses.map(pos => pos[1])),\n    ];\n}\nexport function getPosByReverseDirection(\n    [pos1, pos2, pos3, pos4]: number[][],\n    direction: number[],\n) {\n    /*\n    [-1, -1](pos4)       [0, -1](pos3,pos4)       [1, -1](pos3)\n    [-1, 0](pos2, pos4)                           [1, 0](pos3, pos1)\n    [-1, 1](pos2)        [0, 1](pos1, pos2)       [1, 1](pos1)\n    */\n\n    return getPosByDirection([pos4, pos3, pos2, pos1], direction);\n}\nfunction getStartPos(poses: number[][], direction: number[]) {\n    const [\n        startPos1,\n        startPos2,\n        startPos3,\n        startPos4,\n    ] = poses;\n    return getPosByReverseDirection([startPos1, startPos2, startPos3, startPos4], direction);\n}\nfunction getDist(\n    startPos: number[],\n    matrix: number[],\n    width: number,\n    height: number,\n    n: number,\n    direction: number[],\n) {\n    const poses = caculatePoses(matrix, width, height, n);\n    const pos = getPosByReverseDirection(poses, direction);\n    const distX = startPos[0] - pos[0];\n    const distY = startPos[1] - pos[1];\n\n    return [distX, distY];\n}\nexport function getNextMatrix(\n    offsetMatrix: number[],\n    targetMatrix: number[],\n    origin: number[],\n    n: number,\n) {\n    return multiply(\n        offsetMatrix,\n        getAbsoluteMatrix(targetMatrix, n, origin),\n        n,\n    );\n}\nexport function scaleMatrix(\n    state: MoveableManagerState<any>,\n    scale: number[],\n) {\n    const {\n        transformOrigin,\n        offsetMatrix,\n        is3d,\n        targetMatrix,\n    } = state;\n    const n = is3d ? 4 : 3;\n\n    return getNextMatrix(\n        offsetMatrix,\n        multiply(targetMatrix, createScaleMatrix(scale, n), n),\n        transformOrigin,\n        n,\n    );\n}\nexport function getScaleDist(\n    moveable: MoveableManager<any>,\n    scale: number[],\n    direction: number[],\n    dragClient?: number[],\n) {\n    const state = moveable.state;\n    const {\n        is3d,\n        left,\n        top,\n        width,\n        height,\n    } = state;\n\n    const n = is3d ? 4 : 3;\n    const groupable = moveable.props.groupable;\n    const nextMatrix = scaleMatrix(moveable.state, scale);\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n\n    const startPos = dragClient ? dragClient : getStartPos(getAbsolutePosesByState(moveable.state), direction);\n\n    const dist = getDist(\n        startPos, nextMatrix, width, height, n,\n        direction,\n    );\n\n    return minus(dist, [groupLeft, groupTop]);\n}\n\nexport function getResizeDist(\n    moveable: MoveableManager<GroupableProps>,\n    width: number,\n    height: number,\n    // prevWidth: number,\n    // prevHeight: number,\n    direction: number[],\n    fixedPosition: number[],\n    transformOrigin: string[],\n) {\n    const {\n        groupable,\n    } = moveable.props;\n    const {\n        transformOrigin: prevOrigin,\n        targetMatrix,\n        offsetMatrix,\n        is3d,\n        width: prevWidth,\n        height: prevHeight,\n        left,\n        top,\n    } = moveable.state;\n\n    const n = is3d ? 4 : 3;\n    const nextOrigin = caculateTransformOrigin(\n        transformOrigin!,\n        width,\n        height,\n        prevWidth,\n        prevHeight,\n        prevOrigin,\n    );\n    const groupLeft = groupable ? left : 0;\n    const groupTop = groupable ? top : 0;\n    const nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);\n    const dist = getDist(fixedPosition, nextMatrix, width, height, n, direction);\n\n    return minus(dist, [groupLeft, groupTop]);\n}\nexport function getStartDirection(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    if (!direction[0] && !direction[1]) {\n        return [0, 0];\n    }\n    const {\n        baseDirection = [-1, -1],\n    } = moveable.props;\n    return [\n        direction[0] ? direction[0] : baseDirection[0] * -1,\n        direction[1] ? direction[1] : baseDirection[1] * -1,\n    ];\n}\nexport function getAbsoluteFixedPosition(\n    moveable: MoveableManager<ResizableProps>,\n    direction: number[],\n) {\n    return getStartPos(getAbsolutePosesByState(moveable.state), direction);\n}\n","import { prefix } from \"../utils\";\nimport { hasClass } from \"@daybrush/utils\";\n\nexport function directionCondition(e: any) {\n    if (e.isRequest) {\n        return e.parentDirection!!;\n    }\n    return hasClass(e.inputEvent.target, prefix(\"direction\"));\n}\n","import {\n    SnapInfo, SnappableProps, SnappableState,\n    Guideline, ResizableProps, ScalableProps, SnapOffsetInfo\n} from \"../../types\";\nimport MoveableManager from \"../../MoveableManager\";\nimport { selectValue, throttle } from \"../../utils\";\nimport { getPosByDirection, getPosesByDirection } from \"../../DraggerUtils\";\nimport { TINY_NUM } from \"../../consts\";\nimport { minus } from \"@moveable/matrix\";\n\nexport function getTotalGuidelines(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n) {\n    const {\n        guidelines,\n        containerClientRect: {\n            scrollHeight: containerHeight,\n            scrollWidth: containerWidth,\n        },\n    } = moveable.state;\n    const props = moveable.props;\n    const {\n        snapHorizontal = true,\n        snapVertical = true,\n        verticalGuidelines,\n        horizontalGuidelines,\n    } = props;\n\n    const totalGuidelines = [...guidelines];\n\n    if (snapHorizontal && horizontalGuidelines) {\n        horizontalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"horizontal\", pos: [0, throttle(pos, 0.1)], size: containerWidth });\n        });\n    }\n    if (snapVertical && verticalGuidelines) {\n        verticalGuidelines!.forEach(pos => {\n            totalGuidelines.push({ type: \"vertical\", pos: [throttle(pos, 0.1), 0], size: containerHeight });\n        });\n    }\n    return totalGuidelines;\n}\nexport function checkSnapPoses(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    posesX: number[],\n    posesY: number[],\n    snapCenter?: boolean,\n    customSnapThreshold?: number,\n) {\n    const totalGuidelines = getTotalGuidelines(moveable);\n    const props = moveable.props;\n    const {\n        snapElement = true,\n    } = props;\n    const snapThreshold = selectValue<number>(customSnapThreshold, props.snapThreshold, 5);\n\n    return {\n        vertical: checkSnap(\n            totalGuidelines,\n            \"vertical\", posesX, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n        horizontal: checkSnap(\n            totalGuidelines,\n            \"horizontal\", posesY, snapThreshold,\n            snapCenter!,\n            snapElement,\n        ),\n    };\n}\n\nexport function checkSnapKeepRatio(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n): {\n    vertical: SnapOffsetInfo,\n    horizontal: SnapOffsetInfo,\n} {\n    const [endX, endY] = endPos;\n    const [startX, startY] = startPos;\n    const [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo: SnapOffsetInfo = {\n        isSnap: false,\n        offset: 0,\n        pos: 0,\n    };\n\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    }\n    const {\n        vertical: verticalSnapInfo,\n        horizontal: horizontalSnapInfo,\n    } = checkSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []);\n\n    verticalSnapInfo.posInfos.filter(({ pos }) => {\n        return isRight ? pos >= startX : pos <= startX;\n    });\n    horizontalSnapInfo.posInfos.filter(({ pos }) => {\n        return isBottom ? pos >= startY : pos <= startY;\n    });\n    verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;\n    horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;\n\n    const {\n        isSnap: isVerticalSnap,\n        guideline: verticalGuideline,\n    } = getNearestSnapGuidelineInfo(verticalSnapInfo);\n    const {\n        isSnap: isHorizontalSnap,\n        guideline: horizontalGuideline,\n    } = getNearestSnapGuidelineInfo(horizontalSnapInfo);\n    const horizontalPos = isHorizontalSnap ? horizontalGuideline!.pos[1] : 0;\n    const verticalPos = isVerticalSnap ? verticalGuideline!.pos[0] : 0;\n\n    if (dx === 0) {\n        if (isHorizontalSnap) {\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = horizontalGuideline!.pos[1];\n            horizontalInfo.offset = endY - horizontalInfo.pos;\n        }\n    } else if (dy === 0) {\n        if (isVerticalSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = verticalPos;\n            verticalInfo.offset = endX - verticalPos;\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isSnap = false;\n\n        if (isVerticalSnap) {\n            x = verticalPos;\n            y = a * x + b;\n            isSnap = true;\n        } else if (isHorizontalSnap) {\n            y = horizontalPos;\n            x = (y - b) / a;\n            isSnap = true;\n        }\n        if (isSnap) {\n            verticalInfo.isSnap = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isSnap = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\n\nexport function checkSnaps(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    rect: {\n        left?: number,\n        top?: number,\n        bottom?: number,\n        right?: number,\n        center?: number,\n        middle?: number,\n    },\n    isCenter: boolean,\n    customSnapThreshold?: number,\n) {\n    const snapCenter = moveable.props.snapCenter;\n    const isSnapCenter = snapCenter! && isCenter;\n\n    let verticalNames: Array<\"left\" | \"center\" | \"right\"> = [\"left\", \"right\"];\n    let horizontalNames: Array<\"top\" | \"middle\" | \"bottom\"> = [\"top\", \"bottom\"];\n\n    if (isSnapCenter) {\n        verticalNames.push(\"center\");\n        horizontalNames.push(\"middle\");\n    }\n    verticalNames = verticalNames.filter(name => name in rect);\n    horizontalNames = horizontalNames.filter(name => name in rect);\n\n    return checkSnapPoses(\n        moveable,\n        verticalNames.map(name => rect[name]!),\n        horizontalNames.map(name => rect[name]!),\n        isSnapCenter,\n        customSnapThreshold,\n    );\n}\n\nexport function getNearestSnapGuidelineInfo(\n    snapInfo: SnapInfo,\n) {\n    const isSnap = snapInfo.isSnap;\n\n    if (!isSnap) {\n        return {\n            isSnap: false,\n            offset: 0,\n            dist: -1,\n            pos: 0,\n            guideline: null,\n        };\n    }\n    const posInfo = snapInfo.posInfos[0];\n    const guidelineInfo = posInfo!.guidelineInfos[0];\n    const offset = guidelineInfo!.offset;\n    const dist = guidelineInfo!.dist;\n    const guideline = guidelineInfo!.guideline;\n\n    return {\n        isSnap,\n        offset,\n        dist,\n        pos: posInfo!.pos,\n        guideline,\n    };\n}\n\nfunction checkSnap(\n    guidelines: Guideline[],\n    targetType: \"horizontal\" | \"vertical\",\n    targetPoses: number[],\n    snapThreshold: number,\n    snapCenter: boolean,\n    snapElement: boolean,\n): SnapInfo {\n    if (!guidelines || !guidelines.length) {\n        return {\n            isSnap: false,\n            posInfos: [],\n        };\n    }\n    const isVertical = targetType === \"vertical\";\n    const posType = isVertical ? 0 : 1;\n\n    const snapPosInfos = targetPoses.map(targetPos => {\n        const guidelineInfos = guidelines.map(guideline => {\n            const { pos } = guideline;\n            const offset = targetPos - pos[posType];\n\n            return {\n                offset,\n                dist: Math.abs(offset),\n                guideline,\n            };\n        }).filter(({ guideline, dist }) => {\n            const { type, center, element } = guideline;\n            if (\n                (!snapElement && element)\n                || (!snapCenter && center)\n                || type !== targetType\n                || dist > snapThreshold\n            ) {\n                return false;\n            }\n            return true;\n        }).sort(\n            (a, b) => a.dist - b.dist,\n        );\n\n        return {\n            pos: targetPos,\n            guidelineInfos,\n        };\n    }).filter(snapPosInfo => {\n        return snapPosInfo.guidelineInfos.length > 0;\n    }).sort((a, b) => {\n        return a.guidelineInfos[0].dist - b.guidelineInfos[0].dist;\n    });\n\n    return {\n        isSnap: snapPosInfos.length > 0,\n        posInfos: snapPosInfos,\n    };\n}\n\nexport function getSnapInfosByDirection(\n    moveable: MoveableManager<SnappableProps & (ResizableProps | ScalableProps), SnappableState>,\n    poses: number[][],\n    snapDirection: number[],\n) {\n    let nextPoses = [];\n    if (snapDirection[0] && snapDirection[1]) {\n        nextPoses = [\n            snapDirection,\n            [-snapDirection[0], snapDirection[1]],\n            [snapDirection[0], -snapDirection[1]],\n        ].map(direction => getPosByDirection(poses, direction));\n    } else if (!snapDirection[0] && !snapDirection[1]) {\n        const alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];\n\n        for (let i = 0; i < 4; ++i) {\n            nextPoses.push(alignPoses[i]);\n            nextPoses.push([\n                (alignPoses[i][0] + alignPoses[i + 1][0]) / 2,\n                (alignPoses[i][1] + alignPoses[i + 1][1]) / 2,\n            ]);\n        }\n    } else {\n        if (moveable.props.keepRatio) {\n            nextPoses = [\n                [-1, -1],\n                [-1, 1],\n                [1, -1],\n                [1, 1],\n                snapDirection,\n            ].map(dir => getPosByDirection(poses, dir));\n        } else {\n            nextPoses = getPosesByDirection(poses, snapDirection);\n\n            if (nextPoses.length > 1) {\n                nextPoses.push([\n                    (nextPoses[0][0] + nextPoses[1][0]) / 2,\n                    (nextPoses[0][1] + nextPoses[1][1]) / 2,\n                ]);\n            }\n        }\n    }\n    return checkSnapPoses(moveable, nextPoses.map(pos => pos[0]), nextPoses.map(pos => pos[1]), true, 1);\n}\n\nexport function getNearOffsetInfo<T extends { offset: number[], isBound: boolean, isSnap: boolean, sign: number[] }>(\n    offsets: T[],\n    index: number,\n) {\n    return offsets.slice().sort((a, b) => {\n        const aSign = a.sign[index];\n        const bSign = b.sign[index];\n        const aOffset = a.offset[index];\n        const bOffset = b.offset[index];\n        const aDist = Math.abs(aOffset);\n        const bDist = Math.abs(bOffset);\n        // -1 The positions of a and b do not change.\n        // 1 The positions of a and b are reversed.\n        if (!aSign) {\n            return 1;\n        } else if (!bSign) {\n            return -1;\n        } else if (a.isBound && b.isBound) {\n            return bDist - aDist;\n        } else if (a.isBound) {\n            return -1;\n        } else if (b.isBound) {\n            return 1;\n        } else if (a.isSnap && b.isSnap) {\n            return aDist - bDist;\n        } else if (a.isSnap) {\n            return -1;\n        } else if (b.isSnap) {\n            return 1;\n        } else if (aDist < TINY_NUM) {\n            return 1;\n        } else if (bDist < TINY_NUM) {\n            return -1;\n        }\n        return aDist - bDist;\n    })[0];\n}\n","import { maxOffset, getDistSize, throttle } from \"../../utils\";\nimport { average, rotate, getRad } from \"@moveable/matrix\";\nimport MoveableManager from \"../../MoveableManager\";\nimport { SnappableProps, DraggableProps, RotatableProps } from \"../../types\";\nimport { getDragDist, getPosByDirection, getInverseDragDist } from \"../../DraggerUtils\";\nimport { getNearOffsetInfo } from \"./snap\";\nimport { TINY_NUM } from \"../../consts\";\n\nfunction isStartLine(dot: number[], line: number[][]) {\n    // l    o     => true\n    // o    l    => false\n    const cx = average(line[0][0], line[1][0]);\n    const cy = average(line[0][1], line[1][1]);\n\n    return {\n        vertical: cx <= dot[0],\n        horizontal: cy <= dot[1],\n    };\n}\nfunction hitTestLine(\n    dot: number[],\n    [pos1, pos2]: number[][],\n) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    let test1: number;\n    let test2: number;\n    if (!dx) {\n        test1 = pos1[0];\n        test2 = dot[0];\n    } else if (!dy) {\n        test1 = pos1[1];\n        test2 = dot[1];\n    } else {\n        const a = dy / dx;\n\n        // y = a * (x - pos1) + pos1\n        test1 = a * (dot[0] - pos1[0]) + pos1[1];\n        test2 = dot[1];\n    }\n    return test1 - test2;\n}\nfunction isSameStartLine(dots: number[][], line: number[][], error: number = TINY_NUM) {\n    const centerSign = hitTestLine(dots[0], line) <= 0;\n\n    return dots.slice(1).every(dot => {\n        const value = hitTestLine(dot, line);\n        const sign = value <= 0;\n        return sign === centerSign || Math.abs(value) <= error;\n    });\n}\nfunction checkInnerBoundDot(\n    pos: number,\n    start: number,\n    end: number,\n    isStart: boolean,\n    threshold: number = 0,\n) {\n    if (\n        (isStart && start - threshold <= pos)\n        || (!isStart && pos <= end + threshold)\n    ) {\n        // false 402 565 602 => 37 ([0, 37])\n        // true 400 524.9712603540036 600 => 124 ([124, 0])\n        // true 400 410 600 => 10 ([10, 0])\n        return {\n            isBound: true,\n            offset: isStart ? start - pos : end - pos,\n        };\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\n\nfunction checkInnerBound(\n    moveable: MoveableManager<SnappableProps>,\n    line: number[][],\n    center: number[],\n) {\n    const bounds = moveable.props.innerBounds;\n\n    if (!bounds) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n    const { left, top, width, height } = bounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n    const {\n        horizontal: isHorizontalStart,\n        vertical: isVerticalStart,\n    } = isStartLine(center, line);\n\n    if (isSameStartLine([\n        center,\n        [left, top],\n        [left + width, top],\n        [left, top + height],\n        [left + width, top + height],\n    ], line)) {\n        return {\n            isAllBound: false,\n            isBound: false,\n            isVerticalBound: false,\n            isHorizontalBound: false,\n            offset: [0, 0],\n        };\n    }\n\n    // test vertical\n    const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);\n    const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);\n\n    // test horizontal\n    const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);\n    const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);\n\n    const isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;\n    const isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;\n    const isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;\n    const isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;\n    const verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);\n    const horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);\n\n    let offset = [0, 0];\n    let isBound = false;\n    let isAllBound = false;\n\n    if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {\n        offset = [verticalOffset, 0];\n        isBound = isVerticalBound;\n        isAllBound = isAllVerticalBound;\n    } else {\n        offset = [0, horizontalOffset];\n        isBound = isHorizontalBound;\n        isAllBound = isAllHorizontalBound;\n    }\n    return {\n        isAllBound,\n        isVerticalBound,\n        isHorizontalBound,\n        isBound,\n        offset,\n    };\n}\n\nfunction checkLineBoundCollision(\n    line: number[][],\n    boundLine: number[][],\n    isStart: boolean,\n    threshold?: number,\n) {\n    const dot1 = line[0];\n    const dot2 = line[1];\n    const boundDot1 = boundLine[0];\n    const boundDot2 = boundLine[1];\n    const dy1 = dot2[1] - dot1[1];\n    const dx1 = dot2[0] - dot1[0];\n\n    const dy2 = boundDot2[1] - boundDot1[1];\n    const dx2 = boundDot2[0] - boundDot1[0];\n\n    // dx2 or dy2 is zero\n    if (!dx2) {\n        // vertical\n        if (dx1) {\n            const y = dy1 ? dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1] : dot1[1];\n\n            // boundDot1[1] <= y  <= boundDot2[1]\n            return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);\n        }\n    } else if (!dy2) {\n        // horizontal\n\n        if (dy1) {\n            // y = a * (x - x1) + y1\n            // x = (y - y1) / a + x1\n            const a = dy1 / dx1;\n            const x = dx1 ? (boundDot1[1] - dot1[1]) / a + dot1[0] : dot1[0];\n\n            // boundDot1[0] <= x && x <= boundDot2[0]\n            return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);\n        }\n    }\n    return {\n        isBound: false,\n        offset: 0,\n    };\n}\nexport function getInnerBoundInfo(\n    moveable: MoveableManager<SnappableProps>,\n    lines: number[][][],\n    center: number[],\n    datas: any,\n) {\n    return lines.map(([multiple, pos1, pos2]) => {\n        const {\n            isBound,\n            offset,\n            isVerticalBound,\n            isHorizontalBound,\n        } = checkInnerBound(moveable, [pos1, pos2], center);\n\n        const sizeOffset = getDragDist({\n            datas,\n            distX: offset[0],\n            distY: offset[1],\n        }).map((size, i) => size * (multiple[i] ?  2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound,\n            isVerticalBound,\n            isHorizontalBound,\n            isSnap: false,\n            offset: sizeOffset,\n        };\n    });\n}\n\nexport function getInnerBoundDragInfo(\n    moveable: MoveableManager<SnappableProps & DraggableProps, any>,\n    poses: number[][],\n    datas: any,\n) {\n    const lines = getCheckSnapLines(poses, [0, 0], false).map(([sign, pos1, pos2]) => {\n        return [\n            sign.map(dir => Math.abs(dir) * 2),\n            pos1,\n            pos2,\n        ];\n    });\n    const innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);\n    const widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);\n    const heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);\n    let verticalOffset = 0;\n    let horizontalOffset = 0;\n    const isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;\n    const isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;\n\n    if (isVerticalBound || isHorizontalBound) {\n        [verticalOffset, horizontalOffset] = getInverseDragDist({\n            datas,\n            distX: -widthOffsetInfo.offset[0],\n            distY: -heightOffsetInfo.offset[1],\n        });\n    }\n\n    return {\n        vertical: {\n            isBound: isVerticalBound,\n            offset: verticalOffset,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            offset: horizontalOffset,\n        },\n    };\n}\nexport function getCheckSnapLineDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const lineDirections: number[][][] = [];\n    const x = direction[0];\n    const y = direction[1];\n    if (x && y) {\n        lineDirections.push(\n            [[0, y * 2], direction, [-x, y]],\n            [[x * 2, 0], direction, [x, -y]],\n        );\n    } else if (x) {\n        // vertcal\n        lineDirections.push(\n            [[x * 2, 0], [x, 1], [x, -1]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[0, -1], [x, -1], [-x, -1]],\n                [[0, 1], [x, 1], [-x, 1]],\n            );\n        }\n    } else if (y) {\n        // horizontal\n        lineDirections.push(\n            [[0, y * 2], [1, y], [-1, y]],\n        );\n        if (keepRatio) {\n            lineDirections.push(\n                [[-1, 0], [-1, y], [-1, -y]],\n                [[1, 0], [1, y], [1, -y]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        lineDirections.push(\n            [[-1, 0], [-1, -1], [-1, 1]],\n            [[1, 0], [1, -1], [1, 1]],\n            [[0, -1], [-1, -1], [1, -1]],\n            [[0, 1], [-1, 1], [1, 1]],\n        );\n    }\n\n    return lineDirections;\n}\nexport function getCheckSnapLines(\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n) {\n    return getCheckSnapLineDirections(direction, keepRatio).map(([sign, dir1, dir2]) => {\n        return [\n            sign,\n            getPosByDirection(poses, dir1),\n            getPosByDirection(poses, dir2),\n        ];\n    });\n}\n\nfunction isBoundRotate(\n    relativePoses: number[][],\n    boundDots: number[][],\n    center: number[],\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n    const dots = [\n        center,\n        ...boundDots,\n    ];\n    return [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].some((line, i) => !isSameStartLine(dots, line));\n}\nfunction getDistPointLine([pos1, pos2]: number[][]) {\n    // x = 0, y = 0\n    // d = (ax + by + c) / root(a2 + b2)\n\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return Math.abs(pos1[0]);\n    }\n    if (!dy) {\n        return Math.abs(pos1[1]);\n    }\n    // y - y1 = a(x - x1)\n    // 0 = ax -y + -a * x1 + y1\n\n    const a = dy / dx;\n\n    return Math.abs((-a * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a, 2) + 1));\n}\nfunction solveReverseLine([pos1, pos2]: number[][]) {\n    const dx = pos2[0] - pos1[0];\n    const dy = pos2[1] - pos1[1];\n\n    if (!dx) {\n        return [pos1[0], 0];\n    }\n    if (!dy) {\n        return [0, pos1[1]];\n    }\n    const a = dy / dx;\n    // y - y1 = a (x  - x1)\n    // y = ax - a * x1 + y1\n    const b = -a * pos1[0] + pos1[1];\n    // y = ax + b = -1/a x\n    // x = -b / (a + 1 / a)\n    // y = b / (1 + 1 / a^2)\n\n    return [\n        -b / (a + 1 / a),\n        b / ((a * a) + 1),\n    ];\n}\nexport function checkRotateInnerBounds(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.innerBounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left,\n        top,\n        width,\n        height,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = left + width - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = top + height - origin[1];\n    const dots = [\n        [relativeLeft, relativeTop],\n        [relativeRight, relativeTop],\n        [relativeLeft, relativeBottom],\n        [relativeRight, relativeBottom],\n    ];\n    const center = getPosByDirection(nextPoses, [0, 0]);\n\n    if (!isBoundRotate(nextPoses, dots, center, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    const dotInfos = dots.map(dot => [\n        getDistSize(dot),\n        getRad([0, 0], dot),\n    ]);\n    [\n        [nextPoses[0], nextPoses[1]],\n        [nextPoses[1], nextPoses[3]],\n        [nextPoses[3], nextPoses[2]],\n        [nextPoses[2], nextPoses[0]],\n    ].forEach(line => {\n        const lineRad = getRad([0, 0], solveReverseLine(line));\n        const lineDist = getDistPointLine(line);\n\n        result.push(...dotInfos\n            .filter(([dotDist]) => {\n                return dotDist && lineDist <= dotDist;\n            })\n            .map(([dotDist, dotRad]) => {\n                const distRad = Math.acos(dotDist ? lineDist / dotDist : 0);\n                const nextRad1 = dotRad + distRad;\n                const nextRad2 = dotRad - distRad;\n\n                return [\n                    rad + nextRad1 - lineRad,\n                    rad + nextRad2 - lineRad,\n                ];\n            })\n            .reduce<number[]>((prev, cur) => {\n                prev.push(...cur);\n                return prev;\n            }, [])\n            .filter(nextRad => !isBoundRotate(prevPoses, dots, center, nextRad))\n            .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n    });\n    return result;\n}\n\nexport function checkInnerBoundPoses(\n    moveable: MoveableManager<SnappableProps>,\n) {\n    const innerBounds = moveable.props.innerBounds;\n\n    if (!innerBounds) {\n        return {\n            vertical: [],\n            horizontal: [],\n        };\n    }\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = moveable.getRect();\n    const poses = [pos1, pos2, pos3, pos4];\n    const center = getPosByDirection(poses, [0, 0]);\n    const { left, top, width, height } = innerBounds;\n    const leftLine = [[left, top], [left, top + height]];\n    const topLine = [[left, top], [left + width, top]];\n    const rightLine = [[left + width, top], [left + width, top + height]];\n    const bottomLine = [[left, top + height], [left + width, top + height]];\n\n    const lines = [\n        [pos1, pos2],\n        [pos2, pos4],\n        [pos4, pos3],\n        [pos3, pos1],\n    ];\n\n    const horizontalPoses: number[] = [];\n    const verticalPoses: number[] = [];\n\n    const boundMap = {\n        top: false,\n        bottom: false,\n        left: false,\n        right: false,\n    };\n\n    lines.forEach(line => {\n        const {\n            horizontal: isHorizontalStart,\n            vertical: isVerticalStart,\n        } = isStartLine(center, line);\n\n        // test vertical\n        const topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1);\n        const bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1);\n\n        // test horizontal\n        const leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1);\n        const rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1);\n\n        if (topBoundInfo.isBound && !boundMap.top) {\n            horizontalPoses.push(top);\n            boundMap.top = true;\n        }\n        if (bottomBoundInfo.isBound && !boundMap.bottom) {\n            horizontalPoses.push(top + height);\n            boundMap.bottom = true;\n        }\n        if (leftBoundInfo.isBound && !boundMap.left) {\n            verticalPoses.push(left);\n            boundMap.left = true;\n        }\n        if (rightBoundInfo.isBound && !boundMap.right) {\n            verticalPoses.push(left + width);\n            boundMap.right = true;\n        }\n    });\n\n    return {\n        horizontal: horizontalPoses,\n        vertical: verticalPoses,\n    };\n}\n","import MoveableManager from \"../../MoveableManager\";\nimport { BoundInfo, SnappableProps, BoundType, RotatableProps } from \"../../types\";\nimport { rotate, getRad, minus } from \"@moveable/matrix\";\nimport { getDistSize, throttle } from \"../../utils\";\nimport { TINY_NUM } from \"../../consts\";\n\nexport function checkBoundPoses(\n    moveable: MoveableManager<SnappableProps>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n    const bounds = { left, top, right, bottom };\n\n    return {\n        vertical: checkBound(bounds, verticalPoses, true),\n        horizontal: checkBound(bounds, horizontalPoses, false),\n    };\n}\n\nexport function checkBoundKeepRatio(\n    moveable: MoveableManager<SnappableProps>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = moveable.props.bounds || {};\n\n    const [endX, endY] = endPos;\n    const [dx, dy] = minus(endPos, startPos);\n    const isBottom = dy > 0;\n    const isRight = dx > 0;\n\n    const verticalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    const horizontalInfo = {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n    if (dx === 0 && dy === 0) {\n        return {\n            vertical: verticalInfo,\n            horizontal: horizontalInfo,\n        };\n    } else if (dx === 0) {\n        if (isBottom) {\n            if (bottom < endY) {\n                horizontalInfo.pos = bottom;\n                horizontalInfo.offset = endY - bottom;\n            }\n        } else {\n            if (top > endY) {\n                horizontalInfo.pos = top;\n                horizontalInfo.offset = endY - top;\n            }\n        }\n    } else if (dy === 0) {\n        if (isRight) {\n            if (right < endX) {\n                verticalInfo.pos = right;\n                verticalInfo.offset = endX - right;\n            }\n        } else {\n            if (left > endX) {\n                verticalInfo.pos = left;\n                verticalInfo.offset = endX - left;\n            }\n        }\n    } else {\n        // y - y1 = a * (x - x1)\n        const a = dy / dx;\n        const b = endPos[1] - a * endX;\n        let y = 0;\n        let x = 0;\n        let isBound = false;\n\n        if (isRight && right <= endX) {\n            y = a * right + b;\n            x = right;\n            isBound = true;\n        } else if (!isRight && endX <= left) {\n            y = a * left + b;\n            x = left;\n            isBound = true;\n        } else if (isBottom && bottom <= endY) {\n            y = bottom;\n            x = (y - b) / a;\n            isBound = true;\n        } else if (!isBottom &&  endY <= top) {\n            y = top;\n            x = (y - b) / a;\n            isBound = true;\n        }\n        if (isBound) {\n            verticalInfo.isBound = true;\n            verticalInfo.pos = x;\n            verticalInfo.offset = endX - x;\n\n            horizontalInfo.isBound = true;\n            horizontalInfo.pos = y;\n            horizontalInfo.offset = endY - y;\n        }\n    }\n\n    return {\n        vertical: verticalInfo,\n        horizontal: horizontalInfo,\n    };\n}\nfunction checkBound(\n    bounds: Required<BoundType>,\n    poses: number[],\n    isVertical: boolean,\n): BoundInfo {\n    // 0   [100 - 200]  300\n    const startBoundPos = bounds[isVertical ? \"left\" : \"top\"];\n    const endBoundPos = bounds[isVertical ? \"right\" : \"bottom\"];\n\n    // 450\n    const minPos = Math.min(...poses);\n    const maxPos = Math.max(...poses);\n\n    if (startBoundPos + 1 > minPos) {\n        return {\n            isBound: true,\n            offset: minPos - startBoundPos,\n            pos: startBoundPos,\n        };\n    }\n    if (endBoundPos - 1 < maxPos) {\n        return {\n            isBound: true,\n            offset: maxPos - endBoundPos,\n            pos: endBoundPos,\n        };\n    }\n\n    return {\n        isBound: false,\n        offset: 0,\n        pos: 0,\n    };\n}\nexport function isBoundRotate(\n    relativePoses: number[][],\n    boundRect: { left: number, top: number, right: number, bottom: number },\n    rad: number,\n) {\n    const nextPoses = rad ? relativePoses.map(pos => rotate(pos, rad)) : relativePoses;\n\n    return nextPoses.some(pos => {\n        return (pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1)\n            || (pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1)\n            || (pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1)\n            || (pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1);\n    });\n}\nexport function boundRotate(\n    vec: number[],\n    boundPos: number,\n    index: number,\n) {\n    const r = getDistSize(vec);\n    const nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;\n\n    return [nextPos, -nextPos].sort((a, b) => {\n        return Math.abs(a - vec[index ? 0 : 1]) - Math.abs(b - vec[index ? 0 : 1]);\n    }).map(pos => {\n        return getRad([0, 0], index ? [pos, boundPos] : [boundPos, pos]);\n    });\n}\n\nexport function checkRotateBounds(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    prevPoses: number[][],\n    nextPoses: number[][],\n    origin: number[],\n    rotation: number,\n) {\n    const bounds = moveable.props.bounds;\n    const rad = rotation * Math.PI / 180;\n\n    if (!bounds) {\n        return [];\n    }\n    const {\n        left = -Infinity,\n        top = -Infinity,\n        right = Infinity,\n        bottom = Infinity,\n    } = bounds;\n\n    const relativeLeft = left - origin[0];\n    const relativeRight = right - origin[0];\n    const relativeTop = top - origin[1];\n    const relativeBottom = bottom - origin[1];\n    const boundRect = {\n        left: relativeLeft,\n        top: relativeTop,\n        right: relativeRight,\n        bottom: relativeBottom,\n    };\n\n    if (!isBoundRotate(nextPoses, boundRect, 0)) {\n        return [];\n    }\n    const result: number[] = [];\n    [\n        [relativeLeft, 0],\n        [relativeRight, 0],\n        [relativeTop, 1],\n        [relativeBottom, 1],\n    ].forEach(([boundPos, index], i) => {\n        nextPoses.forEach(nextPos => {\n            const relativeRad1 = getRad([0, 0], nextPos);\n\n            result.push(...boundRotate(nextPos, boundPos, index)\n                .map(relativeRad2 => rad + relativeRad2 - relativeRad1)\n                .filter(nextRad => !isBoundRotate(prevPoses, boundRect, nextRad))\n                .map(nextRad => throttle(nextRad * 180 / Math.PI, TINY_NUM)));\n        });\n    });\n\n    return result;\n}\n","import MoveableManager from \"../MoveableManager\";\nimport {\n    Renderer,\n    SnappableProps,\n    SnappableState, Guideline,\n    SnapInfo, BoundInfo,\n    ScalableProps, SnapPosInfo, RotatableProps,\n    RectInfo, DraggableProps, SnapOffsetInfo,\n} from \"../types\";\nimport {\n    prefix, caculatePoses, getRect,\n    getAbsolutePosesByState, getAbsolutePoses, throttle, roundSign, getDistSize, groupBy, flat, maxOffset,\n} from \"../utils\";\nimport { IObject, find } from \"@daybrush/utils\";\nimport {\n    getPosByReverseDirection,\n    getDragDist, scaleMatrix, getPosByDirection,\n} from \"../DraggerUtils\";\nimport { minus, rotate, plus } from \"@moveable/matrix\";\nimport {\n    dragControlCondition as rotatableDragControlCondtion,\n} from \"./Rotatable\";\nimport { TINY_NUM } from \"../consts\";\nimport { directionCondition } from \"./utils\";\nimport {\n    getInnerBoundInfo, getCheckSnapLines,\n    getInnerBoundDragInfo, checkRotateInnerBounds, checkInnerBoundPoses,\n} from \"./snappable/innerBounds\";\nimport { checkBoundPoses, checkRotateBounds, checkBoundKeepRatio } from \"./snappable/bounds\";\nimport {\n    checkSnaps, getSnapInfosByDirection,\n    checkSnapPoses, getNearestSnapGuidelineInfo,\n    getNearOffsetInfo,\n    checkSnapKeepRatio,\n} from \"./snappable/snap\";\n\nexport function snapStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n    const state = moveable.state;\n    if (state.guidelines && state.guidelines.length) {\n        return;\n    }\n\n    const {\n        horizontalGuidelines = [],\n        verticalGuidelines = [],\n        elementGuidelines = [],\n        bounds,\n        snapCenter,\n    } = moveable.props;\n\n    if (!bounds && !horizontalGuidelines.length && !verticalGuidelines.length && !elementGuidelines.length) {\n        return;\n    }\n\n    const {\n        containerClientRect: {\n            top: containerTop,\n            left: containerLeft,\n        },\n        targetClientRect: {\n            top: clientTop,\n            left: clientLeft,\n        },\n    } = state;\n    const poses = getAbsolutePosesByState(state);\n    const targetLeft = Math.min(...poses.map(pos => pos[0]));\n    const targetTop = Math.min(...poses.map(pos => pos[1]));\n    const distLeft = roundSign(targetLeft - (clientLeft - containerLeft));\n    const distTop = roundSign(targetTop - (clientTop - containerTop));\n    const guidelines: Guideline[] = [];\n\n    elementGuidelines!.forEach(el => {\n        const rect = el.getBoundingClientRect();\n        const { top, left, width, height } = rect;\n        const elementTop = top - containerTop;\n        const elementBottom = elementTop + height;\n        const elementLeft = left - containerLeft;\n        const elementRight = elementLeft + width;\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementLeft + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n        });\n        guidelines.push({\n            type: \"vertical\", element: el, pos: [\n                throttle(elementRight + distLeft, 0.1),\n                elementTop,\n            ], size: height,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementTop + distTop, 0.1),\n            ], size: width,\n        });\n        guidelines.push({\n            type: \"horizontal\", element: el, pos: [\n                elementLeft,\n                throttle(elementBottom + distTop, 0.1),\n            ], size: width,\n        });\n\n        if (snapCenter) {\n            guidelines.push({\n                type: \"vertical\",\n                element: el,\n                pos: [\n                    throttle((elementLeft + elementRight) / 2 + distLeft, 0.1),\n                    elementTop,\n                ],\n                size: height,\n                center: true,\n            });\n            guidelines.push({\n                type: \"horizontal\",\n                element: el,\n                pos: [\n                    elementLeft,\n                    throttle((elementTop + elementBottom) / 2 + distTop, 0.1),\n                ],\n                size: width,\n                center: true,\n            });\n        }\n    });\n\n    state.guidelines = guidelines;\n    state.enableSnap = true;\n}\n\nexport function hasGuidelines(\n    moveable: MoveableManager<any, any>,\n    ableName: string,\n): moveable is MoveableManager<SnappableProps, SnappableState> {\n    const {\n        props: {\n            snappable,\n            bounds,\n            verticalGuidelines,\n            horizontalGuidelines,\n        },\n        state: {\n            guidelines,\n            enableSnap,\n        },\n    } = moveable;\n\n    if (\n        !snappable\n        || !enableSnap\n        || (ableName && snappable !== true && snappable.indexOf(ableName) < 0)\n    ) {\n        return false;\n    }\n    if (\n        bounds\n        || (guidelines && guidelines.length)\n        || (verticalGuidelines && verticalGuidelines.length)\n        || (horizontalGuidelines && horizontalGuidelines.length)\n    ) {\n        return true;\n    }\n    return false;\n}\n\nfunction solveNextOffset(\n    pos1: number[],\n    pos2: number[],\n    offset: number,\n    isVertical: boolean,\n    datas: IObject<any>,\n) {\n    const sizeOffset = solveEquation(\n        pos1,\n        pos2,\n        -offset,\n        isVertical,\n    );\n\n    if (!sizeOffset) {\n        return [0, 0];\n    }\n    const [widthOffset, heightOffset] = getDragDist({\n        datas,\n        distX: sizeOffset[0],\n        distY: sizeOffset[1],\n    });\n\n    return [widthOffset, heightOffset];\n}\nfunction getNextFixedPoses(\n    matrix: number[],\n    width: number,\n    height: number,\n    fixedPos: number[],\n    direction: number[],\n    is3d: boolean,\n) {\n    const nextPoses = caculatePoses(matrix, width, height, is3d ? 4 : 3);\n    const nextPos = getPosByReverseDirection(nextPoses, direction);\n\n    return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));\n}\nfunction getSnapBoundOffset(boundInfo: BoundInfo, snapInfo: SnapOffsetInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return snapInfo.offset;\n    }\n    return 0;\n}\nfunction getSnapBound(boundInfo: BoundInfo, snapInfo: SnapInfo) {\n    if (boundInfo.isBound) {\n        return boundInfo.offset;\n    } else if (snapInfo.isSnap) {\n        return getNearestSnapGuidelineInfo(snapInfo).offset;\n    }\n    return 0;\n}\nexport function checkSnapBoundsKeepRatio(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    startPos: number[],\n    endPos: number[],\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapKeepRatio(\n        moveable,\n        startPos,\n        endPos,\n    );\n\n    const horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkSnapBounds(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    boundPoses: number[][] = poses,\n) {\n    const {\n        horizontal: horizontalBoundInfo,\n        vertical: verticalBoundInfo,\n    } = checkBoundPoses(\n        moveable,\n        boundPoses.map(pos => pos[0]),\n        boundPoses.map(pos => pos[1]),\n    );\n    const {\n        horizontal: horizontalSnapInfo,\n        vertical: verticalSnapInfo,\n    } = checkSnapPoses(\n        moveable,\n        poses.map(pos => pos[0]),\n        poses.map(pos => pos[1]),\n    );\n\n    const horizontalOffset = getSnapBound(horizontalBoundInfo, horizontalSnapInfo);\n    const verticalOffset = getSnapBound(verticalBoundInfo, verticalSnapInfo);\n\n    const horizontalDist = Math.abs(horizontalOffset);\n    const verticalDist = Math.abs(verticalOffset);\n\n    return {\n        horizontal: {\n            isBound: horizontalBoundInfo.isBound,\n            isSnap: horizontalSnapInfo.isSnap,\n            offset: horizontalOffset,\n            dist: horizontalDist,\n        },\n        vertical: {\n            isBound: verticalBoundInfo.isBound,\n            isSnap: verticalSnapInfo.isSnap,\n            offset: verticalOffset,\n            dist: verticalDist,\n        },\n    };\n}\nexport function checkMaxBounds(\n    moveable: MoveableManager<SnappableProps>,\n    width: number,\n    height: number,\n    poses: number[][],\n    direction: number[],\n    fixedPos: number[],\n    datas: any,\n) {\n    const fixedDirection = [-direction[0], -direction[1]];\n    const bounds = moveable.props.bounds;\n    let maxWidth = Infinity;\n    let maxHeight = Infinity;\n\n    if (bounds) {\n        const directions = [\n            [direction[0], -direction[1]],\n            [-direction[0], direction[1]],\n        ];\n        const {\n            left = -Infinity,\n            top = -Infinity,\n            right = Infinity,\n            bottom = Infinity,\n        } = bounds;\n\n        directions.forEach(otherDirection => {\n            const isCheckVertical = otherDirection[0] !== fixedDirection[0];\n            const isCheckHorizontal = otherDirection[1] !== fixedDirection[1];\n            const otherPos = getPosByDirection(poses, otherDirection);\n\n            if (isCheckHorizontal) {\n                const [\n                    ,\n                    heightOffset,\n                ] = solveNextOffset(\n                    fixedPos, otherPos,\n                    (fixedPos[1] < otherPos[1] ? bottom : top) - otherPos[1],\n                    false, datas,\n                );\n\n                if (!isNaN(heightOffset)) {\n                    maxHeight = height + heightOffset;\n                }\n            }\n            if (isCheckVertical) {\n                const [\n                    widthOffset,\n                ] = solveNextOffset(\n                    fixedPos, otherPos,\n                    (fixedPos[0] < otherPos[0] ? right : left) - otherPos[0],\n                    true, datas,\n                );\n                if (!isNaN(widthOffset)) {\n                    maxWidth = width + widthOffset;\n                }\n            }\n        });\n    }\n    return {\n        maxWidth,\n        maxHeight,\n    };\n}\nfunction getSnapBoundInfo(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    directions: number[][][],\n    keepRatio: boolean,\n    datas: any,\n) {\n    return directions.map(([startDirection, endDirection]) => {\n        const otherStartPos = getPosByDirection(poses, startDirection);\n        const otherEndPos = getPosByDirection(poses, endDirection);\n\n        const snapBoundInfo\n            = keepRatio\n            ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos)\n            : checkSnapBounds(moveable, [otherEndPos]);\n\n        const {\n            horizontal: {\n                dist: otherHorizontalDist,\n                offset: otherHorizontalOffset,\n                isBound: isOtherHorizontalBound,\n                isSnap: isOtherHorizontalSnap,\n            },\n            vertical: {\n                dist: otherVerticalDist,\n                offset: otherVerticalOffset,\n                isBound: isOtherVerticalBound,\n                isSnap: isOtherVerticalSnap,\n            },\n        } = snapBoundInfo;\n\n        const multiple = minus(endDirection, startDirection);\n\n        if (!otherVerticalOffset && !otherHorizontalOffset) {\n            return {\n                isBound: isOtherVerticalBound || isOtherHorizontalBound,\n                isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,\n                sign: multiple,\n                offset: [0, 0],\n            };\n        }\n        const isVertical = otherHorizontalDist < otherVerticalDist;\n        const sizeOffset = solveNextOffset(\n            otherStartPos,\n            otherEndPos,\n            isVertical ? otherVerticalOffset : otherHorizontalOffset,\n            isVertical,\n            datas,\n        ).map((size, i) => size * (multiple[i] ? 2 / multiple[i] : 0));\n\n        return {\n            sign: multiple,\n            isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,\n            isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,\n            offset: sizeOffset,\n        };\n    });\n}\nexport function getCheckSnapDirections(\n    direction: number[],\n    keepRatio: boolean,\n) {\n    const directions: number[][][] = [];\n    const fixedDirection = [-direction[0], -direction[1]];\n\n    if (direction[0] && direction[1]) {\n        directions.push(\n            [fixedDirection, [direction[0], -direction[1]]],\n            [fixedDirection, [-direction[0], direction[1]]],\n        );\n        if (keepRatio) {\n            // pass two direction condition\n            directions.push(\n                [fixedDirection, direction],\n            );\n        }\n    } else if (direction[0]) {\n        // vertcal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [fixedDirection[0], -1]],\n                [fixedDirection, [fixedDirection[0], 1]],\n                [fixedDirection, [direction[0], -1]],\n                [fixedDirection, direction],\n                [fixedDirection, [direction[0], 1]],\n            );\n        } else {\n            directions.push(\n                [[fixedDirection[0], -1], [direction[0], -1]],\n                [[fixedDirection[0], 0], [direction[0], 0]],\n                [[fixedDirection[0], 1], [direction[0], 1]],\n            );\n        }\n    } else if (direction[1]) {\n        // horizontal\n        if (keepRatio) {\n            directions.push(\n                [fixedDirection, [-1, fixedDirection[1]]],\n                [fixedDirection, [1, fixedDirection[1]]],\n                [fixedDirection, [-1, direction[1]]],\n                [fixedDirection, [1, direction[1]]],\n                [fixedDirection, direction],\n            );\n        } else {\n            directions.push(\n                [[-1, fixedDirection[1]], [-1, direction[1]]],\n                [[0, fixedDirection[1]], [0, direction[1]]],\n                [[1, fixedDirection[1]], [1, direction[1]]],\n            );\n        }\n    } else {\n        // [0, 0] to all direction\n        directions.push(\n            [fixedDirection, [1, 0]],\n            [fixedDirection, [-1, 0]],\n            [fixedDirection, [0, -1]],\n            [fixedDirection, [0, 1]],\n\n            [[1, 0], [1, -1]],\n            [[1, 0], [1, 1]],\n            [[0, 1], [1, 1]],\n            [[0, 1], [-1, 1]],\n\n            [[-1, 0], [-1, -1]],\n            [[-1, 0], [-1, 1]],\n            [[0, -1], [1, -1]],\n            [[0, -1], [-1, -1]],\n        );\n    }\n\n    return directions;\n}\nexport function getSizeOffsetInfo(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    direction: number[],\n    keepRatio: boolean,\n    datas: any,\n) {\n    const directions = getCheckSnapDirections(direction, keepRatio);\n    const lines = getCheckSnapLines(poses, direction, keepRatio);\n    const offsets = [\n        ...getSnapBoundInfo(moveable, poses, directions, keepRatio, datas),\n        ...getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas),\n    ];\n    const widthOffsetInfo = getNearOffsetInfo(offsets, 0);\n    const heightOffsetInfo = getNearOffsetInfo(offsets, 1);\n\n    return {\n        width: {\n            isBound: widthOffsetInfo.isBound,\n            offset: widthOffsetInfo.offset[0],\n        },\n        height: {\n            isBound: heightOffsetInfo.isBound,\n            offset: heightOffsetInfo.offset[1],\n        },\n    };\n}\nexport function recheckSizeByTwoDirection(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    poses: number[][],\n    width: number,\n    height: number,\n    maxWidth: number,\n    maxHeight: number,\n    direction: number[],\n    datas: any,\n) {\n    const snapPos = getPosByDirection(poses, direction);\n\n    const {\n        horizontal: {\n            offset: horizontalOffset,\n        },\n        vertical: {\n            offset: verticalOffset,\n        },\n    } = checkSnapBounds(moveable, [snapPos]);\n\n    if (verticalOffset || horizontalOffset) {\n        const [nextWidthOffset, nextHeightOffset] = getDragDist({\n            datas,\n            distX: -verticalOffset,\n            distY: -horizontalOffset,\n        });\n\n        const nextWidth\n            = Math.min(maxWidth || Infinity, width + direction[0] * nextWidthOffset);\n        const nextHeight\n            = Math.min(maxHeight || Infinity, height + direction[1] * nextHeightOffset);\n\n        return [\n            nextWidth - width,\n            nextHeight - height,\n        ];\n    }\n    return [\n        0,\n        0,\n    ];\n}\nexport function checkSizeDist(\n    moveable: MoveableManager<any, any>,\n    getNextPoses: (widthOffset: number, heightOffset: number) => number[][],\n    matrix: number[],\n    width: number,\n    height: number,\n    direction: number[],\n    snapDirection: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    is3d: boolean,\n    datas: any,\n) {\n    const poses = getAbsolutePosesByState(moveable.state);\n    const keepRatio = moveable.props.keepRatio;\n\n    let widthOffset = 0;\n    let heightOffset = 0;\n\n    for (let i = 0; i < 2; ++i) {\n        const nextPoses = getNextPoses(widthOffset, heightOffset);\n        const {\n            width: widthOffsetInfo,\n            height: heightOffsetInfo,\n        } = getSizeOffsetInfo(\n            moveable,\n            nextPoses,\n            direction,\n            keepRatio,\n            datas,\n        );\n\n        const isWidthBound = widthOffsetInfo.isBound;\n        const isHeightBound = heightOffsetInfo.isBound;\n        let nextWidthOffset = widthOffsetInfo.offset;\n        let nextHeightOffset = heightOffsetInfo.offset;\n\n        if (i === 1) {\n            if (!isWidthBound) {\n                nextWidthOffset = 0;\n            }\n            if (!isHeightBound) {\n                nextHeightOffset = 0;\n            }\n        }\n        if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {\n            return [0, 0];\n        }\n        if (keepRatio) {\n            const widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);\n            const heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);\n            const isGetWidthOffset\n                = isWidthBound && isHeightBound ? widthDist < heightDist\n                    : isHeightBound || (!isWidthBound && widthDist < heightDist);\n\n            // height * widthOffset = width * heighOffset\n            if (isGetWidthOffset) {\n                // width : height = ? : heightOffset\n                nextWidthOffset = width * nextHeightOffset / height;\n            } else {\n                // width : height = widthOffset : ?\n                nextHeightOffset = height * nextWidthOffset / width;\n            }\n        }\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n\n        return [\n            widthOffset,\n            heightOffset,\n        ];\n    }\n\n    if (direction[0] && direction[1]) {\n        const {\n            maxWidth,\n            maxHeight,\n        } = checkMaxBounds(moveable, width, height, poses, direction, fixedPos, datas);\n\n        const [nextWidthOffset, nextHeightOffset] = recheckSizeByTwoDirection(\n            moveable,\n            getNextPoses(widthOffset, heightOffset),\n            width + widthOffset,\n            height + heightOffset,\n            maxWidth,\n            maxHeight,\n            direction,\n            datas,\n        );\n\n        widthOffset += nextWidthOffset;\n        heightOffset += nextHeightOffset;\n    }\n\n    return [\n        widthOffset,\n        heightOffset,\n    ];\n}\n\nexport function checkSnapRotate(\n    moveable: MoveableManager<SnappableProps & RotatableProps, any>,\n    rect: RectInfo,\n    origin: number[],\n    rotation: number,\n) {\n    if (!hasGuidelines(moveable, \"rotatable\")) {\n        return rotation;\n    }\n\n    const {\n        pos1,\n        pos2,\n        pos3,\n        pos4,\n    } = rect;\n    const rad = rotation * Math.PI / 180;\n    const prevPoses = [pos1, pos2, pos3, pos4].map(pos => minus(pos, origin));\n    const nextPoses = prevPoses.map(pos => rotate(pos, rad));\n\n    const result = [\n        ...checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation),\n        ...checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation),\n    ];\n    result.sort((a, b) => Math.abs(a - rotation) - Math.abs(b - rotation));\n\n    if (result.length) {\n        return result[0];\n    } else {\n        return rotation;\n    }\n}\nexport function checkSnapSize(\n    moveable: MoveableManager<any, any>,\n    width: number,\n    height: number,\n    direction: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    if (!hasGuidelines(moveable, \"resizable\")) {\n        return [0, 0];\n    }\n    const {\n        matrix,\n        is3d,\n    } = moveable.state;\n    return checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                matrix,\n                width + widthOffset,\n                height + heightOffset,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        }, matrix, width, height, direction, direction, fixedPos, isRequest, is3d, datas,\n    );\n}\nexport function checkSnapScale(\n    moveable: MoveableManager<ScalableProps, any>,\n    scale: number[],\n    direction: number[],\n    snapDirection: number[],\n    fixedPos: number[],\n    isRequest: boolean,\n    datas: any,\n) {\n    const {\n        width,\n        height,\n    } = datas;\n    if (!hasGuidelines(moveable, \"scalable\")) {\n        return [0, 0];\n    }\n    const is3d = datas.is3d;\n    const sizeDist = checkSizeDist(\n        moveable,\n        (widthOffset: number, heightOffset: number) => {\n            return getNextFixedPoses(\n                scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])),\n                width,\n                height,\n                fixedPos,\n                direction,\n                is3d,\n            );\n        },\n        scaleMatrix(datas, scale),\n        width, height,\n        direction,\n        snapDirection,\n        fixedPos,\n        isRequest,\n        is3d,\n        datas,\n    );\n\n    return [\n        sizeDist[0] / width,\n        sizeDist[1] / height,\n    ];\n}\nexport function solveEquation(\n    pos1: number[],\n    pos2: number[],\n    snapOffset: number,\n    isVertical: boolean,\n) {\n    let dx = pos2[0] - pos1[0];\n    let dy = pos2[1] - pos1[1];\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n    if (!dx) {\n        // y = 0 * x + b\n        // only horizontal\n        if (!isVertical) {\n            return [0, snapOffset];\n        }\n        return [0, 0];\n    }\n    if (!dy) {\n        // only vertical\n        if (isVertical) {\n            return [snapOffset, 0];\n        }\n        return [0, 0];\n    }\n    // y = ax + b\n    const a = dy / dx;\n    const b = pos1[1] - a * pos1[0];\n\n    if (isVertical) {\n        // y = a * x + b\n        const y = a * (pos2[0] + snapOffset) + b;\n\n        return [snapOffset, y - pos2[1]];\n    } else {\n        // x = (y - b) / a\n        const x = (pos2[1] + snapOffset - b) / a;\n\n        return [x - pos2[0], snapOffset];\n    }\n}\n\nexport function startCheckSnapDrag(\n    moveable: MoveableManager<any, any>,\n    datas: any,\n) {\n    datas.absolutePoses = getAbsolutePosesByState(moveable.state);\n}\n\nexport function checkThrottleDragRotate(\n    throttleDragRotate: number,\n    [distX, distY]: number[],\n    [isVerticalBound, isHorizontalBound]: boolean[],\n    [isVerticalSnap, isHorizontalSnap]: boolean[],\n    [verticalOffset, horizontalOffset]: number[],\n) {\n    let offsetX = -verticalOffset;\n    let offsetY = -horizontalOffset;\n\n    if (throttleDragRotate && distX && distY) {\n        offsetX = 0;\n        offsetY = 0;\n        const adjustPoses = [];\n        if (isVerticalBound && isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalBound) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalBound) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        } else if (isVerticalSnap && isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n                [verticalOffset, 0],\n            );\n        } else if (isVerticalSnap) {\n            adjustPoses.push(\n                [verticalOffset, 0],\n            );\n        } else if (isHorizontalSnap) {\n            adjustPoses.push(\n                [0, horizontalOffset],\n            );\n        }\n        if (adjustPoses.length) {\n            adjustPoses.sort((a, b) => {\n                return getDistSize(minus([distX, distY], a)) - getDistSize(minus([distX, distY], b));\n            });\n            const adjustPos = adjustPoses[0];\n\n            if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {\n                offsetX = -adjustPos[0];\n                offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;\n            } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {\n                const prevDistY = distY;\n                offsetY = -adjustPos[1];\n                offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;\n            }\n            if (throttleDragRotate && isHorizontalBound && isVerticalBound) {\n                if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {\n                    const scale = Math.abs(verticalOffset) / Math.abs(offsetX);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {\n                    const scale = Math.abs(horizontalOffset) / Math.abs(offsetY);\n\n                    offsetX *= scale;\n                    offsetY *= scale;\n                } else {\n                    offsetX = maxOffset(-verticalOffset, offsetX);\n                    offsetY = maxOffset(-horizontalOffset, offsetY);\n                }\n            }\n        }\n    } else {\n        offsetX = (distX || isVerticalBound) ? -verticalOffset : 0;\n        offsetY = (distY || isHorizontalBound) ? -horizontalOffset : 0;\n    }\n    return [offsetX, offsetY];\n}\nexport function checkSnapDrag(\n    moveable: MoveableManager<SnappableProps & DraggableProps, any>,\n    distX: number,\n    distY: number,\n    throttleDragRotate: number,\n    datas: any,\n) {\n\n    if (!hasGuidelines(moveable, \"draggable\")) {\n        return [\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n            {\n                isSnap: false,\n                isBound: false,\n                offset: 0,\n            },\n        ];\n    }\n    const poses = getAbsolutePoses(\n        datas.absolutePoses,\n        [distX, distY],\n    );\n    const { left, right, top, bottom } = getRect(poses);\n    const snapCenter = moveable.props.snapCenter;\n    const snapPoses = [\n        [left, top],\n        [right, top],\n        [left, bottom],\n        [right, bottom],\n    ];\n\n    if (snapCenter) {\n        snapPoses.push([(left + right) / 2, (top + bottom) / 2]);\n    }\n    const {\n        vertical: verticalSnapBoundInfo,\n        horizontal: horizontalSnapBoundInfo,\n    } = checkSnapBounds(moveable, snapPoses, poses);\n    const {\n        vertical: verticalInnerBoundInfo,\n        horizontal: horizontalInnerBoundInfo,\n    } = getInnerBoundDragInfo(moveable, poses, datas);\n\n    const isVerticalSnap = verticalSnapBoundInfo.isSnap;\n    const isHorizontalSnap = horizontalSnapBoundInfo.isSnap;\n    const isVerticalBound\n        = verticalSnapBoundInfo.isBound\n        || verticalInnerBoundInfo.isBound;\n    const isHorizontalBound\n        = horizontalSnapBoundInfo.isBound\n        || horizontalInnerBoundInfo.isBound;\n    const verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);\n    const horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);\n    const [offsetX, offsetY] = checkThrottleDragRotate(\n        throttleDragRotate,\n        [distX, distY],\n        [isVerticalBound, isHorizontalBound],\n        [isVerticalSnap, isHorizontalSnap],\n        [verticalOffset, horizontalOffset],\n    );\n    return [\n        {\n            isBound: isVerticalBound,\n            isSnap: isVerticalSnap,\n            offset: offsetX,\n        },\n        {\n            isBound: isHorizontalBound,\n            isSnap: isHorizontalSnap,\n            offset: offsetY,\n        },\n    ];\n}\n\nfunction getSnapGuidelines(posInfos: SnapPosInfo[]) {\n    const guidelines: Guideline[] = [];\n\n    posInfos.forEach(posInfo => {\n        posInfo.guidelineInfos.forEach(({ guideline }) => {\n            if (guidelines.indexOf(guideline) > -1) {\n                return;\n            }\n            guidelines.push(guideline);\n        });\n    });\n\n    return guidelines;\n}\n\nfunction getElementGuidelineDist(\n    elementPos: number,\n    elementSize: number,\n    targetPos: number,\n    targetSize: number,\n) {\n    // relativePos < 0  => element(l)  ---  (r)target\n    // relativePos > 0  => target(l)   ---  (r)element\n    const relativePos = elementPos - targetPos;\n    const startPos = relativePos < 0 ? relativePos + elementSize : targetSize;\n    const endPos = relativePos < 0 ? 0 : relativePos;\n    const size = endPos - startPos;\n\n    return {\n        size,\n        pos: startPos,\n    };\n}\nfunction groupByElementGuidelines(\n    guidelines: Guideline[],\n    clientPos: number,\n    size: number,\n    index: number,\n) {\n    const groupInfos: Array<[Element, number, any]> = [];\n\n    const group = groupBy(guidelines.filter(({ element }) => element), ({ element, pos, size: size2 }) => {\n        const elementPos = pos[index];\n        const sign = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;\n        const groupKey = `${sign}_${pos[index ? 0 : 1]}`;\n        const groupInfo = find(groupInfos, ([groupElement, groupPos]) => {\n            return element === groupElement && elementPos === groupPos;\n        });\n        if (groupInfo) {\n            return groupInfo[2];\n        }\n        groupInfos.push([element!, elementPos, groupKey]);\n        return groupKey;\n    });\n    group.forEach(elementGuidelines => {\n        elementGuidelines.sort((a, b) => {\n            const result = getElementGuidelineDist(a.pos[index], a.size, clientPos, size).size\n                - getElementGuidelineDist(b.pos[index], a.size, clientPos, size).size;\n\n            return result || a.pos[index ? 0 : 1] - b.pos[index ? 0 : 1];\n        });\n    });\n    return group;\n}\nfunction renderElementGroup(\n    group: Guideline[][],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    clientPos: number,\n    clientSize: number,\n    targetPos: number,\n    snapThreshold: number,\n    isDisplaySnapDigit: boolean,\n    snapDigit: number,\n    index: number,\n    React: Renderer,\n) {\n    return flat(group.map((elementGuidelines, i) => {\n        let isFirstRenderSize = true;\n\n        return elementGuidelines.map(({ pos, size }, j) => {\n            const {\n                pos: linePos,\n                size: lineSize,\n            } = getElementGuidelineDist(pos[index], size, clientPos, clientSize);\n\n            if (lineSize < snapThreshold) {\n                return null;\n            }\n            const isRenderSize = isFirstRenderSize;\n\n            isFirstRenderSize = false;\n            const snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;\n\n            return <div className={prefix(\n                \"line\",\n                directionName,\n                \"guideline\",\n                \"dashed\",\n            )}\n                data-size={snapSize > 0 ? snapSize : \"\"}\n                key={`${directionName}LinkGuidline${i}-${j}`} style={{\n                    [posName1]: `${minPos + linePos}px`,\n                    [posName2]: `${-targetPos + pos[index ? 0 : 1]}px`,\n                    [sizeName]: `${lineSize}px`,\n                }} />;\n        });\n    }));\n}\nfunction renderSnapPoses(\n    snapPoses: number[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    minPos: number,\n    targetPos: number,\n    size: number,\n    React: Renderer,\n) {\n    return snapPoses.map((pos, i) => {\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            \"target\",\n            \"bold\",\n        )} key={`${directionName}TargetGuidline${i}`} style={{\n            [posName1]: `${minPos}px`,\n            [posName2]: `${-targetPos + pos}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\nfunction renderGuidelines(\n    guidelines: Guideline[],\n    [directionName, posName1, posName2, sizeName]: readonly [string, string, string, string],\n    targetPos1: number,\n    targetPos2: number,\n    index: number,\n    React: Renderer,\n) {\n    return guidelines.map((guideline, i) => {\n        const { pos, size, element } = guideline;\n\n        return <div className={prefix(\n            \"line\",\n            directionName,\n            \"guideline\",\n            element ? \"bold\" : \"\",\n        )} key={`${directionName}Guidline${i}`} style={{\n            [posName1]: `${-targetPos1 + pos[index]}px`,\n            [posName2]: `${-targetPos2 + pos[index ? 0 : 1]}px`,\n            [sizeName]: `${size}px`,\n        }} />;\n    });\n}\n\nfunction addBoundGuidelines(\n    moveable: MoveableManager<SnappableProps, SnappableState>,\n    verticalPoses: number[],\n    horizontalPoses: number[],\n    verticalSnapPoses: number[],\n    horizontalSnapPoses: number[],\n) {\n    const {\n        vertical: {\n            isBound: isVerticalBound,\n            pos: verticalBoundPos,\n        },\n        horizontal: {\n            isBound: isHorizontalBound,\n            pos: horizontalBoundPos,\n        },\n    } = checkBoundPoses(moveable, verticalPoses, horizontalPoses);\n\n    if (isVerticalBound && verticalSnapPoses.indexOf(verticalBoundPos) < 0) {\n        verticalSnapPoses.push(verticalBoundPos);\n    }\n    if (isHorizontalBound && horizontalSnapPoses.indexOf(horizontalBoundPos) < 0) {\n        horizontalSnapPoses.push(horizontalBoundPos);\n    }\n    const {\n        vertical: verticalInnerBoundPoses,\n        horizontal: horizontalInnerBoundPoses,\n    } = checkInnerBoundPoses(moveable);\n\n    verticalSnapPoses.push(\n        ...verticalInnerBoundPoses.filter(pos => verticalSnapPoses.indexOf(pos) < 0),\n    );\n    horizontalSnapPoses.push(\n        ...horizontalInnerBoundPoses.filter(pos => horizontalSnapPoses.indexOf(pos) < 0),\n    );\n}\nexport default {\n    name: \"snappable\",\n    props: {\n        snappable: [Boolean, Array],\n        snapCenter: Boolean,\n        snapHorizontal: Boolean,\n        snapVertical: Boolean,\n        snapElement: Boolean,\n        isDisplaySnapDigit: Boolean,\n        snapDigit: Number,\n        snapThreshold: Number,\n        horizontalGuidelines: Array,\n        verticalGuidelines: Array,\n        elementGuidelines: Array,\n        bounds: Object,\n        innerBounds: Object,\n    } as const,\n    render(moveable: MoveableManager<SnappableProps, SnappableState>, React: Renderer): any[] {\n        const {\n            top: targetTop,\n            left: targetLeft,\n            pos1, pos2, pos3, pos4,\n            snapRenderInfo,\n            targetClientRect,\n            containerClientRect,\n        } = moveable.state;\n        const clientLeft = targetClientRect.left - containerClientRect.left;\n        const clientTop = targetClientRect.top - containerClientRect.top;\n\n        const minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);\n        const minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);\n\n        if (!snapRenderInfo || !hasGuidelines(moveable, \"\")) {\n            return [];\n        }\n        const {\n            snapThreshold = 5,\n            snapDigit = 0,\n            isDisplaySnapDigit = true,\n        } = moveable.props;\n        const poses = getAbsolutePosesByState(moveable.state);\n        const { width, height, top, left, bottom, right } = getRect(poses);\n        const verticalSnapPoses: number[] = [];\n        const horizontalSnapPoses: number[] = [];\n        const verticalGuildelines: Guideline[] = [];\n        const horizontalGuidelines: Guideline[] = [];\n        const snapInfos: Array<{ vertical: SnapInfo, horizontal: SnapInfo }> = [];\n\n        if (snapRenderInfo.direction) {\n            snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));\n        }\n        if (snapRenderInfo.snap) {\n            const rect = getRect(poses);\n\n            if (snapRenderInfo.center) {\n                (rect as any).middle = (rect.top + rect.bottom) / 2;\n                (rect as any).center = (rect.left + rect.right) / 2;\n            }\n            snapInfos.push(checkSnaps(moveable, rect, true, 1));\n        }\n        snapInfos.forEach(snapInfo => {\n            const {\n                vertical: {\n                    posInfos: verticalPosInfos,\n                },\n                horizontal: {\n                    posInfos: horizontalPosInfos,\n                },\n            } = snapInfo;\n            verticalSnapPoses.push(...verticalPosInfos.map(posInfo => posInfo.pos));\n            horizontalSnapPoses.push(...horizontalPosInfos.map(posInfo => posInfo.pos));\n            verticalGuildelines.push(...getSnapGuidelines(verticalPosInfos));\n            horizontalGuidelines.push(...getSnapGuidelines(horizontalPosInfos));\n        });\n\n        addBoundGuidelines(\n            moveable,\n            [left, right],\n            [top, bottom],\n            verticalSnapPoses,\n            horizontalSnapPoses,\n        );\n        const elementHorizontalGroup = groupByElementGuidelines(\n            horizontalGuidelines,\n            clientLeft,\n            width,\n            0,\n        );\n        const elementVerticalGroup = groupByElementGuidelines(\n            verticalGuildelines,\n            clientTop,\n            height,\n            1,\n        );\n        const horizontalNames = [\"horizontal\", \"left\", \"top\", \"width\"] as const;\n        const verticalNames = [\"vertical\", \"top\", \"left\", \"height\"] as const;\n        return [\n            ...renderElementGroup(\n                elementHorizontalGroup,\n                horizontalNames,\n                minLeft,\n                clientLeft,\n                width,\n                targetTop,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                0,\n                React,\n            ),\n            ...renderElementGroup(\n                elementVerticalGroup,\n                verticalNames,\n                minTop,\n                clientTop,\n                height,\n                targetLeft,\n                snapThreshold,\n                isDisplaySnapDigit,\n                snapDigit,\n                1,\n                React,\n            ),\n            ...renderSnapPoses(\n                horizontalSnapPoses,\n                horizontalNames,\n                minLeft,\n                targetTop,\n                width,\n                React,\n            ),\n            ...renderSnapPoses(\n                verticalSnapPoses,\n                verticalNames,\n                minTop,\n                targetLeft,\n                height,\n                React,\n            ),\n            ...renderGuidelines(\n                horizontalGuidelines,\n                horizontalNames,\n                targetLeft,\n                targetTop,\n                0,\n                React,\n            ),\n            ...renderGuidelines(\n                verticalGuildelines,\n                verticalNames,\n                targetTop,\n                targetLeft,\n                1,\n                React,\n            ),\n        ];\n    },\n    dragStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = {\n            snap: true,\n            center: true,\n        };\n        snapStart(moveable);\n    },\n    pinchStart(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragControlCondition(e: any) {\n        return directionCondition(e) || rotatableDragControlCondtion(e);\n    },\n    dragControlStart(moveable: MoveableManager<SnappableProps, SnappableState>, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragControlEnd(moveable: MoveableManager<SnappableProps, SnappableState>) {\n        this.unset(moveable);\n    },\n    dragGroupStart(moveable: any, e: any) {\n        this.dragStart(moveable, e);\n    },\n    dragGroupEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    dragGroupControlStart(moveable: any, e: any) {\n        moveable.state.snapRenderInfo = null;\n        snapStart(moveable);\n    },\n    dragGroupControlEnd(moveable: any) {\n        this.unset(moveable);\n    },\n    unset(moveable: any) {\n        const state = moveable.state;\n\n        state.enableSnap = false;\n        state.guidelines = [];\n        state.snapRenderInfo = null;\n    },\n};\n","import { getDragDist, setDragStart } from \"../DraggerUtils\";\nimport { throttleArray, triggerEvent, fillParams, throttle, getDistSize, prefix } from \"../utils\";\nimport { minus, plus, getRad } from \"@moveable/matrix\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    DraggableProps, OnDrag, OnDragGroup,\n    OnDragGroupStart, OnDragStart, OnDragEnd, DraggableState, Renderer,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport { checkSnapDrag, startCheckSnapDrag } from \"./Snappable\";\nimport { IObject } from \"@daybrush/utils\";\n\n/**\n * @namespace Draggable\n * @memberof Moveable\n */\nexport default {\n    name: \"draggable\",\n    props: {\n        draggable: Boolean,\n        throttleDrag: Number,\n        throttleDragRotate: Number,\n    },\n    render(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        React: Renderer,\n    ) {\n        const throttleDragRotate = moveable.props.throttleDragRotate;\n        const { dragInfo, beforeOrigin } = moveable.state;\n\n        if (!throttleDragRotate || !dragInfo) {\n            return;\n        }\n        const dist = dragInfo.dist;\n\n        if (!dist[0] && !dist[1]) {\n            return;\n        }\n\n        const width = getDistSize(dist);\n        const rad = getRad(dist, [0, 0]);\n\n        return <div className={prefix(\n            \"line\",\n            \"horizontal\",\n            \"dragline\",\n            \"dashed\",\n        )} key={`dragRotateGuideline`} style={{\n            width: `${width}px`,\n            transform: `translate(${beforeOrigin[0]}px, ${beforeOrigin[1]}px) rotate(${rad}rad)`,\n        }} />;\n    },\n    dragStart(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ) {\n        const { datas, parentEvent, parentDragger } = e;\n        const state = moveable.state;\n        const {\n            targetTransform,\n            target,\n            dragger,\n        } = state;\n\n        if (dragger) {\n            return false;\n        }\n        state.dragger = parentDragger || moveable.targetDragger;\n        const style = window.getComputedStyle(target!);\n\n        datas.datas = {};\n        datas.left = parseFloat(style.left || \"\") || 0;\n        datas.top = parseFloat(style.top || \"\") || 0;\n        datas.bottom = parseFloat(style.bottom || \"\") || 0;\n        datas.right = parseFloat(style.right || \"\") || 0;\n        datas.transform = targetTransform;\n        datas.startTranslate = [0, 0];\n\n        setDragStart(moveable, { datas });\n\n        datas.prevDist = [0, 0];\n        datas.prevBeforeDist = [0, 0];\n        datas.isDrag = false;\n\n        startCheckSnapDrag(moveable, datas);\n        const params = fillParams<OnDragStart>(moveable, e, {\n            set: (translate: number[]) => {\n                datas.startTranslate = translate;\n            },\n        });\n        const result = parentEvent || triggerEvent(moveable, \"onDragStart\", params);\n\n        if (result !== false) {\n            datas.isDrag = true;\n            moveable.state.dragInfo = {\n                startRect: moveable.getRect(),\n                dist: [0, 0],\n            };\n        } else {\n            state.dragger = null;\n            datas.isPinch = false;\n        }\n        return datas.isDrag ? params : false;\n    },\n    drag(\n        moveable: MoveableManager<DraggableProps, any>,\n        e: any,\n    ): OnDrag | undefined {\n        const { datas, parentEvent, parentFlag } = e;\n        let { distX, distY } = e;\n        const { isPinch, isDrag, prevDist, prevBeforeDist, transform, startTranslate } = datas;\n\n        if (!isDrag) {\n            return;\n        }\n        const props = moveable.props;\n\n        const parentMoveable = props.parentMoveable;\n        const throttleDrag = parentEvent ? 0 : (props.throttleDrag || 0);\n        const throttleDragRotate = parentEvent ? 0 : (props.throttleDragRotate || 0);\n\n        let isSnap = false;\n        let dragRotateRad = 0;\n\n        if (throttleDragRotate > 0 && (distX || distY)) {\n            const deg = throttle(getRad([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate);\n            const r = getDistSize([distX, distY]);\n            dragRotateRad = deg * Math.PI / 180;\n\n            distX = r * Math.cos(dragRotateRad);\n            distY = r * Math.sin(dragRotateRad);\n        }\n\n        if (!isPinch && !parentEvent && !parentFlag && (distX || distY)) {\n            const [verticalInfo, horizontalInfo] = checkSnapDrag(\n                moveable, distX, distY, throttleDragRotate, datas,\n            );\n            const {\n                isSnap: isVerticalSnap,\n                isBound: isVerticalBound,\n                offset: verticalOffset,\n            } = verticalInfo;\n            const {\n                isSnap: isHorizontalSnap,\n                isBound: isHorizontalBound,\n                offset: horizontalOffset,\n            } = horizontalInfo;\n            isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;\n\n            distX += verticalOffset;\n            distY += horizontalOffset;\n        }\n        datas.passDistX = distX;\n        datas.passDistY = distY;\n        const beforeTranslate = plus(getDragDist({ datas, distX, distY }, true), startTranslate);\n        const translate = plus(getDragDist({ datas, distX, distY }, false), startTranslate);\n\n        if (!throttleDragRotate && !isSnap) {\n            throttleArray(translate, throttleDrag);\n            throttleArray(beforeTranslate, throttleDrag);\n        }\n\n        const beforeDist = minus(beforeTranslate, startTranslate);\n        const dist = minus(translate, startTranslate);\n        const delta = minus(dist, prevDist);\n        const beforeDelta = minus(beforeDist, prevBeforeDist);\n\n        datas.prevDist = dist;\n        datas.prevBeforeDist = beforeDist;\n\n        const left = datas.left + beforeDist[0];\n        const top = datas.top + beforeDist[1];\n        const right = datas.right - beforeDist[0];\n        const bottom = datas.bottom - beforeDist[1];\n        const nextTransform = `${transform} translate(${dist[0]}px, ${dist[1]}px)`;\n\n        moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;\n        if (!parentEvent && !parentMoveable && delta.every(num => !num) && beforeDelta.some(num => !num)) {\n            return;\n        }\n        const params = fillParams<OnDrag>(moveable, e, {\n            transform: nextTransform,\n            dist,\n            delta,\n            translate,\n            beforeDist,\n            beforeDelta,\n            beforeTranslate,\n            left,\n            top,\n            right,\n            bottom,\n            isPinch,\n        });\n\n        !parentEvent && triggerEvent(moveable, \"onDrag\", params);\n        return params;\n    },\n    dragEnd(\n        moveable: MoveableManager<DraggableProps, DraggableState>,\n        e: any,\n    ) {\n        const { parentEvent, datas, isDrag } = e;\n\n        moveable.state.dragger = null;\n        moveable.state.dragInfo = null;\n        if (!datas.isDrag) {\n            return;\n        }\n        datas.isDrag = false;\n        !parentEvent && triggerEvent(moveable, \"onDragEnd\", fillParams<OnDragEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        const params = this.dragStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const events = triggerChildAble(moveable, this, \"dragStart\", datas, e);\n        const nextParams: OnDragGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onDragGroupStart\", nextParams);\n\n        datas.isDrag = result !== false;\n\n        return datas.isDrag ? params : false;\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        const datas = e.datas;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        const params = this.drag(moveable, e);\n        const { passDistX, passDistY } = e.datas;\n        const events = triggerChildAble(moveable, this, \"drag\", datas, { ...e, distX: passDistX, distY: passDistY });\n\n        if (!params) {\n            return;\n        }\n        const nextParams: OnDragGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onDragGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isDrag) {\n            return;\n        }\n        this.dragEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragEnd\", datas, e);\n        triggerEvent(moveable, \"onDragGroupEnd\", fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        }));\n\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Draggable#request\n     * @param {object} [e] - the draggable's request parameter\n     * @param {number} [e.x] - x position\n     * @param {number} [e.y] - y position\n     * @param {number} [e.deltaX] - X number to move\n     * @param {number} [e.deltaY] - Y number to move\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"draggable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * // Use Absolute Value\n     * moveable.request(\"draggable\", { x: 200, y: 100, isInstant: true });\n     * moveable.request(\"draggable\", { x: 220, y: 100, isInstant: true });\n     * moveable.request(\"draggable\", { x: 240, y: 100, isInstant: true });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManager<any, any>) {\n        const datas = {};\n        const rect = moveable.getRect();\n        let distX = 0;\n        let distY = 0;\n\n        return {\n            isControl: false,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                if (\"x\" in e) {\n                    distX = e.x - rect.left;\n                } else if (\"deltaX\" in e) {\n                    distX += e.deltaX;\n                }\n                if (\"y\" in e) {\n                    distY = e.y - rect.top;\n                } else if (\"deltaY\" in e) {\n                    distY += e.deltaY;\n                }\n\n                return { datas, distX, distY };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n    unset(moveable: any) {\n        moveable.state.dragInfo = null;\n    },\n};\n","import { MoveableManagerState, OnCustomDrag } from \"./types\";\nimport { convertDragDist } from \"./utils\";\n\nexport function setCustomDrag(\n    state: MoveableManagerState<any>,\n    delta: number[], inputEvent: any,\n    isConvert: boolean = true,\n) {\n    const result = state.dragger!.move(delta, inputEvent);\n    return {\n        ...(isConvert ? convertDragDist(state, result) : result),\n        parentEvent: true,\n    };\n}\n\nexport default class CustomDragger {\n    private prevX = 0;\n    private prevY = 0;\n    private startX = 0;\n    private startY = 0;\n    private isDrag = false;\n    private isFlag = false;\n    private datas = {};\n\n    public dragStart(client: number[], inputEvent: any)  {\n        this.isDrag = false;\n        this.isFlag = false;\n        this.datas = {};\n\n        return this.move(client, inputEvent);\n    }\n    public drag(client: number[], inputEvent: any) {\n        return this.move([\n            client[0] - this.prevX,\n            client[1] - this.prevY,\n        ], inputEvent);\n    }\n    public move(delta: number[], inputEvent: any): OnCustomDrag {\n        let clientX!: number;\n        let clientY!: number;\n        if (!this.isFlag) {\n            this.prevX = delta[0];\n            this.prevY = delta[1];\n            this.startX = delta[0];\n            this.startY = delta[1];\n\n            clientX = delta[0];\n            clientY = delta[1];\n\n            this.isFlag = true;\n        } else {\n\n            clientX = this.prevX + delta[0];\n            clientY = this.prevY + delta[1];\n            this.isDrag = true;\n        }\n\n        this.prevX = clientX;\n        this.prevY = clientY;\n\n        return {\n            clientX,\n            clientY,\n            inputEvent,\n            isDrag: this.isDrag,\n            distX: clientX - this.startX,\n            distY: clientY - this.startY,\n            deltaX: delta[0],\n            deltaY: delta[1],\n            datas: this.datas,\n            parentEvent: true,\n            parentDragger: this,\n        };\n    }\n}\n","import { throttle, prefix, triggerEvent, fillParams, getRotationRad, getClientRect, caculatePosition } from \"../utils\";\nimport { IObject, hasClass } from \"@daybrush/utils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    RotatableProps, OnRotateGroup, OnRotateGroupEnd,\n    Renderer, OnRotateGroupStart, OnRotateStart, OnRotate,\n    OnRotateEnd, MoveableClientRect, SnappableProps, SnappableState,\n} from \"../types\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { triggerChildAble } from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { minus, plus, getRad, rotate as rotateMatrix } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapRotate } from \"./Snappable\";\n\n/**\n * @namespace Rotatable\n * @memberof Moveable\n */\n\nfunction setRotateStartInfo(\n    moveable: MoveableManager<any, any>,\n    datas: IObject<any>, clientX: number, clientY: number, origin: number[], rect: MoveableClientRect) {\n\n    const n = moveable.state.is3d ? 4 : 3;\n    const nextOrigin = caculatePosition(moveable.state.rootMatrix, origin, n);\n    const startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);\n\n    datas.startAbsoluteOrigin = startAbsoluteOrigin;\n    datas.prevDeg = getRad(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;\n    datas.prevSnapDeg = datas.prevDeg;\n    datas.startDeg = datas.prevDeg;\n    datas.loop = 0;\n}\nfunction getParentDeg(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    parentDist: number,\n    direction: number,\n    startRotate: number,\n) {\n    const {\n        prevDeg,\n    } = datas;\n\n    const absoluteDeg = startRotate + parentDist;\n    const dist = checkSnapRotate(\n        moveable,\n        moveableRect,\n        datas.origin,\n        parentDist,\n    );\n    datas.prevDeg = dist;\n\n    const delta = direction * (dist - prevDeg);\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getDeg(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    deg: number,\n    direction: number,\n    startRotate: number,\n    throttleRotate: number,\n    isSnap?: boolean,\n) {\n    const {\n        prevDeg,\n        prevSnapDeg,\n        startDeg,\n        loop: prevLoop,\n    } = datas;\n\n    if (prevDeg > deg && prevDeg > 270 && deg < 90) {\n        // 360 => 0\n        ++datas.loop;\n    } else if (prevDeg < deg && prevDeg < 90 && deg > 270) {\n        // 0 => 360\n        --datas.loop;\n    }\n    const loop = datas.loop;\n    const absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startRotate;\n    let absoluteDeg = loop * 360 + deg - startDeg + startRotate;\n\n    datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    absoluteDeg = throttle(absoluteDeg, throttleRotate);\n    let dist = direction * (absoluteDeg - startRotate);\n    if (isSnap) {\n        dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);\n        absoluteDeg = dist / direction + startRotate;\n    }\n    datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startRotate;\n\n    const delta = direction * (absoluteDeg - absolutePrevSnapDeg);\n\n    return [delta, dist, absoluteDeg];\n}\nfunction getRotateInfo(\n    moveable: MoveableManager<any, any>,\n    moveableRect: any,\n    datas: IObject<any>,\n    direction: number,\n    clientX: number, clientY: number,\n    startRotate: number,\n    throttleRotate: number,\n) {\n    return getDeg(\n        moveable,\n        moveableRect,\n        datas,\n        getRad(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180,\n        direction,\n        startRotate,\n        throttleRotate,\n        true,\n    );\n}\n\nexport function getPositions(\n    rotationPosition: \"top\" | \"bottom\" | \"left\" | \"right\",\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    pos4: number[],\n) {\n    if (rotationPosition === \"left\") {\n        return [pos3, pos1];\n    } else if (rotationPosition === \"right\") {\n        return [pos2, pos4];\n    } else if (rotationPosition === \"bottom\") {\n        return [pos4, pos3];\n    }\n    return [pos1, pos2];\n}\n\nexport function dragControlCondition(e: any) {\n    if (e.isRequest) {\n        return true;\n    }\n    return hasClass(e.inputEvent.target, prefix(\"rotation\"));\n}\n\nexport default {\n    name: \"rotatable\",\n    canPinch: true,\n    props: {\n        rotatable: Boolean,\n        rotationPosition: String,\n        throttleRotate: Number,\n    },\n    render(moveable: MoveableManager<RotatableProps>, React: Renderer): any {\n        const {\n            rotatable,\n            rotationPosition,\n        } = moveable.props;\n        if (!rotatable) {\n            return null;\n        }\n        const { pos1, pos2, pos3, pos4, direction } = moveable.state;\n        const poses = getPositions(rotationPosition!, pos1, pos2, pos3, pos4);\n        const rotationRad = getRotationRad(poses, direction);\n\n        return (\n            <div key=\"rotation\" className={prefix(\"line rotation-line\")} style={{\n                // tslint:disable-next-line: max-line-length\n                transform: `translate(-50%) translate(${(poses[0][0] + poses[1][0]) / 2}px, ${(poses[0][1] + poses[1][1]) / 2}px) rotate(${rotationRad}rad)`,\n            }}>\n                <div className={prefix(\"control\", \"rotation\")}></div>\n            </div>\n        );\n    },\n    dragControlCondition,\n    dragControlStart(\n        moveable: MoveableManager<RotatableProps & SnappableProps, SnappableState>,\n        e: any) {\n        const {\n            datas,\n            clientX, clientY,\n            parentRotate, parentFlag, pinchFlag,\n            isRequest,\n        } = e;\n        const {\n            target, left, top, origin, beforeOrigin,\n            direction, beforeDirection, targetTransform,\n        } = moveable.state;\n\n        if (!isRequest && !target) {\n            return false;\n        }\n\n        const rect = moveable.getRect();\n        datas.rect = rect;\n        datas.transform = targetTransform;\n        datas.left = left;\n        datas.top = top;\n\n        if (isRequest || pinchFlag || parentFlag) {\n            const externalRotate = parentRotate || 0;\n\n            datas.beforeInfo = {\n                origin: rect.beforeOrigin,\n                prevDeg: externalRotate,\n                startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n            datas.afterInfo = {\n                origin: rect.origin,\n                prevDeg: externalRotate, startDeg: externalRotate,\n                prevSnapDeg: externalRotate, loop: 0,\n            };\n        } else {\n            datas.beforeInfo = { origin: rect.beforeOrigin };\n            datas.afterInfo = { origin: rect.origin };\n\n            const controlRect = getClientRect(moveable.controlBox.getElement());\n\n            setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, controlRect);\n            setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, controlRect);\n        }\n\n        datas.direction = direction;\n        datas.beforeDirection = beforeDirection;\n        datas.startRotate = 0;\n        datas.datas = {};\n\n        const params = fillParams<OnRotateStart>(moveable, e, {\n            set: (rotatation: number) => {\n                datas.startRotate = rotatation;\n            },\n        });\n        const result = triggerEvent(moveable, \"onRotateStart\", params);\n        datas.isRotate = result !== false;\n        moveable.state.snapRenderInfo = {};\n\n        return datas.isRotate ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<RotatableProps>,\n        e: any,\n    ) {\n        const { datas, clientX, clientY, parentRotate, parentFlag, pinchFlag } = e;\n        const {\n            direction,\n            beforeDirection,\n            beforeInfo,\n            afterInfo,\n            isRotate,\n            startRotate,\n            rect,\n        } = datas;\n\n        if (!isRotate) {\n            return;\n        }\n        const {\n            throttleRotate = 0,\n            parentMoveable,\n        } = moveable.props;\n\n        let delta: number;\n        let dist: number;\n        let rotate: number;\n        let beforeDelta: number;\n        let beforeDist: number;\n        let beforeRotate: number;\n\n        if (\"parentDist\" in e) {\n            const parentDist = e.parentDist;\n\n            [delta, dist, rotate]\n                = getParentDeg(moveable, rect, afterInfo, parentDist, direction, startRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getParentDeg(moveable, rect, beforeInfo, parentDist, direction, startRotate);\n        } else if (pinchFlag || parentFlag) {\n            [delta, dist, rotate]\n                = getDeg(moveable, rect, afterInfo, parentRotate, direction, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate]\n                = getDeg(moveable, rect, beforeInfo, parentRotate, direction, startRotate, throttleRotate);\n        } else {\n            [delta, dist, rotate]\n                = getRotateInfo(moveable, rect, afterInfo, direction, clientX, clientY, startRotate, throttleRotate);\n            [beforeDelta, beforeDist, beforeRotate] = getRotateInfo(\n                moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startRotate, throttleRotate,\n            );\n        }\n\n        if (!delta && !beforeDelta && !parentMoveable) {\n            return;\n        }\n        const params = fillParams<OnRotate>(moveable, e, {\n            delta,\n            dist,\n            rotate,\n            beforeDist,\n            beforeDelta,\n            beforeRotate,\n            transform: `${datas.transform} rotate(${dist}deg)`,\n            isPinch: !!pinchFlag,\n        });\n        triggerEvent(moveable, \"onRotate\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<RotatableProps>, e: any) {\n        const { datas, isDrag } = e;\n\n        if (!datas.isRotate) {\n            return false;\n        }\n        datas.isRotate = false;\n\n        triggerEvent(moveable, \"onRotateEnd\", fillParams<OnRotateEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: dragControlCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas, inputEvent } = e;\n        const {\n            left: parentLeft,\n            top: parentTop,\n            beforeOrigin: parentBeforeOrigin,\n        } = moveable.state;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n\n        params.set(moveable.rotation);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            { ...e, parentRotate: 0 },\n            (child, childDatas, eventParams) => {\n                const { left, top, beforeOrigin } = child.state;\n                const childClient = plus(\n                    minus([left, top], [parentLeft, parentTop]),\n                    minus(beforeOrigin, parentBeforeOrigin),\n                );\n\n                childDatas.prevClient = childClient;\n                eventParams.dragStart = Draggable.dragStart(\n                    child,\n                    new CustomDragger().dragStart(childClient, inputEvent),\n                );\n            },\n        );\n\n        const nextParams: OnRotateGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onRotateGroupStart\", nextParams);\n\n        datas.isRotate = result !== false;\n\n        return datas.isRotate ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { inputEvent, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const parentRotate = params.beforeDist;\n        const deg = params.beforeDelta;\n        const rad = deg / 180 * Math.PI;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            { ...e, parentRotate },\n            (child, childDatas, result, i) => {\n                const [prevX, prevY] = childDatas.prevClient;\n                const [clientX, clientY] = rotateMatrix([prevX, prevY], rad);\n                const delta = [clientX - prevX, clientY - prevY];\n\n                childDatas.prevClient = [clientX, clientY];\n\n                const dragResult = Draggable.drag(\n                    child,\n                    setCustomDrag(child.state, delta, inputEvent, false),\n                );\n                result.drag = dragResult;\n            },\n        );\n        moveable.rotation = params.beforeRotate;\n\n        const nextParams: OnRotateGroup = {\n            targets: moveable.props.targets!,\n            events,\n            set: (rotation: number) => {\n                moveable.rotation = rotation;\n            },\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onRotateGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isRotate) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnRotateGroupEnd = fillParams(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onRotateGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Rotatable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.deltaRotate=0] -  delta number of rotation\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"rotatable\", { deltaRotate: 10, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"rotatable\");\n     *\n     * // request\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     * requester.request({ deltaRotate: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distRotate = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas };\n            },\n            request(e: IObject<any>) {\n                distRotate += e.deltaRotate;\n\n                return { datas, parentDist: distRotate };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { prefix, getControlTransform, throttle } from \"./utils\";\nimport { ResizableProps, ScalableProps, WarpableProps, Renderer } from \"./types\";\nimport { DIRECTION_INDEXES, DIRECTION_ROTATIONS } from \"./consts\";\nimport { IObject } from \"@daybrush/utils\";\n\nexport function renderControls(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    defaultDirections: string[],\n    React: Renderer,\n): any[] {\n    const {\n        pos1, pos2, pos3, pos4,\n        rotation,\n    } = moveable.state;\n    const {\n        renderDirections: directions = defaultDirections,\n    } = moveable.props;\n    const poses = [pos1, pos2, pos3, pos4];\n\n    const directionMap: IObject<boolean> = {};\n    directions.forEach(direction => {\n        directionMap[direction] = true;\n    });\n    return directions.map(direction => {\n        const indexes = DIRECTION_INDEXES[direction];\n\n        if (!indexes || !directionMap[direction]) {\n            return null;\n        }\n        const directionRotation = (throttle(rotation / Math.PI * 180, 15) + DIRECTION_ROTATIONS[direction]) % 180;\n\n        return (\n            <div className={prefix(\"control\", \"direction\", direction)}\n                data-rotation={directionRotation} data-direction={direction} key={`direction-${direction}`}\n                style={getControlTransform(rotation, ...indexes.map(index => poses[index]))}></div>\n        );\n    });\n}\nexport function renderAllDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n) {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\", \"n\", \"w\", \"s\", \"e\"], React);\n}\nexport function renderDiagonalDirections(\n    moveable: MoveableManager<Partial<ResizableProps & ScalableProps & WarpableProps>>,\n    React: Renderer,\n): any[] {\n    return renderControls(moveable, [\"nw\", \"ne\", \"sw\", \"se\"], React);\n}\n","import {\n    throttle, getDirection, triggerEvent,\n    getAbsolutePosesByState, fillParams, getKeepRatioHeight, getKeepRatioWidth, getCSSSize, getDistSize,\n} from \"../utils\";\nimport {\n    setDragStart,\n    getDragDist,\n    getResizeDist,\n    getPosByReverseDirection,\n    getStartDirection,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport {\n    ResizableProps, OnResizeGroup, OnResizeGroupEnd,\n    Renderer, OnResizeGroupStart, DraggableProps, OnDrag, OnResizeStart, SnappableState,\n    OnResize, OnResizeEnd,\n} from \"../types\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapSize } from \"./Snappable\";\nimport {\n    directionCondition,\n} from \"./utils\";\nimport { IObject } from \"@daybrush/utils\";\nimport { TINY_NUM } from \"../consts\";\n\n/**\n * @namespace Resizable\n * @memberof Moveable\n */\n\nexport default {\n    name: \"resizable\",\n    ableGroup: \"size\",\n    updateRect: true,\n    canPinch: true,\n    props: {\n        resizable: Boolean,\n        throttleResize: Number,\n        renderDirections: Array,\n        baseDirection: Array,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, edge } = moveable.props;\n        if (resizable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ResizableProps & DraggableProps, SnappableState>,\n        e: any,\n    ) {\n        const {\n            inputEvent,\n            pinchFlag,\n            parentDirection,\n            datas,\n        } = e;\n\n        const direction = parentDirection || (pinchFlag ? [1, 1] : getDirection(inputEvent.target));\n\n        const { target, width, height } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        !pinchFlag && setDragStart(moveable, { datas });\n\n        datas.datas = {};\n        datas.direction = direction;\n        datas.startOffsetWidth = width;\n        datas.startOffsetHeight = height;\n        datas.prevWidth = 0;\n        datas.prevHeight = 0;\n        [\n            datas.startWidth,\n            datas.startHeight,\n        ] = getCSSSize(target);\n        datas.transformOrigin = moveable.props.transformOrigin;\n        datas.startDirection = getStartDirection(moveable, direction);\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, datas.startDirection);\n        datas.fixedOriginalPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnResizeStart>(moveable, e, {\n            direction,\n            set: ([startWidth, startHeight]: number[]) => {\n                datas.startWidth = startWidth;\n                datas.startHeight = startHeight;\n            },\n            setOrigin: (origin: Array<string | number>) => {\n                datas.transformOrigin = origin;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ),\n        });\n        const result = triggerEvent(moveable, \"onResizeStart\", params);\n        if (result !== false) {\n            datas.isResize = true;\n            moveable.state.snapRenderInfo = {\n                direction,\n            };\n        }\n        return datas.isResize ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const {\n            datas,\n            distX, distY,\n            parentFlag, pinchFlag,\n            parentDistance, parentScale, inputEvent,\n            parentKeepRatio,\n            dragClient,\n            parentDist,\n        } = e;\n        const {\n            direction,\n            isResize,\n            transformOrigin,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            startWidth,\n            startHeight,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n        const {\n            throttleResize = 0,\n            parentMoveable,\n        } = moveable.props;\n        let sizeDirection = direction;\n\n        if (!direction[0] && !direction[1]) {\n            sizeDirection = [1, 1];\n        }\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const isWidth = sizeDirection[0] || !sizeDirection[1];\n        const ratio = isWidth ? startOffsetHeight / startOffsetWidth : startOffsetWidth / startOffsetHeight;\n        const startDirection = keepRatio || parentFlag ? direction : datas.startDirection;\n        const fixedPosition = dragClient || (keepRatio ? datas.fixedOriginalPosition : datas.fixedPosition);\n        let distWidth: number = 0;\n        let distHeight: number = 0;\n\n        if (parentDist) {\n            distWidth = parentDist[0];\n            distHeight = parentDist[1];\n        } else if (parentScale) {\n            distWidth = (parentScale[0] - 1) * startOffsetWidth;\n            distHeight = (parentScale[1] - 1) * startOffsetHeight;\n\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                distWidth = parentDistance;\n                distHeight = parentDistance * startOffsetHeight / startOffsetWidth;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n\n            distWidth = sizeDirection[0] * dist[0];\n            distHeight = sizeDirection[1] * dist[1];\n\n            if (keepRatio && startOffsetWidth && startOffsetHeight) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], sizeDirection);\n                const ratioRad = getRad([0, 0], [startOffsetWidth, startOffsetHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!sizeDirection[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!sizeDirection[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n        }\n        let nextWidth = sizeDirection[0] || keepRatio\n            ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;\n        let nextHeight = sizeDirection[1] || keepRatio\n            ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;\n\n        if (keepRatio && startOffsetWidth && startOffsetHeight) {\n            // startOffsetWidth : startOffsetHeight = nextWidth : nextHeight\n            nextHeight = nextWidth * startOffsetHeight / startOffsetWidth;\n        }\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapSize(\n                moveable, nextWidth,\n                nextHeight, direction,\n                datas.fixedOriginalPosition,\n                parentDist,\n                datas,\n            );\n        }\n        if (parentDist) {\n            !parentDist[0] && (snapDist[0] = 0);\n            !parentDist[1] && (snapDist[1] = 0);\n        }\n        if (keepRatio) {\n            if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nextWidth = throttle(nextWidth, throttleResize!);\n                } else {\n                    nextHeight = throttle(nextHeight, throttleResize!);\n                }\n            }\n            if (\n                (sizeDirection[0] && !sizeDirection[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nextWidth += snapDist[0];\n                nextHeight = getKeepRatioHeight(nextWidth, isWidth, ratio);\n            } else if (\n                (!sizeDirection[0] && sizeDirection[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nextHeight += snapDist[1];\n                nextWidth = getKeepRatioWidth(nextHeight, isWidth, ratio);\n            }\n        } else {\n            nextWidth += snapDist[0];\n            nextHeight += snapDist[1];\n            if (!snapDist[0]) {\n                nextWidth = throttle(nextWidth, throttleResize!);\n            }\n            if (!snapDist[1]) {\n                nextHeight = throttle(nextHeight, throttleResize!);\n            }\n        }\n        nextWidth = Math.round(nextWidth);\n        nextHeight = Math.round(nextHeight);\n\n        distWidth = nextWidth - startOffsetWidth;\n        distHeight = nextHeight - startOffsetHeight;\n\n        const delta = [distWidth - prevWidth, distHeight - prevHeight];\n\n        datas.prevWidth = distWidth;\n        datas.prevHeight = distHeight;\n\n        if (!parentMoveable && delta.every(num => !num)) {\n            return;\n        }\n\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getResizeDist(\n                moveable,\n                nextWidth, nextHeight,\n                startDirection, fixedPosition, transformOrigin);\n\n        const params = fillParams<OnResize>(moveable, e, {\n            width: startWidth + distWidth,\n            height: startHeight + distHeight,\n            offsetWidth: nextWidth,\n            offsetHeight: nextHeight,\n            direction,\n            dist: [distWidth, distHeight],\n            delta,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onResize\", params);\n        return params;\n    },\n    dragControlAfter(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const datas = e.datas;\n        const {\n            isResize,\n            startOffsetWidth,\n            startOffsetHeight,\n            prevWidth,\n            prevHeight,\n        } = datas;\n\n        if (!isResize) {\n            return;\n        }\n        const {\n            width,\n            height,\n        } = moveable.state;\n        const errorWidth = width - (startOffsetWidth + prevWidth);\n        const errorHeight = height - (startOffsetHeight + prevHeight);\n        const isErrorWidth = Math.abs(errorWidth) > 3;\n        const isErrorHeight = Math.abs(errorHeight) > 3;\n\n        if (isErrorWidth) {\n            datas.startWidth += errorWidth;\n            datas.startOffsetWidth += errorWidth;\n            datas.prevWidth += errorWidth;\n        }\n        if (isErrorHeight) {\n            datas.startHeight += errorHeight;\n            datas.startOffsetHeight += errorHeight;\n            datas.prevHeight += errorHeight;\n        }\n        if (isErrorWidth || isErrorHeight) {\n            this.dragControl(moveable, e);\n            return true;\n        }\n    },\n    dragControlEnd(\n        moveable: MoveableManager<ResizableProps & DraggableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isResize) {\n            return false;\n        }\n        datas.isResize = false;\n\n        const params = fillParams<OnResizeEnd>(moveable, e, {\n            isDrag,\n        });\n        triggerEvent(moveable, \"onResizeEnd\", params);\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getPosByReverseDirection(getAbsolutePosesByState(moveable.state), direction);\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getPosByReverseDirection(getAbsolutePosesByState(child.state), direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnResizeGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onResizeGroupStart\", nextParams);\n\n        datas.isResize = result !== false;\n        return datas.isResize ? params : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isResize) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n\n        if (!params) {\n            return;\n        }\n        const {\n            offsetWidth, offsetHeight, dist,\n        } = params;\n\n        const keepRatio = moveable.props.keepRatio;\n\n        const parentScale = [\n            offsetWidth / (offsetWidth - dist[0]),\n            offsetHeight / (offsetHeight - dist[1]),\n        ];\n        const fixedPosition = datas.fixedOriginalPosition;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * parentScale[0],\n                        childDatas.originalY * parentScale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentScale,\n                    dragClient: plus(fixedPosition, [clientX, clientY]),\n                    parentKeepRatio: keepRatio,\n                };\n            },\n        );\n        const nextParams: OnResizeGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onResizeGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isResize) {\n            return;\n        }\n\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams: OnResizeGroupEnd = fillParams<OnResizeGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onResizeGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Resizable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to resize\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * // Use Relative Value\n     * moveable.request(\"resizable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"resizable\");\n     *\n     * // request\n     * // Use Relative Value\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // Use Absolute Value\n     * moveable.request(\"resizable\", { offsetWidth: 100, offsetHeight: 100, isInstant: true });\n     * moveable.request(\"resizable\", { offsetWidth: 110, offsetHeight: 100, isInstant: true });\n     * moveable.request(\"resizable\", { offsetWidth: 120, offsetHeight: 100, isInstant: true });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request(moveable: MoveableManager<any>) {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n        const rect = moveable.getRect();\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                if (\"offsetWidth\" in e) {\n                    distWidth = e.offsetWidth - rect.offsetWidth;\n                } else if (\"deltaWidth\" in e) {\n                    distWidth += e.deltaWidth;\n                }\n                if (\"offsetHeight\" in e) {\n                    distHeight = e.offsetHeight - rect.offsetHeight;\n                } else if (\"deltaHeight\" in e) {\n                    distHeight += e.deltaHeight;\n                }\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import {\n    throttle, getDirection, triggerEvent, multiply2,\n    fillParams, getKeepRatioHeight, getKeepRatioWidth, getDistSize,\n} from \"../utils\";\nimport { MIN_SCALE } from \"../consts\";\nimport {\n    setDragStart, getDragDist,\n    getScaleDist,\n    getAbsoluteFixedPosition,\n} from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport { renderAllDirections, renderDiagonalDirections } from \"../renderDirection\";\nimport {\n    ScalableProps, ResizableProps, OnScaleGroup, OnScaleGroupEnd,\n    Renderer, OnScaleGroupStart, DraggableProps, OnDragStart,\n    OnDrag, SnappableState, GroupableProps, OnScaleStart, OnScale, OnScaleEnd,\n} from \"../types\";\nimport {\n    triggerChildAble,\n} from \"../groupUtils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport Draggable from \"./Draggable\";\nimport { getRad, caculate, createRotateMatrix, plus } from \"@moveable/matrix\";\nimport CustomDragger, { setCustomDrag } from \"../CustomDragger\";\nimport { checkSnapScale } from \"./Snappable\";\nimport { isArray, IObject } from \"@daybrush/utils\";\nimport {\n    directionCondition,\n} from \"./utils\";\n\n/**\n * @namespace Scalable\n * @memberof Moveable\n */\nexport default {\n    name: \"scalable\",\n    ableGroup: \"size\",\n    canPinch: true,\n    props: {\n        scalable: Boolean,\n        throttleScale: Number,\n        renderDirections: String,\n        keepRatio: Boolean,\n    },\n    render(moveable: MoveableManager<Partial<ResizableProps & ScalableProps>>, React: Renderer): any[] | undefined {\n        const { resizable, scalable, edge } = moveable.props;\n        if (!resizable && scalable) {\n            if (edge) {\n                return renderDiagonalDirections(moveable, React);\n            }\n            return renderAllDirections(moveable, React);\n        }\n    },\n    dragControlCondition: directionCondition,\n    dragControlStart(\n        moveable: MoveableManager<ScalableProps & DraggableProps, SnappableState>,\n        e: any) {\n\n        const { datas, pinchFlag, inputEvent, parentDirection } = e;\n        const direction = parentDirection || (pinchFlag ? [1, 1] : getDirection(inputEvent.target));\n        const {\n            width,\n            height,\n            targetTransform,\n            target,\n        } = moveable.state;\n\n        if (!direction || !target) {\n            return false;\n        }\n        if (!pinchFlag) {\n            setDragStart(moveable, { datas });\n        }\n\n        datas.datas = {};\n        datas.transform = targetTransform;\n        datas.prevDist = [1, 1];\n        datas.direction = direction;\n        datas.width = width;\n        datas.height = height;\n        datas.startScale = [1, 1];\n        datas.fixedPosition = getAbsoluteFixedPosition(moveable, direction);\n\n        const params = fillParams<OnScaleStart>(moveable, e, {\n            direction,\n            set: (scale: number[]) => {\n                datas.startScale = scale;\n            },\n            dragStart: Draggable.dragStart(\n                moveable,\n                new CustomDragger().dragStart([0, 0], inputEvent),\n            ) as OnDragStart,\n        });\n        const result = triggerEvent(moveable, \"onScaleStart\", params);\n\n        if (result !== false) {\n            datas.isScale = true;\n            moveable.state.snapRenderInfo = {\n                direction,\n            };\n\n        }\n        return datas.isScale ? params : false;\n    },\n    dragControl(\n        moveable: MoveableManager<ScalableProps & DraggableProps & GroupableProps, SnappableState>,\n        e: any) {\n        const {\n            datas, distX, distY,\n            parentScale,\n            parentDistance,\n            parentKeepRatio,\n            parentFlag, pinchFlag, inputEvent,\n            dragClient,\n            parentDist,\n        } = e;\n        const {\n            prevDist,\n            direction,\n            width,\n            height,\n            transform,\n            isScale,\n            startScale,\n        } = datas;\n\n        if (!isScale) {\n            return false;\n        }\n\n        const {\n            throttleScale,\n            parentMoveable,\n        } = moveable.props;\n        const keepRatio = moveable.props.keepRatio || parentKeepRatio;\n        const state = moveable.state;\n        const isWidth = direction[0] || !direction[1];\n        const startWidth = width * startScale[0];\n        const startHeight = height * startScale[1];\n        const ratio = isWidth ? startHeight / startWidth : startWidth / startHeight;\n        let scaleX: number = 1;\n        let scaleY: number = 1;\n\n        if (parentScale) {\n            scaleX = parentScale[0];\n            scaleY = parentScale[1];\n        } else if (pinchFlag) {\n            if (parentDistance) {\n                scaleX = (width + parentDistance) / width;\n                scaleY = (height + parentDistance * height / width) / height;\n            }\n        } else {\n            const dist = getDragDist({ datas, distX, distY });\n            let distWidth = direction[0] * dist[0];\n            let distHeight = direction[1] * dist[1];\n\n            if (keepRatio && width && height) {\n                const rad = getRad([0, 0], dist);\n                const standardRad = getRad([0, 0], direction);\n                const ratioRad = getRad([0, 0], [startWidth, startHeight]);\n                const size = getDistSize([distWidth, distHeight]);\n                const signSize = Math.cos(rad - standardRad) * size;\n\n                if (!direction[0]) {\n                    // top, bottom\n                    distHeight = signSize;\n                    distWidth = getKeepRatioWidth(distHeight, isWidth, ratio);\n                } else if (!direction[1]) {\n                    // left, right\n                    distWidth = signSize;\n                    distHeight = getKeepRatioHeight(distWidth, isWidth, ratio);\n                } else {\n                    // two-way\n                    distWidth = Math.cos(ratioRad) * signSize;\n                    distHeight = Math.sin(ratioRad) * signSize;\n                }\n            }\n            scaleX = (width + distWidth) / width;\n            scaleY = (height + distHeight) / height;\n        }\n        scaleX = direction[0] || keepRatio ? scaleX * startScale[0] : startScale[0];\n        scaleY = direction[1] || keepRatio ? scaleY * startScale[1] : startScale[1];\n\n        if (scaleX === 0) {\n            scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (scaleY === 0) {\n            scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n\n        const nowDist = [scaleX / startScale[0], scaleY / startScale[1]];\n        let scale = [scaleX, scaleY];\n        let snapDirection = direction;\n\n        if (moveable.props.groupable) {\n            snapDirection = [\n                (nowDist[0] >= 0 ? 1 : -1) * direction[0],\n                (nowDist[1] >= 0 ? 1 : -1) * direction[1],\n            ];\n            const snapRenderInfo = state.snapRenderInfo || {};\n            const stateDirection = snapRenderInfo.direction;\n\n            if (isArray(stateDirection) && (stateDirection[0] || stateDirection[1])) {\n                state.snapRenderInfo = { direction };\n            }\n        }\n        let snapDist = [0, 0];\n\n        if (!pinchFlag) {\n            snapDist = checkSnapScale(\n                moveable,\n                nowDist,\n                direction,\n                snapDirection,\n                datas.fixedPosition,\n                parentDist,\n                datas,\n            );\n        }\n\n        if (keepRatio) {\n            if (direction[0] && direction[1] && snapDist[0] && snapDist[1]) {\n                if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {\n                    snapDist[1] = 0;\n                } else {\n                    snapDist[0] = 0;\n                }\n            }\n\n            const isNoSnap = !snapDist[0] && !snapDist[1];\n\n            if (isNoSnap) {\n                if (isWidth) {\n                    nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n                } else {\n                    nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n                }\n            }\n\n            if (\n                (direction[0] && !direction[1])\n                || (snapDist[0] && !snapDist[1])\n                || (isNoSnap && isWidth)\n            ) {\n                nowDist[0] += snapDist[0];\n                const snapHeight = getKeepRatioHeight(width * nowDist[0] * startScale[0], isWidth, ratio);\n\n                nowDist[1] = snapHeight / height / startScale[1];\n            } else if (\n                (!direction[0] && direction[1])\n                || (!snapDist[0] && snapDist[1])\n                || (isNoSnap && !isWidth)\n            ) {\n                nowDist[1] += snapDist[1];\n                const snapWidth = getKeepRatioWidth(height * nowDist[1] * startScale[1], isWidth, ratio);\n\n                nowDist[0] = snapWidth / width / startScale[0];\n            }\n        } else {\n            nowDist[0] += snapDist[0];\n            nowDist[1] += snapDist[1];\n            if (!snapDist[0]) {\n                nowDist[0] = throttle(nowDist[0] * startScale[0], throttleScale!) / startScale[0];\n            }\n            if (!snapDist[1]) {\n                nowDist[1] = throttle(nowDist[1] * startScale[1], throttleScale!) / startScale[1];\n            }\n        }\n        if (nowDist[0] === 0) {\n            nowDist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        if (nowDist[1] === 0) {\n            nowDist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;\n        }\n        const delta = [nowDist[0] / prevDist[0], nowDist[1] / prevDist[1]];\n        scale = multiply2(nowDist, startScale);\n\n        datas.prevDist = nowDist;\n\n        if (scaleX === prevDist[0] && scaleY === prevDist[1] && !parentMoveable) {\n            return false;\n        }\n        const inverseDelta = !parentFlag && pinchFlag\n            ? [0, 0]\n            : getScaleDist(moveable, delta, direction, dragClient);\n\n        const params = fillParams<OnScale>(moveable, e, {\n            scale,\n            direction,\n            dist: nowDist,\n            delta,\n            transform: `${transform} scale(${scaleX}, ${scaleY})`,\n            isPinch: !!pinchFlag,\n            drag: Draggable.drag(\n                moveable,\n                setCustomDrag(moveable.state, inverseDelta, inputEvent, false),\n            ) as OnDrag,\n        });\n        triggerEvent(moveable, \"onScale\", params);\n\n        return params;\n    },\n    dragControlEnd(moveable: MoveableManager<ScalableProps>, e: any) {\n        const { datas, isDrag } = e;\n        if (!datas.isScale) {\n            return false;\n        }\n\n        datas.isScale = false;\n\n        triggerEvent(moveable, \"onScaleEnd\", fillParams<OnScaleEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n    dragGroupControlCondition: directionCondition,\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n\n        const params = this.dragControlStart(moveable, e);\n\n        if (!params) {\n            return false;\n        }\n        const direction = params.direction;\n        const startPos = getAbsoluteFixedPosition(moveable, direction);\n\n        datas.startPos = startPos;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControlStart\",\n            datas,\n            (child, childDatas) => {\n                const pos = getAbsoluteFixedPosition(child, direction);\n                const [originalX, originalY] = caculate(\n                    createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3),\n                    [pos[0] - startPos[0], pos[1] - startPos[1], 1],\n                    3,\n                );\n                childDatas.originalX = originalX;\n                childDatas.originalY = originalY;\n\n                return e;\n            },\n        );\n\n        const nextParams: OnScaleGroupStart = {\n            ...params,\n            targets: moveable.props.targets!,\n            events,\n        };\n        const result = triggerEvent(moveable, \"onScaleGroupStart\", nextParams);\n\n        datas.isScale = result !== false;\n        return datas.isScale ? nextParams : false;\n    },\n    dragGroupControl(moveable: MoveableGroup, e: any) {\n        const { datas } = e;\n        if (!datas.isScale) {\n            return;\n        }\n        const params = this.dragControl(moveable, e);\n        if (!params) {\n            return;\n        }\n        const keepRatio = moveable.props.keepRatio;\n        const { scale } = params;\n        const startPos = datas.startPos;\n\n        const events = triggerChildAble(\n            moveable,\n            this,\n            \"dragControl\",\n            datas,\n            (_, childDatas) => {\n                const [clientX, clientY] = caculate(\n                    createRotateMatrix(moveable.rotation / 180 * Math.PI, 3),\n                    [\n                        childDatas.originalX * scale[0],\n                        childDatas.originalY * scale[1],\n                        1,\n                    ],\n                    3,\n                );\n\n                return {\n                    ...e,\n                    parentScale: scale,\n                    parentKeepRatio: keepRatio,\n                    dragClient: plus(startPos, [clientX, clientY]),\n                };\n            },\n        );\n        const nextParams: OnScaleGroup = {\n            targets: moveable.props.targets!,\n            events,\n            ...params,\n        };\n\n        triggerEvent(moveable, \"onScaleGroup\", nextParams);\n        return nextParams;\n    },\n    dragGroupControlEnd(moveable: MoveableGroup, e: any) {\n        const { isDrag, datas } = e;\n\n        if (!datas.isScale) {\n            return;\n        }\n        this.dragControlEnd(moveable, e);\n        triggerChildAble(moveable, this, \"dragControlEnd\", datas, e);\n\n        const nextParams = fillParams<OnScaleGroupEnd>(moveable, e, {\n            targets: moveable.props.targets!,\n            isDrag,\n        });\n\n        triggerEvent(moveable, \"onScaleGroupEnd\", nextParams);\n        return isDrag;\n    },\n    /**\n     * @method Moveable.Scalable#request\n     * @param {object} [e] - the Resizable's request parameter\n     * @param {number} [e.direction=[1, 1]] - Direction to scale\n     * @param {number} [e.deltaWidth] - delta number of width\n     * @param {number} [e.deltaHeight] - delta number of height\n     * @param {number} [e.isInstant] - Whether to execute the request instantly\n     * @return {Moveable.Requester} Moveable Requester\n     * @example\n\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"scalable\", { deltaWidth: 10, deltaHeight: 10, isInstant: true });\n     *\n     * // requestStart\n     * const requester = moveable.request(\"scalable\");\n     *\n     * // request\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     * requester.request({ deltaWidth: 10, deltaHeight: 10 });\n     *\n     * // requestEnd\n     * requester.requestEnd();\n     */\n    request() {\n        const datas = {};\n        let distWidth = 0;\n        let distHeight = 0;\n\n        return {\n            isControl: true,\n            requestStart(e: IObject<any>) {\n                return { datas, parentDirection: e.direction || [1, 1] };\n            },\n            request(e: IObject<any>) {\n                distWidth += e.deltaWidth;\n                distHeight += e.deltaHeight;\n\n                return { datas, parentDist: [distWidth, distHeight] };\n            },\n            requestEnd() {\n                return { datas, isDrag: true };\n            },\n        };\n    },\n};\n","import { prefix, getLineStyle, getDirection, getAbsolutePosesByState, triggerEvent, fillParams } from \"../utils\";\nimport {\n    convertDimension, invert, multiply,\n    convertMatrixtoCSS, caculate,\n    createIdentityMatrix,\n    ignoreDimension,\n    multiplyCSS,\n    minus,\n    createWarpMatrix,\n    getRad,\n    plus,\n} from \"@moveable/matrix\";\nimport { NEARBY_POS } from \"../consts\";\nimport { setDragStart, getDragDist, getPosIndexesByDirection } from \"../DraggerUtils\";\nimport MoveableManager from \"../MoveableManager\";\nimport {\n    WarpableProps, ScalableProps, ResizableProps,\n    Renderer, SnappableProps, SnappableState,\n    OnWarpStart, OnWarp, OnWarpEnd,\n} from \"../types\";\nimport { hasClass, dot } from \"@daybrush/utils\";\nimport { renderAllDirections } from \"../renderDirection\";\nimport { hasGuidelines, checkSnapBounds } from \"./Snappable\";\n\nfunction getMiddleLinePos(pos1: number[], pos2: number[]) {\n    return pos1.map((pos, i) => dot(pos, pos2[i], 1, 2));\n}\n\nfunction getTriangleRad(pos1: number[], pos2: number[], pos3: number[]) {\n    // pos1 Rad\n    const rad1 = getRad(pos1, pos2);\n    const rad2 = getRad(pos1, pos3);\n\n    const rad = rad2 - rad1;\n\n    return rad >= 0 ? rad : rad + 2 * Math.PI;\n}\n\nfunction isValidPos(poses1: number[][], poses2: number[][]) {\n    const rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);\n    const rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);\n    const pi = Math.PI;\n\n    if ((rad1 >= pi && rad2 <= pi) || (rad1 <= pi && rad2 >= pi)) {\n        return false;\n    }\n    return true;\n}\n\nexport default {\n    name: \"warpable\",\n    ableGroup: \"size\",\n    props: {\n        warpable: Boolean,\n        renderDirections: Array,\n    },\n    render(moveable: MoveableManager<ResizableProps & ScalableProps & WarpableProps>, React: Renderer) {\n        const { resizable, scalable, warpable } = moveable.props;\n\n        if (resizable || scalable || !warpable) {\n            return;\n        }\n        const { pos1, pos2, pos3, pos4 } = moveable.state;\n\n        const linePosFrom1 = getMiddleLinePos(pos1, pos2);\n        const linePosFrom2 = getMiddleLinePos(pos2, pos1);\n        const linePosFrom3 = getMiddleLinePos(pos1, pos3);\n        const linePosFrom4 = getMiddleLinePos(pos3, pos1);\n        const linePosTo1 = getMiddleLinePos(pos3, pos4);\n        const linePosTo2 = getMiddleLinePos(pos4, pos3);\n        const linePosTo3 = getMiddleLinePos(pos2, pos4);\n        const linePosTo4 = getMiddleLinePos(pos4, pos2);\n\n        return [\n            <div className={prefix(\"line\")} key=\"middeLine1\" style={getLineStyle(linePosFrom1, linePosTo1)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine2\" style={getLineStyle(linePosFrom2, linePosTo2)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine3\" style={getLineStyle(linePosFrom3, linePosTo3)}></div>,\n            <div className={prefix(\"line\")} key=\"middeLine4\" style={getLineStyle(linePosFrom4, linePosTo4)}></div>,\n            ...renderAllDirections(moveable, React),\n        ];\n    },\n    dragControlCondition(e: any) {\n        if (e.isRequest) {\n            return false;\n        }\n        return hasClass(e.inputEvent.target, prefix(\"direction\"));\n    },\n    dragControlStart(\n        moveable: MoveableManager<WarpableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas, inputEvent } = e;\n        const { target } = moveable.props;\n        const { target: inputTarget } = inputEvent;\n        const direction = getDirection(inputTarget);\n\n        if (!direction || !target) {\n            return false;\n        }\n        const state = moveable.state;\n        const {\n            transformOrigin, is3d,\n            targetTransform, targetMatrix,\n            width, height,\n            left, top,\n        } = state;\n\n        datas.datas = {};\n        datas.targetTransform = targetTransform;\n        datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);\n        datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);\n        datas.direction = direction;\n        datas.left = left;\n        datas.top = top;\n\n        setDragStart(moveable, { datas });\n        datas.poses = [\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n        ].map((p, i) => minus(p, transformOrigin));\n\n        datas.nextPoses = datas.poses.map(([x, y]: number[]) => caculate(datas.warpTargetMatrix, [x, y, 0, 1], 4));\n        datas.startMatrix = createIdentityMatrix(4);\n        datas.prevMatrix = createIdentityMatrix(4);\n        datas.absolutePoses = getAbsolutePosesByState(state);\n        datas.posIndexes = getPosIndexesByDirection(direction);\n        state.snapRenderInfo = {\n            direction,\n        };\n\n        const params = fillParams<OnWarpStart>(moveable, e, {\n            set: (matrix: number[]) => {\n                datas.startMatrix = matrix;\n            },\n        });\n        const result = triggerEvent(moveable, \"onWarpStart\", params);\n        if (result !== false) {\n            datas.isWarp = true;\n        }\n        return datas.isWarp;\n    },\n    dragControl(\n        moveable: MoveableManager<WarpableProps & SnappableProps, SnappableState>,\n        e: any,\n    ) {\n        const { datas } = e;\n        let { distX, distY } = e;\n        const {\n            targetInverseMatrix, prevMatrix, isWarp, startMatrix,\n            poses,\n            posIndexes,\n            absolutePoses,\n        } = datas;\n\n        if (!isWarp) {\n            return false;\n        }\n\n        if (hasGuidelines(moveable, \"warpable\")) {\n            const selectedPoses: number[][] = posIndexes.map((index: number) => absolutePoses[index]);\n\n            if (selectedPoses.length > 1) {\n                selectedPoses.push([\n                    (selectedPoses[0][0] + selectedPoses[1][0]) / 2,\n                    (selectedPoses[0][1] + selectedPoses[1][1]) / 2,\n                ]);\n            }\n\n            const {\n                horizontal: horizontalSnapInfo,\n                vertical: verticalSnapInfo,\n            } = checkSnapBounds(\n                moveable,\n                selectedPoses.map(pos => [pos[0] + distX, pos[1] + distY]),\n            );\n\n            distY -= horizontalSnapInfo.offset;\n            distX -= verticalSnapInfo.offset;\n        }\n\n        const dist = getDragDist({ datas, distX, distY }, true);\n        const nextPoses = datas.nextPoses.slice();\n\n        posIndexes.forEach((index: number) => {\n            nextPoses[index] = plus(nextPoses[index], dist);\n        });\n\n        if (!NEARBY_POS.every(\n            nearByPoses => isValidPos(nearByPoses.map(i => poses[i]), nearByPoses.map(i => nextPoses[i])),\n        )) {\n            return false;\n        }\n        const h = createWarpMatrix(\n            poses[0],\n            poses[1],\n            poses[2],\n            poses[3],\n            nextPoses[0],\n            nextPoses[1],\n            nextPoses[2],\n            nextPoses[3],\n        );\n\n        if (!h.length) {\n            return false;\n        }\n\n        const matrix = convertMatrixtoCSS(multiply(targetInverseMatrix, h, 4));\n        const transform = `${datas.targetTransform} matrix3d(${matrix.join(\",\")})`;\n\n        const delta = multiplyCSS(invert(prevMatrix, 4), matrix, 4);\n\n        datas.prevMatrix = matrix;\n\n        triggerEvent(moveable, \"onWarp\", fillParams<OnWarp>(moveable, e, {\n            delta,\n            matrix: multiplyCSS(startMatrix, matrix, 4),\n            multiply: multiplyCSS,\n            dist: matrix,\n            transform,\n        }));\n        return true;\n    },\n    dragControlEnd(\n        moveable: MoveableManager<WarpableProps>,\n        e: any,\n    ) {\n        const { datas, isDrag } = e;\n        if (!datas.isWarp) {\n            return false;\n        }\n        datas.isWarp = false;\n\n        triggerEvent(moveable, \"onWarpEnd\", fillParams<OnWarpEnd>(moveable, e, {\n            isDrag,\n        }));\n        return isDrag;\n    },\n};\n","import { prefix } from \"./utils\";\n\nexport const AREA = prefix(\"area\");\nexport const AREA_PIECES = prefix(\"area-pieces\");\nexport const AREA_PIECE = prefix(\"area-piece\");\nexport const AVOID = prefix(\"avoid\");\n","import MoveableManager from \"../MoveableManager\";\nimport {\n    createWarpMatrix, convertMatrixtoCSS,\n    caculate, convertPositionMatrix, invert, minus, plus,\n} from \"@moveable/matrix\";\nimport { ref } from \"framework-utils\";\nimport { triggerEvent, fillParams, getRect, caculatePoses } from \"../utils\";\nimport { Renderer, GroupableProps, DragAreaProps, OnClick } from \"../types\";\nimport { AREA_PIECE, AREA, AVOID, AREA_PIECES } from \"../classNames\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport { addClass, findIndex, removeClass } from \"@daybrush/utils\";\n\nfunction restoreStyle(moveable: MoveableManager) {\n    const el = moveable.areaElement;\n    const { width, height } = moveable.state;\n\n    removeClass(el, AVOID);\n\n    el.style.cssText += `left: 0px; top: 0px; width: ${width}px; height: ${height}px`;\n}\n\nfunction renderPieces(React: Renderer): any {\n    return (<div key=\"area_pieces\" className={AREA_PIECES}>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n        <div className={AREA_PIECE}></div>\n    </div>);\n}\nexport default {\n    name: \"dragArea\",\n    props: {\n        dragArea: Boolean,\n    },\n    render(moveable: MoveableManager<GroupableProps>, React: Renderer): any[] {\n        const { target, dragArea, groupable } = moveable.props;\n        const { width, height, pos1, pos2, pos3, pos4 } = moveable.state;\n\n        if (groupable) {\n            return [\n                <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA}></div>,\n                renderPieces(React),\n            ];\n        }\n        if (!target || !dragArea) {\n            return [];\n        }\n        const h = createWarpMatrix(\n            [0, 0],\n            [width, 0],\n            [0, height],\n            [width, height],\n            pos1,\n            pos2,\n            pos3,\n            pos4,\n        );\n        const transform = h.length ? `matrix3d(${convertMatrixtoCSS(h).join(\",\")})` : \"none\";\n\n        return [\n            <div key=\"area\" ref={ref(moveable, \"areaElement\")} className={AREA} style={{\n                top: \"0px\",\n                left: \"0px\",\n                width: `${width}px`,\n                height: `${height}px`,\n                transformOrigin: \"0 0\",\n                transform,\n            }}></div>,\n            renderPieces(React),\n        ];\n    },\n    dragStart(moveable: MoveableManager, { datas, clientX, clientY, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        datas.isDragArea = false;\n        datas.inputTarget = inputEvent.target;\n        const areaElement = moveable.areaElement;\n        const {\n            targetClientRect,\n            pos1, pos2, pos3, pos4,\n            width, height,\n            rootMatrix,\n            is3d,\n        } = moveable.state;\n        const { left, top } = targetClientRect;\n        const {\n            left: relativeLeft,\n            top: relativeTop,\n        } = getRect([pos1, pos2, pos3, pos4]);\n        const n = is3d ? 4 : 3;\n        const poses = caculatePoses(rootMatrix, width, height, n);\n        const {\n            left: rootLeft,\n            top: rootTop,\n        } = getRect(poses);\n\n        const rootRelativePos = minus(\n            [clientX, clientY],\n            plus([left - rootLeft, top - rootTop], poses[0]),\n        );\n\n        const [posX, posY] = caculate(\n            invert(rootMatrix, n),\n            convertPositionMatrix(rootRelativePos, n),\n            n,\n        );\n\n        const rects = [\n            { left: relativeLeft, top: relativeTop, width, height: posY - 10 },\n            { left: relativeLeft, top: relativeTop, width: posX - 10, height },\n            { left: relativeLeft, top: relativeTop + posY + 10, width, height: height - posY - 10 },\n            { left: relativeLeft + posX + 10, top: relativeTop, width: width - posX - 10, height },\n        ];\n\n        const children = [].slice.call(areaElement.nextElementSibling!.children) as HTMLElement[];\n        rects.forEach((rect, i) => {\n            children[i].style.cssText\n                = `left: ${rect.left}px;top: ${rect.top}px; width: ${rect.width}px; height: ${rect.height}px;`;\n        });\n        addClass(areaElement, AVOID);\n    },\n    drag(moveable: MoveableManager, { datas, inputEvent }: any) {\n        if (!inputEvent) {\n            return false;\n        }\n        if (!datas.isDragArea) {\n            datas.isDragArea = true;\n            restoreStyle(moveable);\n        }\n    },\n    dragEnd(moveable: MoveableManager<DragAreaProps>, e: any) {\n        if (!e.inputEvent) {\n            return false;\n        }\n        const { inputEvent, isDragArea, datas } = e;\n        if (!datas.isDragArea) {\n            restoreStyle(moveable);\n        }\n\n        const target = moveable.state.target!;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget)) {\n            return;\n        }\n        const containsTarget = target.contains(inputTarget);\n\n        triggerEvent(moveable, \"onClick\", fillParams<OnClick>(moveable, e, {\n            inputTarget,\n            isTarget: target === inputTarget,\n            containsTarget,\n        }));\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragGroupEnd(\n        moveable: MoveableGroup,\n        e: any,\n    ) {\n        const { inputEvent, isDragArea, datas } = e;\n        if (!inputEvent) {\n            return false;\n        }\n        if (!isDragArea) {\n            restoreStyle(moveable);\n        }\n        const prevInputTarget = datas.inputTarget;\n        const inputTarget = inputEvent.target;\n\n        if (isDragArea || moveable.isMoveableElement(inputTarget) || prevInputTarget === inputTarget) {\n            return;\n        }\n        const targets = moveable.props.targets!;\n        let targetIndex = targets.indexOf(inputTarget);\n        const isTarget = targetIndex > -1;\n        let containsTarget = false;\n\n        if (targetIndex === -1) {\n            targetIndex = findIndex(targets, parentTarget => parentTarget.contains(inputTarget));\n            containsTarget = targetIndex > -1;\n        }\n\n        triggerEvent(moveable, \"onClickGroup\", fillParams(moveable, e, {\n            targets,\n            inputTarget,\n            targetIndex,\n            isTarget,\n            containsTarget,\n        }));\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { prefix, getControlTransform } from \"../utils\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"origin\",\n    props: {\n        origin: Boolean,\n    },\n    render(moveable: MoveableManager, React: Renderer): any {\n        if (!moveable.props.origin) {\n            return null;\n        }\n        const { beforeOrigin, rotation } = moveable.state;\n\n        return [\n            <div className={prefix(\"control\", \"origin\")}\n                style={getControlTransform(rotation, beforeOrigin)} key=\"beforeOrigin\"></div>,\n        ];\n    },\n};\n","import MoveableManager from \"../MoveableManager\";\nimport { ScrollableProps, OnScroll } from \"../types\";\nimport { triggerEvent, fillParams } from \"../utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport DragScroll from \"@scena/dragscroll\";\n\nfunction getDefaultScrollPosition(e: { scrollContainer: HTMLElement, direction: number[] }) {\n    const scrollContainer = e.scrollContainer;\n\n    return [\n        scrollContainer.scrollLeft,\n        scrollContainer.scrollTop,\n    ];\n}\n\nexport default {\n    name: \"scrollable\",\n    canPinch: true,\n    props: {\n        scrollable: Boolean,\n        scrollContainer: Object,\n        scrollThreshold: Number,\n    },\n    dragStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const props = moveable.props;\n        const {\n            scrollContainer = moveable.getContainer(),\n        } = props;\n\n        const dragScroll = new DragScroll();\n\n        e.datas.dragScroll = dragScroll;\n\n        const draggerName = e.isControl ? \"controlDragger\" : \"targetDragger\";\n        const targets = e.targets;\n\n        dragScroll.on(\"scroll\", ({ container, direction }) => {\n            const params = fillParams<OnScroll>(moveable, e, {\n                scrollContainer: container,\n                direction,\n            }) as any;\n\n            const eventName = targets ? \"onScrollGroup\" : \"onScroll\" as any;\n            if (targets) {\n                params.targets = targets;\n            }\n            triggerEvent(moveable, eventName, params);\n        }).on(\"move\", ({ offsetX, offsetY }) => {\n            moveable[draggerName].scrollBy(offsetX, offsetY, e.inputEvent, false);\n        });\n        dragScroll.dragStart(e, {\n            container: scrollContainer as HTMLElement,\n        });\n    },\n    checkScroll(moveable: MoveableManager<ScrollableProps>, e: any) {\n        const {\n            dragScroll,\n        } = e.datas;\n        if (!dragScroll) {\n            return;\n        }\n        const {\n            scrollContainer = moveable.getContainer(),\n            scrollThreshold = 0,\n            getScrollPosition = getDefaultScrollPosition,\n        } = moveable.props;\n\n        dragScroll.drag(e, {\n            container: scrollContainer,\n            threshold: scrollThreshold,\n            getScrollPosition: (ev: any) => {\n                return getScrollPosition({ scrollContainer: ev.container, direction: ev.direction });\n            },\n        });\n\n        return true;\n    },\n    drag(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.checkScroll(moveable, e);\n    },\n    dragEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        e.datas.dragScroll.dragEnd();\n        e.datas.dragScroll = null;\n    },\n    dragControlStart(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.dragStart(moveable, { ...e, isControl: true });\n    },\n    dragControl(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.drag(moveable, e);\n    },\n    dragControlEnd(moveable: MoveableManager<ScrollableProps>, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroup(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupEnd(moveable: MoveableGroup, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n    dragGroupControlStart(moveable: MoveableGroup, e: any) {\n        return this.dragStart(moveable, e);\n    },\n    dragGroupContro(moveable: MoveableGroup, e: any) {\n        return this.drag(moveable, { ...e, targets: moveable.props.targets });\n    },\n    dragGroupControEnd(moveable: MoveableGroup, e: any) {\n        return this.dragEnd(moveable, e);\n    },\n};\n","export default {\n    name: \"\",\n    props: {\n        target: Object,\n        container: Object,\n        dragArea: Boolean,\n        origin: Boolean,\n        transformOrigin: Array,\n        edge: Boolean,\n        ables: Array,\n        className: String,\n        pinchThreshold: Number,\n    },\n};\n","import Pinchable from \"./Pinchable\";\nimport Rotatable from \"./Rotatable\";\nimport Draggable from \"./Draggable\";\nimport Resizable from \"./Resizable\";\nimport Scalable from \"./Scalable\";\nimport Warpable from \"./Warpable\";\nimport Snappable from \"./Snappable\";\nimport DragArea from \"./DragArea\";\nimport Origin from \"./Origin\";\nimport Scrollable from \"./Scrollable\";\nimport Default from \"./Default\";\n\nexport const MOVEABLE_ABLES = [\n    Default, Snappable, Pinchable, Draggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, DragArea, Origin,\n] as const;\n","import { refs } from \"framework-utils\";\nimport MoveableGroup from \"../MoveableGroup\";\nimport MoveableManager from \"../MoveableManager\";\nimport { Renderer } from \"../types\";\n\nexport default {\n    name: \"groupable\",\n    props: {\n        defaultGroupRotate: Number,\n        groupable: Boolean,\n    },\n    render(moveable: MoveableGroup, React: Renderer): any[] {\n        const targets = moveable.props.targets || [];\n\n        moveable.moveables = [];\n        const { left, top } = moveable.state;\n        const position = { left, top };\n\n        return targets.map((target, i) => {\n            return <MoveableManager\n                key={\"moveable\" + i}\n                ref={refs(moveable, \"moveables\", i)}\n                target={target}\n                origin={false}\n                parentMoveable={moveable}\n                parentPosition={position}\n            />;\n        });\n    },\n};\n","import MoveableManager from \"./MoveableManager\";\nimport { GroupableProps, MoveableManagerProps } from \"./types\";\nimport ChildrenDiffer from \"@egjs/children-differ\";\nimport { getAbleDragger } from \"./getAbleDragger\";\nimport Groupable from \"./ables/Groupable\";\nimport { MIN_NUM, MAX_NUM, TINY_NUM } from \"./consts\";\nimport { getTargetInfo, throttle, getAbsolutePosesByState, equals } from \"./utils\";\nimport { plus, rotate } from \"@moveable/matrix\";\n\nfunction getMaxPos(poses: number[][][], index: number) {\n    return Math.max(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.max(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getMinPos(poses: number[][][], index: number) {\n    return Math.min(...poses.map(([pos1, pos2, pos3, pos4]) => {\n        return Math.min(pos1[index], pos2[index], pos3[index], pos4[index]);\n    }));\n}\nfunction getGroupRect(moveables: MoveableManager[], rotation: number) {\n    if (!moveables.length) {\n        return [0, 0, 0, 0];\n    }\n\n    const moveablePoses = moveables.map(({ state }) => getAbsolutePosesByState(state));\n    let minX = MAX_NUM;\n    let minY = MAX_NUM;\n    let groupWidth = 0;\n    let groupHeight = 0;\n    const fixedRotation = throttle(rotation, TINY_NUM);\n\n    if (fixedRotation % 90) {\n        const rad = rotation / 180 * Math.PI;\n        const a1 = Math.tan(rad);\n        const a2 = -1 / a1;\n        const b1s = [MIN_NUM, MAX_NUM];\n        const b2s = [MIN_NUM, MAX_NUM];\n\n        moveablePoses.forEach(poses => {\n            poses.forEach(pos => {\n                // ax + b = y\n                //  = y - ax\n                const b1 = pos[1] - a1 * pos[0];\n                const b2 = pos[1] - a2 * pos[0];\n\n                b1s[0] = Math.max(b1s[0], b1);\n                b1s[1] = Math.min(b1s[1], b1);\n                b2s[0] = Math.max(b2s[0], b2);\n                b2s[1] = Math.min(b2s[1], b2);\n            });\n        });\n\n        b1s.forEach(b1 => {\n            // a1x + b1 = a2x + b2\n            b2s.forEach(b2 => {\n                // (a1 - a2)x = b2 - b1\n                const x = (b2 - b1) / (a1 - a2);\n                const y = a1 * x + b1;\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n            });\n        });\n        const rotatePoses = moveablePoses.map(([pos1, pos2, pos3, pos4]) => {\n\n            return [\n                rotate(pos1, -rad),\n                rotate(pos2, -rad),\n                rotate(pos3, -rad),\n                rotate(pos4, -rad),\n            ];\n        });\n        groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);\n        groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);\n\n    } else {\n        minX = getMinPos(moveablePoses, 0);\n        minY = getMinPos(moveablePoses, 1);\n        groupWidth = getMaxPos(moveablePoses, 0) - minX;\n        groupHeight = getMaxPos(moveablePoses, 1) - minY;\n\n        if (fixedRotation % 180) {\n            const changedWidth = groupWidth;\n\n            groupWidth = groupHeight;\n            groupHeight = changedWidth;\n        }\n    }\n    return [minX, minY, groupWidth, groupHeight];\n}\n\nclass MoveableGroup extends MoveableManager<GroupableProps, any> {\n    public static defaultProps = {\n        ...MoveableManager.defaultProps,\n        transformOrigin: [\"50%\", \"50%\"],\n        groupable: true,\n        dragArea: true,\n        keepRatio: true,\n        targets: [],\n        defaultGroupRotate: 0,\n    };\n    public differ: ChildrenDiffer<HTMLElement | SVGElement> = new ChildrenDiffer();\n    public moveables: MoveableManager[] = [];\n    public rotation: number = 0;\n\n    public updateEvent(prevProps: MoveableManagerProps<GroupableProps>) {\n        const state = this.state;\n        const props = this.props;\n\n        if (!state.target) {\n            state.target = this.areaElement;\n\n            this.controlBox.getElement().style.display = \"block\";\n            this.targetDragger = getAbleDragger(this, state.target!, \"targetAbles\", \"Group\");\n            this.controlDragger = getAbleDragger(this, this.controlBox.getElement(), \"controlAbles\", \"GroupControl\");\n        }\n        const isContainerChanged = !equals(prevProps.container, props.container);\n\n        if (isContainerChanged) {\n            state.container = props.container;\n        }\n        const { added, changed, removed } = this.differ.update(props.targets!);\n\n        if (isContainerChanged || added.length || changed.length || removed.length) {\n            this.updateRect();\n        }\n    }\n    public checkUpdate() {\n        this.updateAbles();\n    }\n\n    public updateRect(type?: \"Start\" | \"\" | \"End\", isTarget?: boolean, isSetState: boolean = true) {\n        if (!this.controlBox) {\n            return;\n        }\n        this.moveables.forEach(moveable => {\n            moveable.updateRect(type, false, false);\n        });\n\n        const state = this.state;\n        const props = this.props;\n        const target = state.target! || props.target!;\n\n        if (!isTarget || (type !== \"\" && props.updateGroup)) {\n            // reset rotataion\n            this.rotation = props.defaultGroupRotate!;\n        }\n        const rotation = this.rotation;\n        const [left, top, width, height] = getGroupRect(this.moveables, rotation);\n\n        // tslint:disable-next-line: max-line-length\n        target.style.cssText += `left:0px;top:0px;width:${width}px; height:${height}px;transform:rotate(${rotation}deg)`;\n        state.width = width;\n        state.height = height;\n\n        const container = this.getContainer();\n        const info = getTargetInfo(\n            target,\n            this.controlBox.getElement(),\n            this.getContainer(),\n            this.props.rootContainer || container,\n            state,\n        );\n        const pos = [info.left!, info.top!];\n        [\n            info.pos1,\n            info.pos2,\n            info.pos3,\n            info.pos4,\n        ] = getAbsolutePosesByState(info as Required<typeof info>);\n        info.origin = plus(pos, info.origin!);\n        info.beforeOrigin = plus(pos, info.beforeOrigin!);\n\n        const clientRect = info.targetClientRect!;\n\n        clientRect.top += (top - info.top!) - state.top;\n        clientRect.left += (left - info.left!) - state.left;\n\n        this.updateState(\n            {\n                ...info,\n                left: left - info.left!,\n                top: top - info.top!,\n            },\n            isSetState,\n        );\n    }\n    public triggerEvent(name: string, e: any): any {\n        if (name.indexOf(\"Group\") > -1) {\n            return super.triggerEvent(name as any, e);\n        }\n    }\n    protected updateAbles() {\n        super.updateAbles([...this.props.ables!, Groupable], \"Group\");\n    }\n}\n\nexport default MoveableGroup;\n","import * as React from \"react\";\nimport { MoveableProps, Able, MoveableInterface, RectInfo, AbleRequestParam, Requester } from \"./types\";\nimport MoveableManager from \"./MoveableManager\";\nimport { MOVEABLE_ABLES } from \"./ables/consts\";\nimport MoveableGroup from \"./MoveableGroup\";\nimport { ref } from \"framework-utils\";\nimport { isArray } from \"@daybrush/utils\";\nimport Groupable from \"./ables/Groupable\";\n\nexport default class Moveable<T = {}> extends React.PureComponent<MoveableProps & T> implements MoveableInterface {\n    public moveable!: MoveableManager<MoveableProps> | MoveableGroup;\n    public render() {\n        const props = this.props;\n        const ables: Able[] = props.ables as Able[] || [];\n        const target = this.props.target || this.props.targets;\n        const isArr = isArray(target);\n        const isGroup = isArr && (target as any[]).length > 1;\n\n        if (isGroup) {\n            const nextProps = {\n                ...this.props,\n                target: null,\n                targets: target as any[],\n                ables: [...MOVEABLE_ABLES, Groupable, ...ables],\n            };\n            return <MoveableGroup key=\"group\" ref={ref(this, \"moveable\")}\n                {...nextProps} />;\n        } else {\n            const moveableTarget = isArr ? (target as any[])[0] : target;\n\n            return <MoveableManager<MoveableProps> key=\"single\" ref={ref(this, \"moveable\")}\n                {...{ ...this.props, target: moveableTarget, ables: [...MOVEABLE_ABLES, ...ables] }} />;\n        }\n    }\n    /**\n     * Check if the target is an element included in the moveable.\n     * @method Moveable#isMoveableElement\n     * @param - the target\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"click\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *         moveable.target = e.target;\n     *     }\n     * });\n     */\n    public isMoveableElement(target: HTMLElement | SVGElement): boolean {\n        return this.moveable.isMoveableElement(target);\n    }\n    /**\n     * You can drag start the Moveable through the external `MouseEvent`or `TouchEvent`. (Angular: ngDragStart)\n     * @method Moveable#dragStart\n     * @param - external `MouseEvent`or `TouchEvent`\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (!moveable.isMoveableElement(e.target)) {\n     *          moveable.dragStart(e);\n     *     }\n     * });\n     */\n    public dragStart(e: MouseEvent | TouchEvent): void {\n        this.moveable.dragStart(e);\n    }\n\n    /**\n     * Whether the coordinates are inside Moveable\n     * @method Moveable#isInside\n     * @param - x coordinate\n     * @param - y coordinate\n     * @return - True if the coordinate is in moveable or false\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * document.body.addEventListener(\"mousedown\", e => {\n     *     if (moveable.isInside(e.clientX, e.clientY)) {\n     *          console.log(\"inside\");\n     *     }\n     * });\n     */\n    public isInside(clientX: number, clientY: number): boolean {\n        return this.moveable.isInside(clientX, clientY);\n    }\n\n    /**\n     * If the width, height, left, and top of all elements change, update the shape of the moveable.\n     * @method Moveable#updateRect\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * window.addEventListener(\"resize\", e => {\n     *     moveable.updateRect();\n     * });\n     */\n    public updateRect(): void {\n        this.moveable.updateRect();\n    }\n\n    /**\n     * If the width, height, left, and top of the only target change, update the shape of the moveable.\n     * @method Moveable#updateTarget\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.updateTarget();\n     */\n    public updateTarget(): void {\n        this.moveable.updateTarget();\n    }\n\n    /**\n     * You can get the vertex information, position and offset size information of the target based on the container.\n     * @method Moveable#getRect\n     * @return - The Rect Info\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * const rectInfo = moveable.getRect();\n     */\n    public getRect(): RectInfo {\n        return this.moveable.getRect();\n    }\n\n    /**\n     * Request able through a method rather than an event.\n     * At the moment of execution, requestStart is executed,\n     * and then request and requestEnd can be executed through Requester.\n     * @method Moveable#request\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Draggable.html#request|Draggable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Resizable.html#request|Resizable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Scalable.html#request|Scalable Requester}\n     * @see {@link https://daybrush.com/moveable/release/latest/doc/Moveable.Rotatable.html#request|Rotatable Requester}\n     * @param - ableName\n     * @param - request to be able params. If isInstant is true, request and requestEnd are executed immediately.\n     * @return - Able Requester. If there is no request in able, nothing will work.\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * // Instantly Request (requestStart - request - requestEnd)\n     * moveable.request(\"draggable\", { deltaX: 10, deltaY: 10, isInstant: true });\n     *\n     * // Start move\n     * const requester = moveable.request(\"draggable\");\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.request({ deltaX: 10, deltaY: 10 });\n     * requester.requestEnd();\n     */\n    public request(ableName: string, params?: AbleRequestParam): Requester {\n        return this.moveable.request(ableName, params);\n    }\n    /**\n     * Remove the Moveable object and the events.\n     * @method Moveable#destroy\n     * @example\n     * import Moveable from \"moveable\";\n     *\n     * const moveable = new Moveable(document.body);\n     *\n     * moveable.destroy();\n     */\n    public destroy(): void {\n        this.moveable.componentWillUnmount();\n    }\n}\n"]},"metadata":{},"sourceType":"module"}